---
layout: post
title: 原型属性屏蔽
categories: [Javascript]
description: 原型属性屏蔽
keywords: prototype, __proto__, defineProperty, setter, writable
---

## 模拟属性屏蔽

我们简单实现构造一个原型含有属性`a`的原型对象`obj`

```js
let proto = {
  a: 'this is a',
}
let obj = Object.create(proto)
console.log('it should be [true]:', proto.isPrototypeOf(obj))
console.log('it should be [this is a]:', obj.a)
obj.a = 'change'
console.log('it should be [changed]:', obj.a)
```

可以得知，一般情况下：
* 当原型中存在同名属性时，会被底层属性赋值产生的同名属性屏蔽

### 属性屏蔽的三种情况

当`a`不直接存在于`obj`，而是存在于`obj`的原型上时，执行`obj.a = 'newValue'`时可能的三种情况：
1. **一般情况，同名可屏蔽**当`prototype`存在同名属性值，并且**没有标记为只读**(`writable: true`)时，那么会在`obj`添加一个同名属性，产生属性屏蔽
2. **原型存在同名只读属性，无法屏蔽**当`prototype`存在同名属性值，并且**被标记为只读**(`writable: false`)时，那么无法添加同名属性，即无法屏蔽
3. **原型存在同名setter，无法屏蔽，必定执行**当`prototype`存在同名属性值，并且是一个**setter**时，此时无法覆盖setter，并且一定会调用这个setter

### 原型存在同名只读属性，无法屏蔽

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
let proto = Object.defineProperty({}, 'a', {
  value: 'this is a',
  writable: false,
})
let obj = Object.create(proto)
console.log('it should be [true]:', proto.isPrototypeOf(obj))
console.log('it should be [this is a]:', obj.a)
// prototype存在同名readonly属性，无法添加同名属性，无法屏蔽
obj.a = 'change'
console.log('it should be [this is a]:', obj.a)
</iframe>

### 原型存在同名setter，无法屏蔽，必定执行

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
let proto = Object.defineProperty({}, 'a', {
  get() {
    return 'this is a'
  },
  set() {
    console.log('setter was executed!')
  },
})
let obj = Object.create(proto)
console.log('it should be [true]:', proto.isPrototypeOf(obj))
console.log('it should be [this is a]:', obj.a)
// prototype存在同名readonly属性，无法添加同名属性，无法屏蔽
obj.a = 'change' // it should log: setter was executed!
console.log('it should be [this is a]:', obj.a)
</iframe>

---
