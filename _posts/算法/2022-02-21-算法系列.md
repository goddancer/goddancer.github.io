---
layout: post
title: 算法系列
categories: [算法]
description: 算法系列
keywords: 算法系列
---

## 手写类算法

### 实现一个无限累加的sum函数

```javascript
sum(1, 2, 3).valueOf(); //6
sum(2, 3)(2).valueOf(); //7
sum(1)(2)(3)(4).valueOf(); //10
sum(2)(4, 1)(2).valueOf(); //9
sum(1)(2)(3)(4)(5)(6).valueOf(); // 21
```

**核心原理：通过懒计算方式，不断返回一个参数累积的原函数，当最后调用`valueOf`时进行最终计算**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
function sum(...arg) {
  const add = (...rest) => sum(...arg, ...rest)
  add.valueOf = () => arg.reduce((a, c) => a + c, 0)
  return add
}
console.log(sum(1, 2, 3).valueOf())
console.log(sum(2, 3)(2).valueOf())
console.log(sum(1)(2)(3)(4).valueOf())
console.log(sum(2)(4, 1)(2).valueOf())
console.log(sum(1)(2)(3)(4)(5)(6).valueOf())
</iframe>

### 实现一个`once`函数，记忆结果，只执行一次

```javascript
const f = (x) => x;
const onceF = once(f);

//=> 3
onceF(3);
//=> 3
onceF(4);
```

**核心原理：类似于柯里化，返回一个包装函数，当已经执行过时，返回记忆的结果；否则执行一次，返回当前结果**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
function once(fn) {
  let _executed = false, _result
  const _fn = (arg) => {
    if (_executed) {
      return _result
    }
    _result = fn(arg)
    _executed = true
    return _result
  }
  return _fn
}
const f = (x) => x
const onceF = once(f)
console.log(onceF(3))
console.log(onceF(4))
</iframe>

---

[1] []()