---
layout: post
title: 手写系列
categories: [手写实现]
description: 手写系列
keywords: 手写系列
---

## 手写算法

### 实现一个无限累加的sum函数

```javascript
sum(1, 2, 3).valueOf(); //6
sum(2, 3)(2).valueOf(); //7
sum(1)(2)(3)(4).valueOf(); //10
sum(2)(4, 1)(2).valueOf(); //9
sum(1)(2)(3)(4)(5)(6).valueOf(); // 21
```

**核心原理：通过懒计算方式，不断返回一个参数累积的原函数，当最后调用`valueOf`时进行最终计算**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
function sum(...arg) {
  const add = (...rest) => sum(...arg, ...rest)
  add.valueOf = () => arg.reduce((a, c) => a + c, 0)
  return add
}
console.log(sum(1, 2, 3).valueOf())
console.log(sum(2, 3)(2).valueOf())
console.log(sum(1)(2)(3)(4).valueOf())
console.log(sum(2)(4, 1)(2).valueOf())
console.log(sum(1)(2)(3)(4)(5)(6).valueOf())
</iframe>

## 手写实现

### 实现一个`once`函数，记忆结果，只执行一次

```javascript
const f = (x) => x;
const onceF = once(f);

//=> 3
onceF(3);
//=> 3
onceF(4);
```

**核心原理：类似于柯里化，返回一个包装函数，当已经执行过时，返回记忆的结果；否则执行一次，返回当前结果**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
function once(fn) {
  let _executed = false, _result
  const _fn = (arg) => {
    if (_executed) {
      return _result
    }
    _result = fn(arg)
    _executed = true
    return _result
  }
  return _fn
}
const f = (x) => x
const onceF = once(f)
console.log(onceF(3))
console.log(onceF(4))
</iframe>

### 实现一个数组扁平化函数`flatten`

> 有原生实现 [Array.flat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)

```javascript
// [1, 2, 3, 4, [5, 6]]
flatten([1, 2, 3, [4, [5, 6]]]);

// [1, 2, 3, 4, 5, 6]
flatten([1, 2, 3, [4, [5, 6]]], 2);
```

**核心原理：当depth > 1时，递归或自循环**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
// 模拟实现
function flatten(array, depth = 1) {
  let _depth = depth, _result = array.slice(0)
  while(_depth > 0) {
    _depth --
    _result = _result.reduce((a, c) => {
      return a.concat(c)
    }, [])
  }
  return _result
}
console.log(flatten([1, 2, 3, [4, [5, 6]]]))
console.log(flatten([1, 2, 3, [4, [5, 6]]], 2))

// 原生实现
console.log([1, 2, 3, [4, [5, 6]]].flat())
console.log([1, 2, 3, [4, [5, 6]]].flat(2))
</iframe>

### 如何逆序一个字符串

```javascript
// gfedcba
reverseStr('abcdefg');
```

**核心原理：通过数组的`reverse`方法实现**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
const str = 'abcdefg'
// 实现一
console.log(Array.prototype.reverse.call(str.split('')).join(''))

// 实现二
console.log(str.split('').reverse().join(''))
</iframe>

### 统计字符串中出现次数最多的字符及次数

```javascript
//=> ['a', 6]
getFrequentChar("aaabbaaacc");

//=> ['a', 3]
getFrequentChar("aaa");
```

<iframe name="codemirror" font-size="14" src="{{ site.url }}/packages/apps/codemirror/lib/index.html">
const getFrequentChar = (str) => {
  const counted = str.split('').reduce((a, c) => {
    if (a[c]) {
      a[c] += 1
    } else {
      a[c] = 1
    }
    return a
  }, {})
  const sorted = Object.keys(counted).sort((a, b) => counted[b] - counted[a])
  return [sorted[0], counted[sorted[0]]]
}
console.log(getFrequentChar("aaabbaaacc"))
console.log(getFrequentChar("aaa"))
</iframe>

---

[1] []()