---
layout: post
title: 手写系列
categories: [手写实现]
description: 手写系列
keywords: 手写系列
---

## 手写算法

### 实现一个无限累加的sum函数

```javascript
sum(1, 2, 3).valueOf(); //6
sum(2, 3)(2).valueOf(); //7
sum(1)(2)(3)(4).valueOf(); //10
sum(2)(4, 1)(2).valueOf(); //9
sum(1)(2)(3)(4)(5)(6).valueOf(); // 21
```

**核心原理：通过懒计算方式，不断返回一个参数累积的原函数，当最后调用`valueOf`时进行最终计算**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
function sum(...arg) {
  const add = (...rest) => sum(...arg, ...rest)
  add.valueOf = () => arg.reduce((a, c) => a + c, 0)
  return add
}
console.log(sum(1, 2, 3).valueOf())
console.log(sum(2, 3)(2).valueOf())
console.log(sum(1)(2)(3)(4).valueOf())
console.log(sum(2)(4, 1)(2).valueOf())
console.log(sum(1)(2)(3)(4)(5)(6).valueOf())
</iframe>

## 手写实现

### 实现一个`once`函数，记忆结果，只执行一次

```javascript
const f = (x) => x;
const onceF = once(f);

//=> 3
onceF(3);
//=> 3
onceF(4);
```

**核心原理：类似于柯里化，返回一个包装函数，当已经执行过时，返回记忆的结果；否则执行一次，返回当前结果**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
function once(fn) {
  let _executed = false, _result
  const _fn = (arg) => {
    if (_executed) {
      return _result
    }
    _result = fn(arg)
    _executed = true
    return _result
  }
  return _fn
}
const f = (x) => x
const onceF = once(f)
console.log(onceF(3))
console.log(onceF(4))
</iframe>

### 实现一个数组扁平化函数`flatten`

> 有原生实现 [Array.flat](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)

```javascript
// [1, 2, 3, 4, [5, 6]]
flatten([1, 2, 3, [4, [5, 6]]]);

// [1, 2, 3, 4, 5, 6]
flatten([1, 2, 3, [4, [5, 6]]], 2);
```

**核心原理：当depth > 1时，递归或自循环**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
// 模拟实现
function flatten(array, depth = 1) {
  let _depth = depth, _result = array.slice(0)
  while(_depth > 0) {
    _depth --
    _result = _result.reduce((a, c) => {
      return a.concat(c)
    }, [])
  }
  return _result
}
console.log(flatten([1, 2, 3, [4, [5, 6]]]))
console.log(flatten([1, 2, 3, [4, [5, 6]]], 2))

// 原生实现
console.log([1, 2, 3, [4, [5, 6]]].flat())
console.log([1, 2, 3, [4, [5, 6]]].flat(2))
</iframe>

### 如何逆序一个字符串

```javascript
// gfedcba
reverseStr('abcdefg');
```

**核心原理：通过数组的`reverse`方法实现**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
const str = 'abcdefg'
// 实现一
console.log(Array.prototype.reverse.call(str.split('')).join(''))

// 实现二
console.log(str.split('').reverse().join(''))
</iframe>

### 统计字符串中出现次数最多的字符及次数

```javascript
//=> ['a', 6]
getFrequentChar("aaabbaaacc");

//=> ['a', 3]
getFrequentChar("aaa");
```

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
const getFrequentChar = (str) => {
  const counted = str.split('').reduce((a, c) => {
    if (a[c]) {
      a[c] += 1
    } else {
      a[c] = 1
    }
    return a
  }, {})
  const sorted = Object.keys(counted).sort((a, b) => counted[b] - counted[a])
  return [sorted[0], counted[sorted[0]]]
}
console.log(getFrequentChar("aaabbaaacc"))
console.log(getFrequentChar("aaa"))
</iframe>

### 实现一个发布订阅模式`EventEmitter`

**需要特别注意:**
* 因为引用类型数据对比是对比内存地址的特性，为了检测重复绑定以及正确取消事件，需要在传入`callback`时**尽量采用单独声明的方式**
* 因为`once`的`callback`比较特殊，需要在执行以后自动`off`事件，导致`callback`需要在`once`内部重新定义，触发了引用类型的比较问题，所以需要额外定义`_original`存储初始`callback`进行比较

<iframe name="codemirror" font-size="14" src="{{site.url}}/public/vue3-case/index.html#/event-emitter">
</iframe>

### 实现一个`Promise.all`

首先关注一下`Promise.all`的特性：
* 接收一个promise的iterable类型的输入，只返回一个promise实例
* resolve发生在全部输入Promise都执行成功，或者iterable里没有Promise的时候（**需要注意当输入参数包含非Promise值时，这些值将被忽略，但是仍放在返回数组中**）
* 只要有一个Promise执行失败或者输入不合法的Promise时，即调用reject，抛出第一个发生的错误信息
* 当成功时，返回参数的顺序与传入值的顺序一致

我们需要知道：
* 一个Promise，只有在调用resolve/reject时，才会fulfilled/rejected，此时才会执行回调函数

**利用这个特性，答案呼之欲出，一个遍历即可**

需要注意：
* **`Array`是和空对象类似，是无限可枚举的对象，其每一项初始化元素都是`undefined`**
* **所以通过`res.length === promises.length`来判断全部`resolve`是不可行的，因为同步脚标赋值的方式会将小于脚标的所有空值初始化为`undefined`**

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
const arr = []
arr[1] = 1
console.log(arr.length) //  should be 2
</iframe>

<iframe name="codemirror" font-size="14" src="{{ site.url }}/public/codemirror/index.html">
const isPromise = (fn) => {
  return (
    fn && typeof fn.then === 'function' && typeof fn.catch === 'function'
  );
};
const promiseAll = (promises) => {
  return new Promise((fulfill, reject) => {
    if (!promises.length) {
      fulfill(promises)
      return
    }
    let res = [], pending = promises.length
    promises.forEach((it, i, s) => {
      if (isPromise(it)) {
        it.then((_res) => {
          res[i] = _res
          if (!--pending) {
            fulfill(res);
          }
        }).catch((_err) => {
          reject(_err);
        });
      } else {
        res[i] = it
        if (!--pending) {
          fulfill(res);
        }
      }
    })
  });
};
const fn1 = () =>
new Promise((resolve) => {
  setTimeout(() => {
    resolve(0);
  }, 3000);
});
promiseAll([1, fn1(), Promise.resolve(3)]).then((res) => {
  console.log(res);
});
promiseAll([1, fn1(), Promise.resolve(3), Promise.reject(2)]).then((res) => {
  console.log(res);
}).catch(err => {
  console.log(err);
});
</iframe>

---

[1] []()