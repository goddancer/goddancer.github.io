---
layout: post
title: 从浏览器输入URL到页面呈现发生了什么
categories: [Javascript]
description: 从浏览器输入URL到页面呈现发生了什么
keywords: url, browser, http, https, ssl, tcp, dns
---

## 如何判断当前输入的是URL还是搜索的关键字

首先我们需要知道，如果是输入标砖的URL的话，会有以下特征：
* Protocol **http/s://**，使用HTTP或HTTPS协议，同时协议后跟随有效主机名称格式字符(一般是ASCII字符)，此时会按照地址进行请求解析，即使域名不合法，因为在响应之前无法判断域名或地址是否合法
* 比较特殊的是文件协议，如果输入的值为**file://**协议，会根据不同浏览器的安全策略，访问本地资源
* 当协议或者主机不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎
  * 大部分情况下，URL会带有一些特定的字符串，用来告知搜索引擎本次搜索来源于哪个浏览器

## 请求前字符转换

* 当用户输入的内容为非ASCII的unicode字符时，会将这部分字符进行编码转换
  * ASCII unicode字符主要为**`a-z`,`A-Z`,`0-9`,`-`,`.`**

## HSTS列表检查

**HSTS是HTTP严格安全传输(HTTP Strict Transport Security)的缩写**，这是一种网站用来声明他们只能使用安全链接HTTPS访问的方法，一般有两种途径：
1. **将域名添加到浏览器HSTS预加载列表**，这个列表是固化在浏览器，随着浏览器版本一同发布的，实在请求发生之前进行检查，从而决定当前请求是否必须使用HTTPS协议发出。**这种预加载的形式是很安全的，因为不会存在网络中间人攻击的可能**
* 申请添加这个列表会比较麻烦，而且周期比较长，因为必须随着浏览器版本发布一同添加或者删除，详细步骤可以参考底部文章
2. **请求时HSTS检查**，为什么说这个是请求时检查呢，因为没有固化到浏览器本地，所以需要通过第一次请求到服务器，由服务器返回声明头`Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`，表示接下来的很长一段时间里(这里是1年)，都必须使用HTTPS进行请求，此时在后续的请求中，不超过缓存时间再次请求同网站，就会强制使用HTTPS请求
* 需要注意的是，这种方式并不够安全，因为加入第一次请求是使用HTTP协议发出，就有可能被中间人拦截，从而导致攻击发生；也正是因为这一点，**HSTS的动态设定，必须透过HTTPS请求才有效**，防止中间人通过劫持HTTP协议请求，对HSTS头进行操作。

## DNS解析

* 首先查询浏览器DNS缓存，如果有直接返回(要查看chrome中的缓存，打开[chrome://net-internals/#dns](chrome://net-internals/#dns))
* 如果没有缓存，继续检查操作系统hosts缓存，不同系统可能存储位置不一样，unix和类unix系统一般存储在`/etc/hosts`，[详细参考](https://en.wikipedia.org/wiki/Hosts_%28file%29#Location_in_the_file_system)
* 如果依旧没有缓存，则会向本地网络提供商(如移动、联通、局域网等网络提供商)设置的DNS服务器发送一条DNS查询请求进行查询，也可以通过系统网络配置，指定信任的DNS服务器地址(如114等)
* 如果本地DNS服务器存在DNS缓存，则会直接返回
* 假如所有DNS服务器都没有DNS缓存，以`a.example.com`为例，我们的查询方式为：
  * 我们向根服务器/查询`a.example.com`的DNS记录，根服务器没有具体记录，返回eTLD com的DNS服务器地址
    * 需要注意，中国互联网发展较晚，根服务器的源服务器都在国外，国内的根服务器是一个备份服务器
  * 继续向eTLD DNS服务器查询，若没有具体记录，返回eTLD + 1的DNS服务器地址
  * 继续向eTLD + 1 DNS服务器查询，此时查询到eTLD+ 2 `a.example.com`地址

## TCP

TCP即传输控制协议(Transmission Control Protocol)。整个过程可以简单的理解为三次握手和四次挥手。

* SYN：连接请求/连接接收 报文
* ACK：确认报文

其中三次握手用来建立TCP连接（为什么？）：
* 第一次握手，客户端发送SYN报文给服务器。**客户端发送，服务器接收**
  * 服务器：确认客户端发送正常，自己接收正常
  * 客户端：无可确认信息
* 第二次握手，服务器发送SYN报文给客户端。**服务器发送，客户端接收**
  * 客户端：确认自己发送正常，接收正常；确认服务器接收正常，发送正常
  * 服务器：无可确认信息
* 第三次握手，客户端发送ACK报文给服务器
  * 服务器：确认自己发送正常，接收正常；确认客户端发送正常，接收正常

* FIN：连接终止报文
* ACK：确认报文

需要四次挥手断开TCP连接（为什么？）：
* 服务端不能直接关闭TCP连接，因为在关闭之前需要接收到ACK确认报文，才能确认可进行操作，所以需要存在一个中间状态，成为**半关闭(half-close)**
* 客户端计划断开TCP连接：
  * 客户端发送FIN报文给服务器，请求断开TCP，发送完毕，客户端TCP半关闭，等待服务器确认
  * 服务器收到FIN，发送ACK给到客户端，客户端确认关闭，TCP连接释放
* 服务端计算断开TCP连接：
  * 同上

## SSL



---

[1] [HSTS](https://segmentfault.com/a/1190000022316260)

[2] [what-happens-when](https://github.com/skyline75489/what-happens-when-zh_CN)

[3] [TCP](https://segmentfault.com/a/1190000039165592)