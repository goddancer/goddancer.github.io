[
    {
        "name": "URL反转",
        "desc": "给定形如 `www.toutiao.com` 的 URL，将其转换成 `com.toutiao.www` 的形式，要求必须原地操作",
        "answer": "1. 原地全部翻转一遍；\n2. 遍历遇到&#34;.&#34;，继续翻转该部分字符串；\n该题目重点考察编码，需要保证代码简洁，要不不允许使用字符串库函数",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "判断单向链表是否有环",
        "desc": "<p>判断一个链表中是否有环</p><p>例如：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D</p><p>D指向B形成环</p><p>要求：在空间复杂度O(1)的情况下，时间复杂度最小</p>",
        "answer": "<p>创建两个指针slow，fast，同时指向这个链表的头节点。</p><p>然后让两个指针开始循环移动</p><p>slow每次向下移动一个节点，fast每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环</p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表",
            "单向链表"
        ]
    },
    {
        "name": "给定两个链表，求它们交叉节点",
        "desc": "1.  已知两个链表, 从某个节点开始就交叉了\n2.  已知这两个链表的头节点, 求出交叉的节点",
        "answer": "1. 依次遍历两个链表分别得到链表的长度M和N\n2. 然后让长的那个一个从头开始走|M-N|的步数;\n3. 两个指针同时走, 直到碰头",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "判断一个IP是否是国内",
        "desc": "如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段",
        "answer": "1. 将ip地址通过位移运算转成int\n2. 对ip地址进行排序(可以考察任意一种排序算法)\n3. 二分查找",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "计算机基础",
            "查找",
            "编程",
            "基础算法"
        ]
    },
    {
        "name": "用户在线峰值",
        "desc": "已知一天内用户登录登出的日志（数据量较大），求这一天用户在线的最大峰值和持续时间段\n- 日志包含字段（userid, login_time, logout_time）\n- 登录登出时间精确到秒\n",
        "answer": "可以将这一天看成0-24*3600的离散的时间点，构造一个dict\n每个用户在login_time对应value+1,logout_time对应value-1\n得到用户在线数量的变化趋势，然后再遍历此dict求和\n难点：\n- 想不到先求变化趋势\n- 峰值时间段可能存在多个\n```\ndef get_max(logs):\n    log_count = {}\n    for log in logs:\n        login_time = log['login_time']\n        logout_time = log['logout_time']\n        log_count[login_time] = log_count.setdefault(login_time, 0) + 1\n        log_count[logout_time] = log_count.setdefault(logout_time, 0) - 1\n    max, current_users, start, end, is_max, timeline = (0, 0, 0, 0, False, [])\n    keys = log_count.keys()\n    keys.sort(lambda a, b: a - b)\n    for time_node in keys:\n        current_users = current_users + log_count[time_node]\n        if current_users &gt; max:\n            max = current_users\n            start = time_node\n            is_max = True\n        elif current_users < max:\n            if is_max:\n                end = time_node\n                is_max = False\n        else:\n            if is_max:\n                end = time_node\n            else:\n                timeline.append((start, end))\n                start = time_node\n                is_max = True\n    timeline.append((start, end))\n    return max, timeline\n```\n\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "股票买卖问题",
        "desc": "给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？日期不重叠的情况下，可以买卖多次呢？\n输入: {100, 80, 120, 130, 70, 60, 100, 125} \n只能买一次：65（60 买进，125 卖出）\n可以买卖多次: 115（80买进，130卖出；60 买进，126卖出）\n\n提示：不用输出买卖的序列，只需要得到最大利润\n\n",
        "answer": "1. 对于只能买一次的情况：\n\n```\n    public static int maximumProfit(int[] stockPrices)\n    {\n        int profit = 0;\n        int minimumPrice = Integer.MAX_VALUE;\n        /* \n         * 对于给定的一天，最大利润等于 - \n         * max(昨天为止的最大利润, 当天的价格 - 之前的最小价格)\n         */\n        for(int i = 0; i < stockPrices.length; i++)\n        {\n            profit = Math.max(profit, stockPrices[i] - minimumPrice);\n            minimumPrice = Math.min(stockPrices[i], minimumPrice);\n        }    \n        return profit;\n    }\n```\n\n2. 对于可以买卖多次的情况，累积递增序列的差就可以了：\n```\n    public static int maximumProfit2(int[] stockPrices) {\n        int totalProfit = 0;\n        for(int i=1; i 0){\n                totalProfit += currentProfit;\n            }\n        }\n        return totalProfit;\n    }\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "编程"
        ]
    },
    {
        "name": "输出给定数字下一个比它大的数字",
        "desc": "比如数字：1234， 输出 1243\n\n比如 1243，则输出 1324",
        "answer": "用 1243 为例：\n1. 从右向左扫描，找到第一个不是升序的数字，比如 2\n2. 在 2 的右边，找到比它大的最小的数，是 3\n3. 交换 2和 3，得到 1342\n4. 把现在 3 右边的所有数字从大到小排序，得到 1324 （如果是排序则是 O(nlogn), 其实逆序就行了）",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "Path Sum",
        "desc": "给定一个二叉树和一个数字n，判断二叉树中是否有一个路径上的数字之和等于给定的数字n\n\n\nFor example:\nGiven the below binary tree and sum = 22,\n\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\nreturn true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.\n",
        "answer": "public class Solution {\n\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        int left = sum - root.val;\n        if(root.left == null &amp;&amp; root.right == null &amp;&amp; left == 0) {\n            return true;\n        }\n        return hasPathSum(root.left, left) || hasPathSum(root.right, left);\n    }\n}\n\n可以进一步问，输出所有和等于给定数字n的path",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "简单编程题"
        ]
    },
    {
        "name": "单链表每隔k个元素做一次反转",
        "desc": "给定一个链表，每隔k个元素做一次反转\n\nExample:\nInputs:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 3 \nOutput:  3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;8-&gt;7-&gt;NULL. \n\nInputs:   1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 5\nOutput:  5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;8-&gt;7-&gt;6-&gt;NULL. \n",
        "answer": "Node* rollback(Node *&amp;head, int k) {\n\tNode *pre = NULL;\n\tNode *next = NULL;\n\tNode *curr = head;\n\tint count = 0;\n\twhile (curr != NULL&amp;&amp;countnext;\n\t\tcurr-&gt;next = pre;\n\t\tpre = curr;\n\t\tcurr = next;\n\t\tcount++;\n\t}\n\tif (curr != NULL) {\n\t\thead-&gt;next = rollback(next, k);\n\t}\n \n\treturn pre;\n}\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "简单编程题",
            "单链表"
        ]
    },
    {
        "name": "用两个栈实现一个队列",
        "desc": "用两个堆栈模拟队列的功能，实现push，pop，count三个方法",
        "answer": "简单的做法：栈s1和s2，始终维护s1作为存储空间，以s2作为临时缓冲区，push直接进s1，pop时s1导入s2，栈顶出栈，导回s1\n优化做法：入队时，将元素压入s1，出队时，判断s2是否为空，如不为空，则直接弹出顶元素；如为空，则将s1的元素逐个“倒入”s2，把最后一个元素弹出并出队",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "赛马求最快N匹",
        "desc": "<p>条件：</p><p>1.64匹马</p><p>2.8个赛道</p><p>3.每次比赛只能知道比赛结果名次，不能知道具体时间</p><p>求：</p><p>用最少的比赛次数，找出最快的4匹</p>",
        "answer": "<p>1.每次比赛至少能淘汰4匹（树形淘汰算法），因此淘汰60匹，至少需要15次比赛，回答15，是最差答案</p><p>2.如果能回答出12次的（经过加速之后的简单排序），为次优解：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2）从第9次开始</p><p>\t\t*1.先取每组第一名，每次比赛，找出最快1匹，取出</p><p>\t\t*2.将最快这匹对应的组里次快的加入比赛，一共4次，找出最快4匹</p><p>3.如果能答出特定情况下10次，最差11次，为最优解（剪枝算法）：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2)  第9次，先取每组第一名，进行比赛，找出前四名</p><p>    3)  第10次，将前4名对应的组中的第2名加入比赛，一共8匹，比赛一次，如果对应的前四名没发生变化，说明前4名就是最快4名</p><p>\t4）第11次</p><p>\t\t*1.假设有一个组里的第2名，进入前四名：</p><p>\t\t\t①有一组的第1名被挤出前4名，该组所有的候选马无法进入前4名</p><p>\t\t\t②另外两组第2名之后无法进入前4名</p><p>\t\t\t因此，4（第2名在第10次进入前4名的组对应的前4名）+2（还在前4名的另外两个第1名）=6匹马进行比赛，决出前4名，即为最终答案</p><p>\t\t*2假设有两个组的第2名，进入前四名：</p><p>\t\t\t①则另外两组都无法进入前4名，而还在前4名的两组的前4名4+4=8，跑一次，最终能得到最快4名</p>",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "LRU cache",
        "desc": "实现一个LRU过期算法的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则按照LRU的规则剔除一个KV;\n4. 查询时如果已经过期, 则返回空;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;\n\n解法大致同上;\n为了实现LRU, 可在每次get后, 将该K从cache中删除并重新插入一遍;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "求数组的最大区间和",
        "desc": "# 输出一个 int 型数组的最大连续子数组（所有元素加和最大）各个元素之和\n# 保证数组中至少有一个正数\n\n例：\n\n输入：{1，2，5，-7，8，-10}\n\n输出：9  (子数组为: {1，2，5，-7，8})",
        "answer": "复杂度 `O(n)` 的算法\n\n```\nint _tmain(int A[], _TCHAR* argv[])\n{\n    int array_length = sizeof(A) / sizeof(A[0]);\n    int sum = 0;\n    int thisSum = 0;\n    for (int i = 0; i < array_length; i++)\n    {\n        thisSum += A[i];\n        if (thisSum &gt; sum)\n        {\n            sum = thisSum;\n        }\n        else if (thisSum < 0)\n        {\n            thisSum = 0;\n        }\n    }\n    printf(&#34;%d&#34;,sum);\n    return 0;\n}\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "最长无重复子串",
        "desc": "<p>无重复子串指：子串中每个字符都不相同 例如：s = 'aaabcdddd' 最长的无重复子串为'abcd'长度为4</p>",
        "answer": "<p>用两个指针left、right指向子串的起止位置 通过set记录是否有重复元素，只要没有重复都可以移动right，更新最长子串长度 如果有重复，移动left，并从set里移除对应的字符</p><pre><code>def max_sub_len(s): \n    existed = set() \n    res = 0 \n    left, right = 0, 0 \n    while right < len(s): \n        if s[right] not in existed: \n            existed.add(s[right]) \n            res = max(res, len(existed)) \n            right += 1\n        else: \n            t.remove(s[left]) \n            left += 1\n    return res </code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "服务循环依赖检测",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很长，如果出现循环依赖将出现非常恶劣的影响。</p><p>对于一个具体应用，已知各个服务的调用关系（即依赖关系），请判断是否存在循环调用。</p><p>输入：</p><p>一组服务依赖关系list，('A', 'B') 表示 A 会调用 B 服务</p><p>service_relations = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('D', 'A')]</p><p>输出：</p><p>由于存在 A - B - D - A 故存在循环依赖，返回True；反之如果不存在，返回False</p><p>Follow up：</p><p>1. 如果有多个环，请都检测出来</p><p>2. 返回每个环中的服务名</p>",
        "answer": "<p>可以采用拓扑排序 或者 DFS思路解决</p>",
        "types": [
            "数据结构与算法",
            "图"
        ],
        "tags": [
            "检测"
        ]
    },
    {
        "name": "比较版本号",
        "desc": "<p>比较两个版本号 version1 和 version2。</p><p>如果 version1 &gt; version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。</p><p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p><p> . 字符不代表小数点，而是用于分隔数字序列。</p><p>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p><p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p><p> </p><p>示例 1:</p><p>输入: version1 = &#34;0.1&#34;, version2 = &#34;1.1&#34;</p><p>输出: -1</p><p>示例 2:</p><p>输入: version1 = &#34;1.0.1&#34;, version2 = &#34;1&#34;</p><p>输出: 1</p><p>示例 3:</p><p>输入: version1 = &#34;7.5.2.4&#34;, version2 = &#34;7.5.3&#34;</p><p>输出: -1</p><p>示例 4：</p><p>输入：version1 = &#34;1.01&#34;, version2 = &#34;1.001&#34;</p><p>输出：0</p><p>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p><p>示例 5：</p><p>输入：version1 = &#34;1.0&#34;, version2 = &#34;1.0.0&#34;</p><p>输出：0</p><p>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>",
        "answer": "<h4><strong>方法1：分割+解析，两次遍历，线性空间</strong></h4><h4><strong>方法2：双指针，一次遍历，常数空间</strong></h4>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "单链表(奇数位升序，偶数位降序)的排序",
        "desc": "单链表，奇数位升序，偶数位降序，现在要求整体排成全局升序\n输入：1-&gt;200-&gt;10-&gt;120-&gt;30-&gt;8-&gt;88-&gt;4\n输出：1-&gt;4-&gt;8-&gt;10-&gt;30-&gt;88-&gt;120-&gt;200",
        "answer": "思路：链表可以随便拆、组合\n先把奇数和偶数拆开，形成两个链表，一个升序和一个降序\n1-&gt;10-&gt;30-&gt;88\n200-&gt;120-&gt;8-&gt;4\n然后将降序的反转，再合并成一个列表\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "蛇形打印二叉树",
        "desc": "输入一棵二叉树，比如：\n```\n              0\n        1            2\n      3     4      5     6\n          7            8   9\n```\n将它蛇形输出，结果如下：\n0，1，2，6，5，4，3，7，8，9",
        "answer": "1. 依赖栈记录每层节点值：层次便利，按偶数层（根是 0 层）从右到左，奇数层从左到右输出，时间空间复杂度都是 O(n)，n 是节点数\n2. 不依赖栈，递归：d 是层数，for i from 0 to d， 如果 i 是偶数，后序遍历二叉树的 0到i层，输出第i层的节点；如果i是奇数，先序遍历 0到 i 层，也只输出第i层节点。空间复杂度是 O(d) 即递归深度，时间复杂度是 o(d^2) 因为 0层节点会被访问 d 次，1 层节点 d-1 次，以此递推。",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "冒泡排序和快速排序的复杂度区别是什么，如何实现？",
        "desc": "```javascript\n/**\n * Quick Sort\n **/\nfunction quickSort(arr) {\n    // 补全代码\n}\nconsole.log(quickSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n\n/** \n * BubbleSort\n **/\n \nfunction bubbleSort(arr) {\n    // 补全代码\n}\nconsole.log(bubbleSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n```",
        "answer": "&gt;1. 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n&gt;1. 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```javascript\n/**\n * Quick Sort  O(NLogN)\n **/\nfunction quickSort(arr) {\n    const res = [];\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const leftArr = [];\n    const rightArr = [];\n    const q = arr[0];\n    for (let i = 1, l = arr.length; i < l; i++) {\n        if (arr[i] &gt; q) {\n            rightArr.push(arr[i]);\n        } else {\n            leftArr.push(arr[i]);\n        }\n    }\n    return res.concat(quickSort(leftArr), [q], quickSort(rightArr));\n}\n \n/** \n * BubbleSort O(N*N)\n **/\nfunction bubbleSort(arr) {\n    for (let i = 0, l = arr.length; i < l - 1; i++) {\n        for (let j = i + 1; j < l; j++) {\n            if (arr[i] &gt; arr[j]) {\n                let tem = arr[i];\n                arr[i] = arr[j];\n                arr[j] = tem;\n            }\n        }\n    }\n    return arr;\n}\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "岛屿数量",
        "desc": "<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1:</p><p>输入:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>输出: 1</p><p>示例 2:</p><p>输入:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>输出: 3</p><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><p><br></p>",
        "answer": "<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数</p><pre><code>class Solution {\nprivate:\n    void dfs(vector<vector<char&gt;&gt;&amp; grid, int r, int c) {\n        int nr = grid.size();\n        int nc = grid[0].size();\n\n        grid[r][c] = '0';\n        if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == '1') dfs(grid, r - 1, c);\n        if (r + 1 < nr &amp;&amp; grid[r+1][c] == '1') dfs(grid, r + 1, c);\n        if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == '1') dfs(grid, r, c - 1);\n        if (c + 1 < nc &amp;&amp; grid[r][c+1] == '1') dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector<vector<char&gt;&gt;&amp; grid) {\n        int nr = grid.size();\n        if (!nr) return 0;\n        int nc = grid[0].size();\n\n        int num_islands = 0;\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == '1') {\n                    ++num_islands;\n                    dfs(grid, r, c);\n                }\n            }\n        }\n\n        return num_islands;\n    }\n};\n</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把中文数字转成int数字",
        "desc": "<p>在中文页面解析、中文数据处理中，常常遇到用中文表示的数字，例如：五千三百万零五百零一。</p><p>我们一般需要把它转化成int型整数，进行实际存储和使用。 请完成一亿（不含）以内的中文数字到int整数的转换</p>",
        "answer": "<p><br></p><pre><code>// 递归解法\ndef cn2digital(number):\n  name2val = {u'一': 1, u'二': 2, u'三': 3, u'四': 4, u'五': 5,\n    u'六': 6, u'七': 7, u'八': 8, u'九': 9}\n  unit2count = {u'十': 10, u'百': 100, u'千': 1000, u'万': 10000}\n  for unit in [u'万', u'千', u'百', u'十']:\n    if unit in number:\n      n1, n2 = number.split(unit)\n      return cn2digital(n1) * unit2count.get(unit) + cn2digital(n2)\n  if not number:\n    return 0\n  for c in number:\n    if c == u'零':\n      continue\n    return name2val.get(c)\n\n// 非递归解法\ndef cn2digital(number):\n  name2val = {u'一': '1', u'二': '2', u'三': '3', u'四': '4', u'五': '5',\n        u'六': '6', u'七': '7', u'八': '8', u'九': '9'}\n  unit2count = {u'十': 1, u'百': 2, u'千': 3, u'万': 4}\n  res = []\n  base_count = 0 \n  for num in number[::-1]:\n    if num in name2val:\n      res.append(name2val.get(num))\n      continue\n    zero_count = 0\n    if num in unit2count:\n      zero_count = max(0, unit2count.get(num) + base_count - len(res))\n      if num == u'万':\n        base_count += 4\n    for _ in range(zero_count):\n      res.append('0') \n  return 0 if not res else int(''.join(res[::-1]))\n\nassert cn2digital(u'一万零一') == 10001\nassert cn2digital(u'三千五百万') == 35000000\nassert cn2digital(u'三千五百一十万') == 35100000\nassert cn2digital(u'三千五百零一万') == 35010000\nassert cn2digital(u'三千五百零一万零五百') == 35010500\nassert cn2digital(u'三千五百零一万五千五百五十五') == 35015555\nassert cn2digital(u'一百万') == 1000000\nassert cn2digital(u'二百三十四万三千四百九十三') == 2343493</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "Hash表设计",
        "desc": "常规的hash表设计及变通。问题由浅入深递进\n\n1. 基本的原理，负载因子，扩容的原理\n2. 假设内存受限4G，hash表已经占用3G内存，怎么使用剩下的那一个G的内存空间\n3. 怎么在文件中设计类似于hash表的结构，能够在文件中快速查找一个key/value对",
        "answer": "1. 扩容时注意关注 rehash 过程\n2. 类似于多个Hash组成一个List\n3. 类似于leveldb的思路",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "哈希表"
        ]
    },
    {
        "name": "1-n数字字典序第k大",
        "desc": "给你一个数字n(n < 1e9), \n再给你一个数字k(k < n), 要求你找到1, 2, 3, ... n按照字典序排序后, 第k大的数字;\n\n如, n = 15, k = 7;\n\n那1 ~ 15按照字典序排序为: 1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;\n\n则答案为15;",
        "answer": "利用字典树的思想;\n我们假设有这么一棵树, 每个节点都要10个儿子, 10条到儿子的边分别对应数据0~9;\n那么我们在这棵树上, 对边按照0~9的顺序进行DFS, 当走到第k个节点时, 该节点对应的数字既为我们的第k大字典序数字;",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "在数组中找出和值为给定值的两个数",
        "desc": "输入一维数组array和n，找出和值为0的任意两个元素。例如：\n``` python \narray = [2, 3, 1, 10, 4, 30]\nn = 31\n```\n则结果应该输出[1, 30] 顺序不重要\n\n如果有多个满足条件的，返回任意一对即可",
        "answer": "解法1： 本题容易想到用哈希表，迭代一次边建表边查找n - array[i]是否在hash_table中即可。\n\n该方法空间开销比较大\n\n解法2：先对数组做排序，然后首尾两个指针求和，如果小于n则左指针右移，如果大于n则右指针左移。\n\n该方法时间复杂度O(nlogn)\n\n推荐考察解法2，附带做了排序算法的考察",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "老虎吃羊问题",
        "desc": "在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。\n\n假设：\n\nA：每次只有一只老虎可以吃样，而且一旦他吃了羊，他自己就变成羊。\n\nB：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 \n\n问最后这只羊会不会被吃？如果是n只老虎和一只羊呢？",
        "answer": "思路：先simplify。\n- 1只老虎，肯定吃。 \n- 2只老虎肯定不吃，否则就被另一只吃了。 \n- 3只老虎，如果一只老虎吃掉了羊，问题就转换为2只老虎和1只羊的情况，显然另外两种老虎不敢轻举妄动。所以羊会被吃。 \n- 4只老虎，如果某一只老虎吃了羊，问题转化为3只老虎和1只羊的问题，它肯定会被接下来的某一只吃掉，然后其他两只只能等着。所以4只老虎，大家都不敢吃羊。\n\n这样归纳，我们就可以发现如果老虎数目是奇数，那么羊肯定被吃，如果是偶数，那么羊肯定不会被吃。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "爬虫url去重-多线程并发",
        "desc": "用爬虫抓取网页时, 一个较为重要的问题, 就是对爬去的网页去重;\n请你详细的设计一种数据结构, 用来检验某个URL之前是否已经被爬取过;\n并给出每次检验的复杂度, 以及整体的空间复杂度;\n\n一般爬虫在实现时, 都会利用多线程并发的爬取;\n现在需要你升级一下之前的实现, 以保证并发安全;",
        "answer": "通常来说, 不需要改变数据结构本身, 只需要在其外围包裹一些简单的操作, 就能大大提高其并发度;\n比如可以根据URL的后几位, 进行hash分桶;\n注意这里选取URL的后几位, 而不是前几位, 是为了让hash更加均匀, 因为同个域名下的前缀大多是相同的;\n然后每个桶内维护一个上述实现的去重的数据结构;",
        "types": [
            "数据结构与算法",
            "队列"
        ],
        "tags": [
            "多线程",
            "哈希",
            "Hash策略",
            "爬虫"
        ]
    },
    {
        "name": "蓄水问题, 1维",
        "desc": "给定一个一维数组用于描述一个海拔，相邻的海拔高度不同，则下雨后低洼海拔的洼地会有积水，假设雨水足够，能够填满所有低洼地段，计算下雨后所有低洼地段总蓄水量。\n\n例如给定数组为：\n\n5, 2, 1, 4, 3\n\n则：所有低洼地段蓄水为量为 5",
        "answer": "定义左极高点: 该点左边最高的那个点;\n\n定义右极高点: 该点右边最高的那个点;\n\n于是每个点的蓄水高度为: min(左极高点高度, 右极高点高度) - 该点高度，累加每个点的高度即可;所有点的左右极点可以分别通过一次向右和向左的扫描得到;\n\n算法复杂度为 O(n)",
        "types": [
            "数据结构与算法",
            "贪心",
            "队列",
            "堆栈",
            "数组"
        ],
        "tags": [
            "基础"
        ]
    },
    {
        "name": "轮流抛硬币问题",
        "desc": "# A和B玩抛硬币游戏，AB轮流抛一枚硬币，谁先抛到正面谁就获胜并结束游戏，硬币两面均匀。A先抛，请问A获胜的概率是多少？",
        "answer": "将A和B的获胜情况罗列，可以看到规律。A第一次抛获胜概率是1/2, A不获胜情况下B第一次获胜概率1/2*1/2=1/4。\n所以A获胜概率是：1/2+1/8+1/32+...=2/3。B获胜的概率是：1/4+1/16+...=1/3",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "查找第一个缺失的正整数",
        "desc": "查找第一个缺失的正整数。\n时间复杂度O(n) ，空间复杂度 O(1)\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\n",
        "answer": "1 排序之后查找\n\n2 把出现的数值放到与下标一致的位置，再判断什么位置最先出现不连续的数值，就是答案了。\n\n3 和2差不多，把出现过的数值的下标位置做好标识，如果没有出现过的数组的下标就没有标识，那么这个就是答案",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "简单编程题",
            "查找",
            "排序"
        ]
    },
    {
        "name": "微信跳一跳",
        "desc": "<p>从起点开始接下来有 100 个方块，相邻方块间的距离都为 1，每个方块上有增加体力的食用蘑菇或减少体力的毒蘑菇，蘑菇带来的体力改变是已知的。一个人初始体力为 m，每次可以往前跳任意个方块，体力耗尽就会死掉。</p><ol><li>每跳一次消耗的体力与跳的距离成正比，比例为 1。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方，每跳一个方块加 1 分。问这个人能否跳到终点，如果能，求可能得到的最高分数。</li></ol>",
        "answer": "<ul><li>第 1 问，贪心算法，时间复杂度 O(n)</li></ul><pre><code>def flip1(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第一问\n    :param m: 初始体力\n    :param array: 蘑菇带来的体力改变\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    for n in array:\n        m -= 1  # 消耗的体力与跳的距离成正比\n        if m <= 0:  # 体力不足死掉\n            return -1\n        if n &gt; 0:  # 只跳加体力的格子\n            m += n\n    if array[-1] < 0:  # 终点的蘑菇必须吃\n        m += array[-1]\n    return m if m &gt; 0 else -1</code></pre><ul><li>第 2 问，动态规划，时间复杂度 O(n^2)</li></ul><pre><code>def flip2(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第二问\n    :param m:\n    :param array:\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    # powers 表示在每个格子可能剩余的最大体力\n    powers = [m] + [0] * len(array)\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            if powers[j] &gt; (i - j) ** 2:\n                powers[i] = max(powers[i], powers[j] - (i - j) ** 2 + array[i - 1])\n    return powers[-1] if powers[-1] &gt; 0 else -1</code></pre><ul><li>第 3 问，动态规划，时间复杂度 O(n^3)</li></ul><pre><code>def flip3(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第三问\n    :param m:\n    :param array:\n    :return: 可能跳的最多格子数\n    &#34;&#34;&#34;\n    # scores 表示在每个格子得到不同分数时可能剩余的最大体力\n    scores = [{0: m}] + [{} for _ in range(len(array))]\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            for score, power in scores[j].items():\n                left = power - (i - j) ** 2\n                if left &gt; 0 and left + array[i - 1] &gt; 0:\n                    scores[i][score + 1] = max(scores[i].get(score + 1, 0), left + array[i - 1])\n    return max(scores[-1].keys()) if scores[-1].keys() else 0</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "二路归并",
        "desc": "<p>实现一个merge函数，功能是将两个有序数组，将它们合并成一个有序数组，如：</p><pre><code>let arr1 = [1, 2]\nlet arr2 = [-1, 2, 8, 9]\n\nmerge(arr1,arr2) // 返回 [-1, 1, 2, 2, 8, 9]</code></pre><p><br></p>",
        "answer": "<p><br></p><pre><code>function merge(arr1, arr2) {\n  // 可以判断一下arr1、arr2是否是数组\n  if(!(Array.isArray(arr1) &amp;&amp; Array.isArray(arr2))) throw '...'\n\n  let i = 0, j=0, t=0\n  let temp = [];\n  while (i < arr1.length &amp;&amp; j < arr2.length) {\n    temp[t++] = arr1[i] <= arr2[j] ? arr1[i++] : arr2[j++];\n  }\n\n  while (i < arr1.length) {  // 数组1有剩余\n    temp[t++] = arr1[i++];\n  }\n  while (j < arr2.length) {  // 数组2有剩余\n    temp[t++] = arr2[j++];\n  }\n  return temp\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据结构",
            "归并",
            "前端编码",
            "排序"
        ]
    },
    {
        "name": "拆分字符串",
        "desc": "输入一个列表的单词，及一个长字符串，判断字符串可否由列表中的单词组成。比如：\n输入：\n单词列表 dict：I, love, byte, bytedance\n字符串 s：Ilovebytedance\n输出：\nTrue",
        "answer": "1. 用一个数组 validWords[] 记录字符串当前位置之前的字符串是否可以用 dict 组成，validWords[i]=True 可以，否则不可以。默认不可以\n2. for 循环 i 从 0 到 s.length：\n    a. 如果 s[0-i] 在 dict 中，设置 validWords[i]=True\n\t\tb. 如果validWords[i]=True，for 循环 j 从 i+1 到 s.length-1，判断 s[i+1 到 j] 是否在 dict 中，如果是，设置 validWords[j]=True\n3. 如果 validWords[s.length-1] = True, return True\n",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": [
            "校招类",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "给定单链表，求离终点距离为 k 的节点",
        "desc": "给定单链表，求离终点距离为 k 的节点，要求只扫一次且空间复杂度为O(1)",
        "answer": "两个指针, 第一个先向后走k步;\n\n然后两个一起走;\n\n当第一个指针到达链表尾部时另一个指针指向的就是距离终点距离为 k 的节点。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "数组0值筛选",
        "desc": "给定一个非负数组，要求你对它进行操作, \n使得所有的0 放在数组左边， \n大于 0 的值位于数组右边,  \n\n要求空间为O(1), 时间为O(n);",
        "answer": "从右往左扫描，同时维护另一个指针指向出现在最右侧的 0，每次扫描到非 0 数字则和它交换",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针",
            "基础算法"
        ]
    },
    {
        "name": "区间合并",
        "desc": "给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。\n\n例如：[9, 10], [1,4], [3,6], [8, 12]\n\n那么合并后的区间段为：[1, 6], [8, 12]",
        "answer": "由于输入的区间段，不一定按照起点排好序，所以先按照起点坐下排序利于后续合并。\n\n``` python\n    def merge(intervals):\n        res = []\n        intervals = sorted(intervals, key=lambda x:x.start)\n        pre = None\n        for interval in intervals:\n            if not pre:\n                pre = interval\n                continue\n            if interval.start <= pre.end:\n                if interval.end &gt;= pre.end:\n                    pre.end = interval.end\n            else:\n                res.append(pre)\n                pre = interval\n        if pre:\n            res.append(pre)\n        return res\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "爬楼梯问题",
        "desc": "<ul><li>爬楼梯问题：爬楼梯时，每一步会有两个选择：爬一个台阶和爬两个台阶，问：楼梯总台阶数为n，则一共有多少种爬法，写一个函数f，使得：总的爬法= f(n)。举例：n=3时，则共有：（1,1,1)、(1,2) 、(2,1)三种爬法，则f(3)=3。</li></ul><p><br></p>",
        "answer": "<p>斐波拉契：f(n)=f(n-1)+f(n-2) </p><p>代码需要判断边界</p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "数学基础",
            "递归"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找零钱问题",
        "desc": "有1，2，5，10等不同零钱，问给N元，有多少种不同的组合方式？",
        "answer": "假设有m种零钱，具体面值存在arr中，要找的钱为n。\n\n使用m种零钱去找零n元，可以拆分为：\n\n完全不用第m种零钱 和 至少用一次第m种零钱\n\n``` python\ndef zhaolin(arr, n, m):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if m <= 0:\n        return 0\n    return zhaolin(arr, n, m - 1) \\ # 不用第m-1号零钱\n\t\t\t+ zhaolin(arr, n - arr[m - 1], m) # 至少使用1次m-1号零钱\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把二叉树压成单链表",
        "desc": "对于输入的二叉树，舍弃left指针，用right指针按照先根顺序串成单链表。例如：\n``` \n      1\n    2   5\n  3  4\n``` \n转为单链表为1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n要求in-place",
        "answer": "本题利用dfs递归比较好解，关键点是要把左子树的最后一个节点和右子树头接上。\n\n关键代码：\n``` python\ndef flatten(root):\n\tif not root:\n\t\treturn\n\tif root.left:\n\t\tflatten(root.left)\n\tif root.right:\n\t\tflatten(root.right)\n\ttmp = root.right\n\troot.right = root.left\n\troot.left = None\n\twhile root.right:\n\t\troot = root-&gt;right\n\troot.right = tmp\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "最短子数组之和",
        "desc": "给定1个正整数数组array和1个正整数n，从array中寻找和值**大于等于n**的最短子数组。\n\n如果存在，则返回最短子数组长度；如果不存在返回0。\n\n例如：array = [1, 3, 4, 3, 9, 1], n = 12,\n\n那么子数组[3, 9]满足条件且长度最短为2。\n\n",
        "answer": "本题用两个指针的思路解决，时间复杂度O(n)\n\n指针left和right记录子数组的左右边界位置，\n\n让right向右移，直到子数组和&gt;=n或到达数组末尾，更新最短距离，\n\n将left像右移一位，然后在和值中减去移去的值，\n\n重复上面的步骤，直到right到达末尾，且left也无法再右移\n\n``` python\ndef min_sub_len(arrary, n):\n\tres = sys.maxsize\n\tleft, cur_sum = 0, 0\n\tfor i in range(0, len(array)):\n\t\tcur_sum += array[i]\n\t\twhile left <= i &amp;&amp; cur_sum &gt;= n:\n\t\t\tres = min(res, i - left + 1)\n\t\t\tcur_sum -= array[left]\n\t\t\tleft += 1\n\treturn 0 if res == sys.maxsize else res\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针"
        ]
    },
    {
        "name": "二叉树最大宽度",
        "desc": "<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度（每一层的节点可能为空）。</p>",
        "answer": "<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>思路：主要想法是给每个节点一个 position 值，如果我们走向左子树，那么 position -&gt; position * 2，如果我们走向右子树，那么 position -&gt; positon * 2 + 1。当我们在看同一层深度的位置值 L 和 R 的时候，宽度就是 R - L + 1。</p><p><strong>方法 1：深度优先搜索</strong></p><h4><strong>方法 2：宽度优先搜索</strong></h4>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树"
        ]
    },
    {
        "name": "二叉树中序遍历打印节点信息",
        "desc": "实现一个二叉树中序遍历函数，打印所有节点信息。  \ntypedef string DataType;  \ntypedef struct BinTreeNode {  \n    DataType data;  \n    struct BinTreeNode* leftChild;  \n    struct BinTreeNode* rightChild;  \n} BinTreeNode;  \ntypedef BinTreeNode* BinaryTree;  \n  \nvoid MidOrderPrint(BinaryTree tree) {  \n    //打印二叉树节点信息  \n}  \n",
        "answer": "二叉树的遍历按照根节点位置的不同，分为前序遍历、中序遍历、后序遍历。\n前序遍历：根节点-&gt;左子树-&gt;右子树  \n中序遍历：左子树-&gt;根节点-&gt;右子树  \n后序遍历：左子树-&gt;右子树-&gt;根节点  \n例如二叉树结构如下  \n........... a  \n........../.....\\  \n........b........c  \n....../....\\  \n....d........e  \n.....\\ ...../  \n......f....g  \n  \n前序遍历：abdfegc  \n中序遍历：dfbgeac  \n后序遍历：fdgebca  \n  \n  \n解法一：递归方式  \nvoid MidOrderPrint(BinaryTree tree) {  \n    if(NULL == tree) {  \n        return;  \n\t\t}  \n\t\tMidOrderPrint(tree-&gt;leftChild);  \n\t\tprintf(&#34;%s &#34;, tree-&gt;data.c_str());  \n\t\tMidOrderPrint(tree-&gt;rightChild);  \n}  \n|  \n|    \n解法二：非递归方式  \n//假设 Stack 为已经实现的堆栈类型，支持push和pop方法  \nclass Stack {  \n    void push(BinTreeNode *);  \n    BinTreeNode *pop();  \n    BinTreeNode *top();  \n};  \n  \nvoid MidOrderPrint(BinaryTree tree){  \n    if(NULL == tree) {  \n        printf(&#34;this tree is empty!\\n&#34;);  \n        return;  \n    }  \n    Stack s;  \n    BinTreeNode *curNode = tree;  \n    while(curNode != NULL || s.top() != NULL) {  \n        while(curNode != NULL) {  \n            s.push(curNode);  \n            curNode = curNode-&gt;leftChild;  \n        }  \n        curNode = s.pop();  \n        printf(&#34;%s &#34;,curNode-&gt;data);  \n        curNode = curNode -&gt;rightChild;  \n    }  \n}  \n_",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "iOS算法考查"
        ]
    },
    {
        "name": "从日志文件中抽取指定分钟的行",
        "desc": "某个很大（假设有几十T）的日志文件，每行的前两列为日期和时间（时间相等或递增），之后为日志内容，日志内容长度不一。例如：\n\n2015-01-01 00:00:01 this is the first line\n2015-01-01 00:00:03 this is another line\n...\n...\n2017-12-31 12:34:45 this is the last line\n\n需要将这个日志文件的某一分钟（例如2017-10-01 10:02这一分钟）的日志保存到另一个文件中。",
        "answer": "使用二分法寻找位置，seek到文件的该位置读取下一行的内容来判断需要寻找的行。\n本题考察二分查找和对文件操作的了解。需要考虑seek到一行中间的情况。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "二分"
        ]
    },
    {
        "name": "概率问题：赌徒获胜胜率计算",
        "desc": "有两个技巧相当的赌徒 A 和 B（即两人赌博胜率各为0.5），现在设定这样的获胜规则：\n1. A只要赢了2局或以上就获胜\n2. B要赢3局或以上才能获胜。\n问双方胜率各为多少？",
        "answer": "如果直接列举所有情况也是可以得出答案的，但有简单方法可以剪枝。\n\n我们用a表示A取胜，用b表示B取胜。\n\n只要意识到，**无论结果如何，最多4局就可分出胜负**，这样就好计算了。\n\n可以列举所有可能的情形如下： \n\naaaa aaab abba bbab \\\nbaaa baba abab babb \\\nabaa bbaa aabb abbb \\\naaba baab bbba bbbb\n\n也可以计算B获胜的情况 1(bbbb)+ 4(abbb babb bbab bbba)\n\n所以A获胜概率是\\dfrac{11}{16}，B获胜概率是\\dfrac{5}{16}\n",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "旋转链表",
        "desc": "给定单链表，要求返回向右移k位后的新链表，例如：\n\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; NULL\n\nk = 3，则返回：4 -&gt; 5 -&gt; 6 -&gt; 1 -&gt; 2 -&gt;3 -&gt; null",
        "answer": "用一快一慢两个指针fast，slow，快指针提前走k步\n\n然后快慢一起走，直到fast.next == NULL\n\n这是slow-&gt;next即为新head，将fast.next指向head，并从slow处断开\n\n本题要注意参数处理：\n\n空链表\n\nk大于链表长度",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "链表求和",
        "desc": "给定一个链表`L1`、`L2`,每个元素是为10以内的正整数，链表表示一个数字，表头为高位。\n求两个链表之和，以链表形式返回\n如：\n```\nL1\n5 -&gt; 6 -&gt; 2 -&gt; 3 -&gt; 7\nL2\n1 -&gt; 7 -&gt; 0 -&gt; 9 -&gt; 2\n和为：\n56237+17092=73329\n```\n拓展1：\n表头改为低位\n拓展2：\n两表内数字不重复，优化\n拓展3：\n",
        "answer": "```java\n/**\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;      \n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param l1: the first list\n     * @param l2: the second list\n     * @return: the sum list of l1 and l2 \n     */\n    public ListNode addLists(ListNode l1, ListNode l2) {\n        if(l1 == null &amp;&amp; l2 == null) return null;\n        ListNode head = new ListNode(0);\n        ListNode tail = head;\n        int carry = 0;\n        while(l1 != null &amp;&amp; l2 != null){\n            int value = carry + l1.val + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        while(l1 != null){\n            int value = carry + l1.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n        }\n        while(l2 != null){\n            int value = carry + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l2 = l2.next;\n        }\n        if(carry &gt; 0){\n            ListNode node = new ListNode(carry);\n            tail.next = node;\n            tail = tail.next;\n        }\n        return head.next;\n    }\n}\n```\n拓展1 翻转\n拓展2 set/bitmap\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "多叉树最大高度",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>求多叉树的最大高度 getDepth(node)</li></ol>",
        "answer": "<p>节点信息</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>getDepth实现</p><pre><code>function getDepth(node){\n if (!node) return 0\n if (node.children &amp;&amp; node.children.length){\n  let depth=0;\n  for(let e of node.children){\n    depth=Math.max(getDepth(e),depth)\n  }\n  return depth+1\n }else{\n   return 1\n } \n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "前端编码"
        ]
    },
    {
        "name": "单链表对折",
        "desc": "对输入的链表做对折操作\n\n例如：有n个节点的单链表：1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n-2 -&gt; n-1 -&gt; n -&gt; NULL\n\n处理后的链表为1 -&gt; n &gt; 2 -&gt; n-1 -&gt; 3 -&gt; n-2 ...\n\n要求在原链表基础上操作。",
        "answer": "解题思路\n1. 先找到中点，将原链表1分为2，即为l_1, l_2；\n2. 然后翻转l_2;\n3. 最后对l_1和l_2归并。\n\n本题主要考查候选人的编程功底以及好的编程习惯。\n\n比较好的答案应该是4个函数：\n* def fold(head): # 对折入口函数\n* def find_middle(head): # 找中点函数，用一快一慢两指针\n* def reverse(head): # 链表翻转\n* def merger(l1, l2): # 链表合并",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "螺旋打印二维数组",
        "desc": "输入m * n的二维矩阵，要求从(0,0)开始螺旋向内完成打印输出。\n具体打印方法：\n1. ➡️先从左向右打印第一行；\n2. ⤵️再从上向下打印最后一列；\n3. ⬅️然后从右向左打印最后一行；\n4. ⤴️最后从下向上打印第一列。\n\n如此往复，完成所有元素打印。\n\n例如：\n``` python\ninput = [ [ 1,  2,  3,  4,  5],\n          [14, 15, 16, 17,  6],\n          [13, 20, 19, 18,  7],\n          [12, 11, 10,  9,  8],\n        ]\noutput = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n```\n附件要求：不允许再开辟O(mn)的存储，直接打印输出。",
        "answer": "``` python\ndef print_martix(matrix):\n    '''\n    : type martix: list[list]\n    '''\n    if not matrix:\n        return\n    start_row, start_col, end_row, end_col = 0, 0, len(matrix) - 1, len(matrix[0]) - 1\n    while start_row <= end_row and start_col <= end_col:\n        for k in xrange(start_col, end_col + 1):\n            print matrix[start_row][k]\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            print matrix[k][end_col]\n        end_col -= 1\n        if start_row &gt; end_row or start_col &gt; end_col:\n        break\n        for k in xrange(end_col, start_col - 1, -1):\n            print matrix[end_row][k]\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            print matrix[k][start_col]\n        start_col += 1\n```\n测试用例\n``` python\ninput0 = [[]]\ninput1 = [[1]]\ninput2 = [[1, 2]]\ninput3 = [[1], [2]]\n```",
        "types": [
            "数据结构与算法",
            "递归",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "字符串相似度-编辑距离",
        "desc": "百科定义：编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\nsitten （k→s）\n\nsittin （e→i）\n\nsitting （→g）\n",
        "answer": "本题用DP思路来解决，递推关系：\n\n若str1[i] == str2[j]，temp=0，否则temp=1\n\nd[i][j] = min([i-1][j] + 1, d[i][j-1] + 1, d[i - 1, j - 1] + temp)",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "找旋转数组的中位数",
        "desc": "有一个有序数组如：1，2，3，4，5，6，7\n随机选一个点比如5反转变成：5，6，7，1，2，3，4\n对于上面翻转后的数组，求它的中位数。",
        "answer": "1. 最简单的，排序，复杂度最高；\n2. 遍历整个数组，找到最小的数字比如 1，然后 (index+n/2)%n\n3. 二分，找到最小的数字就能找到中位数。淘汰哪一半？\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础算法",
            "查找"
        ]
    },
    {
        "name": "求二叉树的最长路径",
        "desc": "给定一棵二叉树，求其中的最长路径，所谓路径是指：连通两个节点的最小边数。",
        "answer": "使用后序遍历O(n)。遍历过程中计算以当前节点为根的最长路径，返回当前节点的高度。",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "精简文件路径",
        "desc": "对输入的unix风格的文件路径做精简。\n例如：/a/b/.././ 精简为 /a",
        "answer": "为了处理..，容易想到stack解决\n\n``` python \ndef simplify_path(ppath):\n\tsegs = path.split('/')\n\tstack = []\n\tfor seg in segs:\n\t\tif not seg or seg == '.':\n\t\t\tcontinue\n\t\telif seg == '..':\n\t\t\tif len(stack):\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.append(seg)\n\treturn '/' + '/'.join(stack)\n```\n特殊case：/../; ////foo/",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "stack"
        ]
    },
    {
        "name": "绝对众数",
        "desc": "<p>https://leetcode-cn.com/problems/majority-element/</p><p>定义：给定N个数，称出现次数最多的数为众数，若某数出现的次数大于N/2称为绝对众数。如</p><p>A={1, 2, 1, 3, 2}中，1和2都是众数，但都不是绝对众数</p><p>如A={1,2,1,3,1}中，1是绝对众数。</p>",
        "answer": "<p><strong>解题思路</strong>：任意删除2个不相同的数，不改变绝对众数</p><pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int m = nums[0]; // 绝对众数\n        int count = 0; // 计数\n        for(int i = 0; i< nums.length; i++) {\n            if(count == 0) {\n                m = nums[i];\n                count++;\n            }else if(m == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return m;\n    }\n}</code></pre><p><br/></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "环节点的走法数",
        "desc": "一个环上有10个点，编号为0-9，\n\n从0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，\n\n求：经过n步又回到0点有多少种不同的走法？\n\n举例：\n\n如果n = 1，则从0出发只能到1或者9，不可能回到0，共0种走法\n\n如果n = 2，则从0出发有4条路径：0-&gt;1-&gt;2, 0-&gt;1-&gt;0, 0-&gt;9-&gt;8, 0-&gt;9-&gt;0，其中有两条回到了0点，故一共有2中走法",
        "answer": "DP问题，令F(k, i)表示从0点出发经过k步到达i点的走法数，题目所求为F(n, 0)\n\nF(k, i) = F(k - 1,  (i + 1) % 10) + F(k - 1, ((i - 1) + 10) % 10)\n\n初始状态：f[1, 0] = 0, f[1, 1] = 1, f[1, 2] = 0, ... f[1, 9] = 1",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "单词搜索",
        "desc": "<p>给定1个二维字符数组cmap和单词1个word，搜索word是否在map中。</p><p>搜索的定义是从cmap的任意位置开始，可以上下左右移动，依次和word每个字符匹配，如果word能匹配完，则存在，否则不存在。 </p><p>注：cmap中的每个位置只能被访问1次</p><pre><code>a c d z\nx t r o\nf i w o</code></pre><p><br></p><p>例如上面的cmap，则'zoo'能搜索到，'wto'不能搜索到</p>",
        "answer": "<p>比较容易想到用DFS解决，如果候选没思路，可以提示属于哪类问题，如果想到图就好办了。</p><pre><code>def search(cmap, word):\n    if not cmap or not word:\n        return False\n    visited = [[False] * len(cmap[0]) for _ in range(len(cmap))]\n    for i in range(len(cmap)):\n        for j in range(len(cmap[0])):\n            if dfs(cmap, word, 0, i, j, visited):\n                return True\n\ndef dfs(cmap, word, pos, i, j, visited):\n    if pos == len(word):\n        return True\n    if i < 0 or i &gt;= len(cmap) or j < 0 or j &gt; len(cmap[0]) or visited[i][j] or cmap[i][j] != word[pos]:\n        return False\n    find = False\n    visited[i][j] = True\n    for (ii, jj) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if dfs(cmap, word, pos + 1, i + ii, j + jj, visited):\n            find = True\n            break\n    visited[i][j] = False  # 易错点\n    return find</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "寻找数组任一峰值",
        "desc": "峰值定义：比前后元素都大；数组可能存在多个峰值，返回任一个就行\n\n例如：1 2 3 2 1 4 3 可以返回3或者4\n\n可以默认前提：\n\n1 任意元素不等于相邻元素\n\n2 首、尾元素只要比右、左一个元素大即可认为是峰值",
        "answer": "O(n)肯定能解决问题，但本题结合二分能优化时间复杂度\n\n如果a[mid] < a[mid + 1]说明峰值后半段，否则在前半段\n\n核心代码\n``` python\ndef find_peak(a):\n\tleft, right = 0, len(a) - 1\n\twhile left < right:\n\t\tmid = left + (right - left) / 2\n\t\tif a[mid] < a[mid + 1]:\n\t\t\tleft = mid + 1\n\t\telse;\n\t\t\tright = mid\n\t\treturn right",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "对称树判断",
        "desc": "判断一棵二叉树，是否是（左右）对称树：\n对称例子：\n```\nFor example, this binary tree is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n不对称例子：\n```\n   1\n   / \\\n  2   2\n   \\   \\\n   3    3\n``` ",
        "answer": "```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return solve (root.left, root.right);\n    }\n    \n    public boolean solve(TreeNode t1, TreeNode t2) {\n        if (t1 == null &amp;&amp; t2 == null) return true;\n        if (t1 == null &amp;&amp; t2 != null || t1 != null &amp;&amp; t2 == null || t1.val != t2.val) return false;\n        return solve(t1.left, t2.right) &amp;&amp; solve(t1.right, t2.left);\n    }\n}\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "给定链表，将其中的某一部分翻转",
        "desc": "给定链表，将其中的某一部分翻转, 要求空间复杂度为O(1);",
        "answer": "指针a与d指向要翻转部分的第一个节点，指针b指向a的上一个节点；\n\n指针c指向a，并将a指向下一个节点，再将c插入到b的后面，重复执行该操作直到a走出要翻转的区间；\n\n最后将a接在d后面，完成翻转。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "带TTL的N-kv cache",
        "desc": "&#34;实现一个带过期的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则将最老的那一对KV给剔除;\n4. 查询时如果已经过期, 则返回空;\n5. 所有操作复杂度都为O(1)&#34;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "cache"
        ]
    },
    {
        "name": "二叉树的镜像",
        "desc": "实现一个函数，完成输入一个二叉树，输出该二叉树的镜像。\n二叉树结点的定义如下：\n```\nstruct BinaryTreeNode  \n{  \n    int data;  \n    BinaryTreeNode *Left;  \n    BinaryTreeNode *Right;  \n};\n```",
        "answer": "思路：先序遍历树的每个结点，若遍历到的结点有子结点，则交换它的两个子结点。\n有两种实现方法：\n1.递归实现:\n```\nvoid MirroRecursively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n    if(NULL == pNode-&gt;Left &amp;&amp; NULL == pNode-&gt;Right)  \n        return;  \n      \n    BinaryTreeNode *pTemp = pNode-&gt;Left;  \n    pNode-&gt;Left = pNode-&gt;Right;  \n    pNode-&gt;Right = pTemp;  \n      \n    if(pNode-&gt;Left)  \n        MirroRecursively(pNode-&gt;Left);  \n    if(pNode-&gt;Right)  \n        MirroRecursively(pNode-&gt;Right);  \n}  \n```\n2.非递归实现，即使用循环实现:\n```\nvoid MirrorNonRecurively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n  \n    stack stackTreeNode;  \n    stackTreeNode.push(pNode);  \n  \n    while(stackTreeNode.size())  \n    {  \n        BinaryTreeNode *pNode = stackTreeNode.top();  \n        stackTreeNode.pop();  \n  \n        if(NULL != pNode-&gt;Left || NULL != pNode-&gt;Right)  \n        {  \n            BinaryTreeNode *pTemp = pNode-&gt;Left;  \n            pNode-&gt;Left = pNode-&gt;Right;  \n            pNode-&gt;Right = pTemp;  \n        }  \n          \n        if(NULL != pNode-&gt;Left)  \n            stackTreeNode.push(pNode-&gt;Left);  \n  \n        if(NULL != pNode-&gt;Right)  \n            stackTreeNode.push(pNode-&gt;Right);  \n    }  \n} \n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出二叉树左视角能看到的节点",
        "desc": "给定一颗二叉树：\n\n```\n                1\n            2       3\n         4   5    6   7\n                        8\n```\n\n从左边看，输出能看到的 1，2，4，8 这四个节点，顺序无所谓。",
        "answer": "递归或者非递归都可以",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": [
            "校招类",
            "基础算法"
        ]
    },
    {
        "name": "日志提取",
        "desc": "你有一份非常大的日志文件;\n日志的格式为: timestamp: content;\n如 2017-01-01 20:00:00: hello hello hello;\n需要你提取日志中指定时间内的内容;\n如提取2017-01-01 20:00:00 ~ 2017-01-01 22:30:00的日志数据",
        "answer": "由于时间是递增的, 可以先二分到指定时间, 然后再进行读取;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "最多有两个不同字符的最长子串",
        "desc": "给定字符串s，返回最多包含两个不同字符的最长子串长度。\n\n例如：s = 'abbcceefffffg'\n\n最长子串为'eefffff'长度为5",
        "answer": "本题采用两个指针left、right指针指向子串的起始和结束位置。\n\nright不断前行，对left和right内的字符存入dict并计数，当dict的keys()超过2个时，向右移动left。\n\n如此往复，不断更新最长子串长度。\n\n``` python\ndef max_sub_len(s):\n\tmax_len, left = 0, 0\n\tcount = collections.Counter()\n\tfor right in xrange(len(s)):\n\t\tcount[s[right]] += 1\n\t\twhile len(count) &gt; 2:\n\t\t\tcount[s[left]] -= 1\n\t\t\tif count[s[left]] == 0:\n\t\t\t\tcount.pop(s[left])\n\t\t\tleft += 1\n\t\tmax_len = max(max_len, right - left + 1)\n\treturn max_len",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "滑动窗口",
            "字符串"
        ]
    },
    {
        "name": "生成n阶螺旋数组",
        "desc": "本题是http://marvel.byted.org/#/question/detail/?id=816&amp;nocontri=true的反向问题。\n\n``` python\ninput = 1\noutput = [[1]]\n\ninput = 2\noutput = [[1, 2],\n          [4, 3]]\n\t\t\t\t\t\ninput = 3 \noutput = [[ 1, 2, 3],\n          [ 8, 9, 4],\n          [ 7, 6, 5]]\n```",
        "answer": "``` python\ndef gen_matrix(n):\n    if n <= 0:\n        return None\n    matrix = [[0] * n for _ in xrange(n)]\n    val = 1\n    start_row, start_col, end_row, end_col = 0, 0, n - 1, n - 1\n    while val <= n * n:\n        for k in xrange(start_col, end_col + 1):\n            matrix[start_row][k] = val\n            val += 1\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            matrix[k][end_col] = val\n            val += 1\n        end_col -= 1\n        for k in xrange(end_col, start_col - 1, -1):\n            matrix[end_row][k] = val\n            val += 1\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            matrix[k][start_col] = val\n            val += 1\n        start_col += 1\n    return matrix\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "给定长度为n的整形数组，给定小一点的正数k，找到数组中出现次数大于 n/k 的数字",
        "desc": "举几个例子：\n1. 假设 n=100，k=2，那么需要找到数组中出现次数大于 50 的数。\n1. 假设 n=100，k=10，那么需要找到数组中出现次数大于 10 的数。",
        "answer": "1. 方案1：使用hashmap，遍历一次数组，将数组的数字当做key放入hashmap中，并将出现的次数作为value。之后再遍历hashmap将次数大于 n/k 的数打印出来即可\n2. 方案2：假设要求空间复杂度为O(K)，时间复杂度尽量低该怎么做？\n   - 可以给一点提示：换一个思路，每次都从数组中删除K个互不相同的数，那么删除 n/k 次后，还在数组中的数的出现次数，应该至少都大于 n/k \n\t - 最终答案：申请一个K空间的hashmap，按照方案1的思路遍历数组并插入hashmap，每当hashmap有K个值时，就将hashmap里的value减1，如果为0，就从hashmap中删除该key。当数组遍历完，hashmap中剩余的key/value对，就基本是我们要找的数（还需要再次遍历hashmap检查一下次数）",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "平均延迟最大的调用链",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很多也很长，我们需要找出耗时最大的链条进行优化。（假设服务同时调用其依赖的下游服务）</p><p><br></p><p>例如：</p><p>A服务依赖B服务，平均调用延迟100ms，记为(A, B, 100)</p><p>其他依赖和延迟如下：</p><p>(A, C, 200)</p><p>(A, F, 100)</p><p>(B, D, 100)</p><p>(D, E, 50)</p><p>(C, G, 300)</p><p>那么服务A有三条调用链：A-B-D-E，A-C-G，A-F，平均延迟250，500，100</p><p>延迟最大的调用链是A-C-G，延迟为500ms</p><p><br></p><p>输入：</p><p>[(A, B, 100), (A, C, 200), (A, F, 100), (B, D, 100), (D, E, 50), (C, G, 300)]</p><p>输出：</p><p>500</p><p><br></p><p>Follow up：</p><p>1. 能否输出延迟最大的调用链，如果存在多条，都输出</p>",
        "answer": "<p>可以采用搜索的思路解决，例如DFS</p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "最大能连续观看剧集数",
        "desc": "小明常常用BT下载连载电视剧、综艺观看。\n\n因为种子、网络等诸多因素，可能不是所有的剧集都能现在下来，且现在的顺序也不一定按照从第一集到第n集排列。\n\n请问：已知小明已下载的某部电视剧的剧集列表，求小明最多能连续观看多少集？\n\n例如：episodes = [10, 1, 3, 4, 7, 6, 20, 5, 13, 23, 14]\n\n那么小明做多能连续看[3, 4, 5, 6, 7]共5集\n\n希望时间复杂度O(N)",
        "answer": "我们看一般的case寻找连续剧集，其实就看当前剧集i的前一集i-1下载了没，或者后一集i+1下载了没\n\n也就是往前查查、往后查查，为了方便查，我们可以用hash，例如python里的set。\n\n知道这个原理后，我们可以比较容易的写出代码。\n\n``` python\ndef long_episode_count(episodes):\n    remains = set(episodes)\n   \tlong_count = 0\n    for i in episodes:\n        if i not in remains:\n            continue\n        remains.remove(i)\n        while pre in remains:\n            remains.remove(pre)\n            pre -= 1\n        while next in remains:\n            remains.remove(next)\n            next += 1\n        long_count = max(long_count, next - pre - 1)\n   return long_count\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "hash"
        ]
    },
    {
        "name": "根据访问日志统计出头条每日最火的n篇文章",
        "desc": "每日的访问日志记录有文章id，简化起见，访问的文章id存在输入数组中，给定n，要求返回查看次数最多的文章id\n\n例如：visit_log = [ 10001, 1002, 10001, 20032, 302, 302]\n\n如果n = 2，则根据上面的访问日志，不难看出[10001、302]是最火的2篇文章\n",
        "answer": "首先对访问日志的文章id做计数，然后根据计数做排序得到top n。\n\n在排序方法选择方面，top n适合用堆来实现。\n\n``` python\ndef top_article_id(visit_log, n):\n\tarticle_cnt = collections.Counter()\n\tfor article_id in visit_log:\n\t\tarticle_cnt[article_id] += 1\n\theap = article_cnt.keys()\n\t\n\tdef _heap_adjust(heap, parent, heap_size, article_cnt):\n\t\twhile parent < heap_size:\n\t\t\tleft, right = parent * 2 + 1, parent * 2 + 2\n\t\t\tswap_pos = parent\n\t\t\tif left < heap_size and article_cnt[heap[left]] < article_cnt[heap[parent]]:\n\t\t\t\tswap_pos = left\n\t\t\tif right < heap_size and article_cnt[heap[right]] < article_cnt[heap[swap_pos]]:\n\t\t\t\tswap_pos = right\n\t\t\tif swap_pos != parent:\n\t\t\t\theap[parent], heap[swap_pos] = heap[swap_pos], heap[parent]\n\t\t\t\tparent = swap_pos\n\t\t\telse:\n\t\t\t\tbreak\n\n\tfor i in range(int(math.ceil(n / 2) - 1), -1, -1):\n\t\theap_adjust(heap, i, n, article_cnt)\n\tfor i in range(n, len(heap)):\n\t\tif article_cnt[heap[0]] < article_cnt[heap[i]]:\n\t\t\theap[0] = heap[i]\n\t\t\theap_adjust(heap, 0, n, article_cnt)\n\treturn heap[:n]",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "排序",
            "堆",
            "统计"
        ]
    },
    {
        "name": "实现字典树",
        "desc": "字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n它有3个基本性质：根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。\n\n请实现字典树Class，并完成单词插入和查找函数。",
        "answer": "参考实现代码：\n``` python\nclass TrieNode(object):\n    def __init__(self):\n        self.is_leaf = False\n        self.children = [None] * 26\n        \nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        if not word:\n            return\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                cur_node.children[index] = TrieNode()\n            cur_node = cur_node.children[index]\n        cur_node.is_leaf = True\n        \n    def search(self, word):\n        if not word:\n            return False\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                return False\n            cur_node = cur_node.children[index]\n        return cur_node.is_leaf\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "Trie"
        ]
    },
    {
        "name": "36进制正整数加法",
        "desc": "36进制由0-9，a-z，共36个字符表示，最小为'0'\n\n'0'~'9'对应十进制的0~9，'a'~'z'对应十进制的10~35\n\n例如：'1b' 换算成10进制等于 1 * 36^1 + 11 * 36^0 = 36 + 11 = 47\n\n要求按照加法规则计算出任意两个36进制正整数的和\n\n如：按照加法规则，计算'1b' + '2x' = '48'\n\n要求：**不允许把36进制数字整体转为10进制数字，计算出10进制累加结果再转回为36进制**\n\n本题可任意改变进制，如加入大写字母变为62进制。",
        "answer": "``` python\ndef add(num1, num2):\n    '''\n    &gt;&gt;&gt; add('', '')\n    ''\n    &gt;&gt;&gt; add('', '1')\n    '1'\n    &gt;&gt;&gt; add('ab', '')\n    'ab'\n    &gt;&gt;&gt; add('1b', '2x')\n    '49'\n    &gt;&gt;&gt; add('0', '2x')\n    '2x'\n    &gt;&gt;&gt; add('zz', '1')\n    '100'\n    '''\n    def _get_value(num):\n        if ord('0') <= ord(num) <= ord('9'):\n            return ord(num) - ord('0')\n        return ord(num) - ord('a') + 10\n\n    def _to_chr(num):\n        if 0 <= num <= 9:\n            return str(num)\n        return chr(ord('a') + num - 10)\n\n    def _add(n1, n2, carry):\n        result = _get_value(n1) +  _get_value(n2) + carry\n        carry = 1 if result &gt;= 36 else 0\n        result %= 36\n        return _to_chr(result), carry\n\n    len1, len2 = len(num1), len(num2)\n    if len1 &gt; len2: # 取巧：把两个数字长度对齐\n        num2 = '0' * (len1 - len2) + num2\n    elif len2 &gt; len1:\n        num1 = '0' * (len2 - len1) + num1\n    res = []\n    carry = 0\n    for i in xrange(max(len1, len2) - 1, -1, -1):\n        tmp, carry = _add(num1[i], num2[i], carry)\n        res.append(tmp)\n    if carry:  # 易错点：很容易遗漏\n        res.append('1')\n    return ''.join(res[::-1])  # 易错点：需要翻转\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "字符串",
            "编程",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数",
        "desc": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数的位置，从 1 开始计数。例如：\n-2，-1，0，0，0，0，4，5\n最后一个负数出现的位置为：2，第一个正数出现的位置为7。",
        "answer": "1. 二分查找 0 的位置;\n2. 注意边界位置 0 的处理，在二分条件上需要做一些处理，如果只是找到 0 的位置然后遍历找到第一个和最后一个 0 的话， 复杂度为恶化;\n3. 整体复杂度为 O(lg(n));",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "青蛙跳石子",
        "desc": "在长度为m的地面格子上，每个格子里面有一些石子；有一只青蛙, 从格子开始处起跳，每次可以跳3到5个格子，求青蛙跳出格子最少需要踩几个石子；",
        "answer": "简单DP\ndp[i]表示调到第i的位置最少需要踩几个石子;\n于是dp[i]可由dp[i-3], dp[i-4], dp[i-5]得来;",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "给定一个字符串如下，请统计字符串中出现最多的字母和次数",
        "desc": "```javascript\nfunction findMaxDuplicateChar(str) {\n       let maxChar = '', maxValue = 1;\n    // 补全代码.....\n    return {\n        maxChar,\n        maxValue\n    };\n}\nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "answer": "```javascript\nfunction findMaxDuplicateChar(str) {\n    if (str.length === 1) {\n        return str;\n    }\n    const charObj = {};\n    let maxChar = '', maxValue = 1;\n    for(let i = 0; i < str.length; i++) {\n        if (str[i].trim() !== '') {\n            if (!charObj[str.charAt(i)]) {\n                charObj[str.charAt(i)] = 1;\n            } else {\n                charObj[str.charAt(i)] += 1;\n            }\n        }\n    }\n    for (const k in charObj) {\n        if (charObj[k] &gt;= maxValue) {\n            maxChar = k;\n            maxValue = charObj[k];\n        }\n    }\n    return {\n        maxChar,\n        maxValue\n    };\n}\n \nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表",
            "基础算法",
            "统计"
        ]
    },
    {
        "name": "数组排序",
        "desc": "<p>输入数组nums，要求输出升序排序后的结果。已知数组元素为非负整数，且当数组长度为n时，所有元素的值都小于n；</p><p>例：</p><p>[3, 2, 1, 3, 5, 0]  -&gt; [0, 1, 2, 3, 3, 5]</p><p>[0] -&gt; [0]</p>",
        "answer": "<p>O(n2)的排序算法：冒泡排序，插入排序，选择排序 等；</p><p>O(nlog(n))的排序算法：归并排序，快排 等；</p><p>O(N)的排序算法：空间换时间，利用计数实现，需要O(n)空间复杂度；</p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "二叉树转换成双向链表",
        "desc": "转换结果满足下面条件：\n1. 不要新建一个链表空间，要原地做；直接使用 left 和 right 指针\n2. 转换后的双向链表节点顺序要与中序遍历的结果一致\n3. 二叉树最左边的节点作为双向链表的头节点\n\n例如:\n二叉树:\n\n                    1\n            2                3\n        4        5        6        7\n\n双向链表: 4 <-&gt; 2 <-&gt; 5 <-&gt; 1 <-&gt; 6 <-&gt; 3 <-&gt; 7",
        "answer": "二叉树遍历；递归；链表操作\n\n原理上看，对根节点、根的左子树、根的右子树分别作处理：\n1. 比如根节点1， 对于左子树，找到它的最右节点 5， 把 5 和 1 连接起来；\n2. 对于 1 的右子树，找到它的最左节点 6，把 6 和 1 连接起来。\n\n实现上，假设已经把左子树变做双向链表了，让指针一直向右走，就能找到最右节点和根连接；\n右子树同理。\n\n返回结果的时候，找到双向链表的最左节点就可以了。\n\n```\n    private Node convertToDoublyLinkedList(Node root) {\n        if (root.getLeft() != null) {\n            Node left = convertToDoublyLinkedList(root.getLeft());\n            while (left.getRight() != null) {\n                left = left.getRight();\n            }\n            left.setRight(root);\n            root.setLeft(left);\n        }\n         \n        if (root.getRight() != null) {\n            Node right = convertToDoublyLinkedList(root.getRight());\n            while (right.getLeft() != null) {\n                right = right.getLeft();\n            }\n            right.setLeft(root);\n            root.setRight(right);\n        }\n        return root;\n    }\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "双向链表"
        ]
    },
    {
        "name": "翻转单词",
        "desc": "给定一个字符串，逐个翻转字符串中的每个单词。",
        "answer": "根据情况，选择栈和队列即可\n栈必须，队列可选",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "字符串"
        ]
    },
    {
        "name": "两个数的和相加",
        "desc": "<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p>",
        "answer": "<p><br></p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "二叉树所有根到叶子路径组成的数字之和",
        "desc": "二叉树每个节点的value范围是1-9\n\n例如：\n```\n\t\t   1\n\t 2\t\t    3 \n 4\t  5\n```\n从根到叶子共3条：1-&gt;2-&gt;4, 1-&gt;2-&gt;5, 1-&gt;3\n\n构成的数字为124，125，13，求和124 + 125 + 13 = 262即为所求",
        "answer": "``` python\ndef tree_path_sum(root, val):\n\tif not root:\n\t\treturn 0\n\tval = val * 10 + root.val\n\tif not root.left and not root.right:\n\t\treturn val\n\treturn tree_path_sum(root.left, val) + tree_path_sum(root.right, val)\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "三门问题/蒙蒂大厅难题",
        "desc": "你面前有三扇门，每个门后都有一个奖品，其中一个是一辆车，另外两个是山羊。\n你首先挑选一扇门，姑且称之为A，其他两个门分别是B和C。\n在打开你选择的门前，我先从B和C中选择一个没有车的门打开。\n给你一个选择，你是坚持最开始的选择还是换到剩下未打开的门上？\n\n如果我打开门的策略从随机选择，变成总是优先选择门B，只有在迫不得已的时候选择C。\n问结果有变化么？",
        "answer": "使用贝叶斯公式求解，p(a|b)*p(b) = p(a)*p(b|a)\n三种假设，即假设车在门A，门B，门C后面。\nD表示打开了门B但是车不在门后。\n假设A：先验概率=1/3，似然度=1/2，后验概率=(1/3)*(1/2)/(1/2)=1/3\n假设B：先验概率=1/3，似然度=0, 后验概率=0\n假设C：先验概率=1/3，似然度=1，后验概率=2/3\n\n变化之后概率相同。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "贝叶斯",
            "概率"
        ]
    },
    {
        "name": "海盗分金问题",
        "desc": "5个海盗要分100块金币，分配的协议是：按顺序一个一个来，轮到当前的海盗，他提出一个分配方案，如果包括他在内至少有50%的人同意，那么方案通过，否则这个海盗就会被喂鲨鱼，下一个海盗继续提出分配方案。 \n假设海盗都是纯理性而且冷血的，他们的第一原则是生存，第二原则就是拿到尽可能多的金子，第三原则是如果给的金币一样，他们倾向于选择有更少的海盗的分配方案。",
        "answer": "思路： \n5个人太多了，首先把问题简化。从1个人到5个人逐个分析。\n* 1个人，显然自己全拿\n* 2个人。1，2。2号海盗显然可以全部拿走，因为他自己的一票保证了50%。\n* 3个人。1，2，3。首先，如果3号的方案没通过，那么1号将什么都得不到，而2号必定要除3号而后快。因此3号必须征得1号的支持，但又不能完全不给1号任何金币（第三原则）。因此分配方案是1 2 3 = 1 0 99。这样3号的方案能够得到1和3的支持。\n* 4个人。1，2，3，4。首先，如果4号的方案没通过，那么2号将什么都得不到。因此4号只需要分配1 2 3 4 = 0 1 0 99\n* 5个人。1，2，3，4，5。5号清楚的知道一旦他的方案不通过，1和3将什么都得不到，因而他只需要分配1 2 3 4 5 = 1 0 1 0 98，这样即足以保证。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "牛过河",
        "desc": "<p><strong>有一堆牛要过河，河的长度是ｌ，河中间有ｎ个石头，牛只能踩着石头过河，问去掉ｍ个石头后（去掉这ｍ个石头的方式是随机的）的每种情况牛能走的石头间距最小值中，最大的那一个是多少</strong></p>",
        "answer": "<p>二分最大值最小化问题</p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "求二叉树是否存在和值为N的路径",
        "desc": "从二叉树的根到叶子节点称为一条路径\n\n路径上每个节点的value之和为路径和值\n\n本题要求所有的路径中是否存在一条和值为N的。\n\nfollow-up：可以要求返回所有符合条件的路径",
        "answer": "要求自己给出二叉树数类定义\n\n本题很容易用递归解决，基本思路如下：\n\n```\ndef path_exists(root, n):\n\tif not root:\n\t\treturn False\n\tif not root.left and not root.right and root.value == n:\n\t\treturn True\n\treturn path_exists(root.left, n - root.value) or path_exists(root.right, n - root.value)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "special trim",
        "desc": "对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'\n\n例如：\n\n'aacbd' -&gt; 'ad'\n\n'aabcd' -&gt; 'ad'\n\n'aaabbccc' -&gt; ''\n\n不允许使用类似string.replace函数。要求时间、空间复杂度尽量优化",
        "answer": "本题不好处理的是aaabccc，即：c和a相遇就要都去掉。\n\n比较好的思路是用栈的思路解决。\n\n``` python\ndef special_trim(s):\n    if not s:\n        return s\n    res = []\n    for c in s:\n       if c == 'b':\n            continue\n       if c == 'c' and res and res[-1] == 'a':\n            res.pop()\n            continue\n       res.append(c)\n    return ''.join(res)\n```",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "栈",
            "字符串"
        ]
    },
    {
        "name": "约瑟夫问题",
        "desc": "假设有n个人，标号为1-n。\n从第一个人开始计数，到第k个人则出列，随后从第k+1个人重新计数，到第k再出列。\n直至剩下最后一个人。问最后剩下的人的编号？",
        "answer": "考察链表使用。最简单直接的方法是使用循环链表。\n具体思路是：\n1. 构建循环链表，初始化数据；\n2. 每到第k-1个结点，便p-&gt;next = p-&gt;next-&gt;next。\n3. 循环结束条件为p = p-&gt;next，即只有一个结点，该结点所对应的值即为最后剩下的人。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "二叉搜索树中的第K小的元素",
        "desc": "给定二叉搜索树，求所有元素中第k小的。k<=节点总数",
        "answer": "结合BST的性质，用递归很好解决，按照中序遍历即可\n核心代码：\n``` python \ndef find_k_small(root, k):\n\tdef _find(root):\n\t\tif not root:\n\t\t\treturn -1\n\t\tval = _find(root)\n\t\tif not k:\n\t\t\treturn val\n\t\tk -= 1\n\t\tif not k:\n\t\t\treturn root.val\n\t\treturn _find(root)\n\t_find(root)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "序列化和反序列化二叉树",
        "desc": "将一棵二叉树序列化为字符串，并能字符串反序列为一棵树。",
        "answer": "本题解法应该有不少，大体思路是按照某种遍历的顺序记录下每个节点，叶子节点的空指针可以用特殊字符表示\n\n例如用先根遍历解决：\n``` python \n    def serialize(root):\n        def pre_order(node):\n            if node:\n                vals.append(str(node.val))\n                pre_order(node.left)\n                pre_order(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        pre_order(root)\n        return ' '.join(vals)\n\n    def deserialize(data):\n        def pre_order():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = pre_order()\n            node.right = pre_order()\n            return node\n            \n        vals = iter(data.split())\n        return pre_order()",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "带过期和最大对象数限制的LRU-CACHE",
        "desc": "设计一个对象cache, 他支持下列两个基本操作:\nset(id, object), 根据id设置对象;\nget(id): 根据id得到一个对象;\n同时它有下面几个性质:\n1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期;\n2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数;\n3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象;\n请你设计这样一个cache;",
        "answer": "通过组合一些基本的数据结构, \n来实现一些更高级的性质;\n\n内部维护一个链表, list, 其元素为一个三元组(ID, timestamp, obj), 分别为对象ID, 上次被访问时间, 和对象内容;\n在维护该list时, 需要保持一个性质, 越靠后的元素越新, 既timestamp越大;\n内部再维护一个map, 该map表示一个ID到list节点的索引, 格式为map(ID, node);\n对于get(id)操作:\n1: 先在map中查找ID对应的list node;\n2: 将node从list中取出, 即list.Remove(node);\n3: 检查node.timestamp, 如果过期, 则返回null, 表示无数据, 并将ID从map中删除;\n4: 如果未过期, 设置node.timestamp = now(), 并将node添加到list尾部, 即list.Append(node);\n5: 返回node.obj;\n对于set(id, obj)操作:\n1: 同get(id)的1~3步操作, 删除对应的ID;\n2: 如果此时空间满了, 既对象数为n, 则将list中表头的那个元素删除;\n3: 更新list和map: node = new(ID, now(), obj), list.Append(node), map[ID] = node;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "n sum",
        "desc": "<p>输入一维数组array和n，找出和值为sum的n个元素即可，不用找出所有组合。</p><pre><code>array = [2, 3, 1, 10, 4, 30] n = 2, sum = 31\nresult = find(array, n, sum)\n// result = [1, 30]</code></pre><p><br></p>",
        "answer": "<p>基础解法供参考</p><pre><code>function find(arr, n, sum, shouldSort = true) {\n let sorted = arr;\n if (shouldSort) {\n  sorted = arr.sort();\n }\n const length = sorted.length;\n if (n === 2) {\n  let front = 0;\n  let back = length - 1;\n  while(front < back) {\n   const value = sorted[front] + sorted[back];\n   if (value === sum) {\n    return [sorted[front], sorted[back]];\n   } else if (value &gt; sum) {\n    back -= 1;\n   } else {\n    front += 1;\n   }\n  }\n  return null;\n }\n for(let i = 0; i < length; i += 1) {\n  const val = sorted[i];\n  const result = find(sorted.slice([i + 1]), n - 1, sum - val, false);\n  if (!result) {\n   return null;\n  } else {\n   return [val, ...result];\n  }\n }\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表",
            "算法"
        ]
    },
    {
        "name": "多叉树广度优先遍历查找",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>按照广度优先查找符合要求的节点（没有符合要求的节点返回null），比如查找电话号码为 phone的用户信息，调用如下：</li></ol><p><br></p><pre><code>let node = wideTraversal(node,(e)=&gt;e.phone===phone)</code></pre><p><br></p>",
        "answer": "<p>节点定义：</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>实现：</p><pre><code>wideTraversal(node: Node, predict): Node | null {\n  if (!node) return null\n  let queue: Array<Node&gt; = [];\n  queue.push(node)\n  while (queue.length) {\n    let cur = queue.shift()\n    if (!cur) continue\n    if (predict(cur)) return cur\n    if (cur.children&amp;&amp; cur.children.length) {\n      queue.push(...cur.children)\n    }\n  }\n  return null\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "广度优先遍历",
            "前端编码",
            "多叉树"
        ]
    },
    {
        "name": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点",
        "desc": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点，各个相邻顶点间距离为1",
        "answer": "方案：对图进行K步的BFS, 注意处理被重复走过的点;\n",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出所有根节点到叶子节点的路径",
        "desc": "比如:\n\n            1\n          2   3\n         4  5 6  7\n                  8\n\n输出：\n\n    1，2，4\n    1，2，5\n    1，3，6\n    1，3，7，8\n",
        "answer": "二叉树遍历",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找出旋转有序数组中的最小值",
        "desc": "假设原数组为1，2，3，4，5那4，5，1，2，3就是旋转有序的数组\n\n注：数组无重复元素",
        "answer": "暴力可以O(n)，但没用到旋转有序的特征。\n\n本题可以用二分的思想降低时间复杂度\n\n定义左右两个指针left、right指向头尾元素\n\n如果a[left] < a[right]则没有移位，直接输出a[left]即可，反之二分搜索。\n\n如果a[left] &gt; a[mid] 则要搜索右半段，因为a[left]也大于a[right]；反之搜索左半段。\n\n核心代码\n``` python\ndef find_min(arr):\n\tleft, right = 0, len(arr) - 1\n\tif arr[left] < arr[right]:\n\t\treturn arr[left]\n\twhile left != right - 1:\n\t\tmid = left + (right - left) / 2\n\t\tif arr[left] < arr[mid]:\n\t\t\tleft = mid\n\t\telse:\n\t\t\tright = mid\n\t\treturn min(arr[left], arr[right])\n\t\t",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "有序数组"
        ]
    },
    {
        "name": "搜索二维矩阵",
        "desc": "给定二维m * n矩阵matrix，满足一定特性：\n1. 每行从左到右递增\n2. 每列从上到下递增\n给定目标元素num，判断num是否在矩阵中存在\n\n例如：\n``` python \nmatrix = [\n\t[1, 3, 5, 10],\n\t[2, 4, 6, 11],\n\t[7, 9, 12, 20],\n]\n```\nnum = 4存在；num = 13不存在\n",
        "answer": "结合数组定义，观察例子，有两个特殊位置很特殊：左下角和右上角。\n\n左下角的7往上所有的数变小，往右所有的数变大。\n\n那么我们就可以将目标数字num和左下角比较，比目标小就往右搜，比目标大就往上搜。\n\n如此往复可以判断num是否在matrix中。\n\n``` python\ndef search(matrix, num):\n\tif not matrix:\n\t\treturn False\n\trows, cols = len(matrix), len(matrix[0])\n\tif num < matrix[0][0] or num &gt; matrix[rows - 1][cols - 1]:\n\t\treturn False\n\ti, j = rows - 1, 0 # 左下角\n\twhile i &gt;= 0 and j < cols:\n\t\tif matrix[i][j] < num:\n\t\t\tj += 1\n\t\telif matrix[i][j] &gt; num:\n\t\t\ti -= 1\n\t\telse:\n\t\t\treturn True\n\treturn False\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "扑克牌的堆栈、队列操作",
        "desc": "我手中有一堆扑克牌， 但是观众不知道它的顺序。\n\n*  第一步， 我从牌顶拿出一张牌， 放到桌子上。\n*  第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。\n*  第三步， 重复第一步的操作， 直到我手中所有的牌都放到了桌子上。 \n\n最后， 观众可以看到桌子上牌的顺序是：13\\12\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\n请问， 我刚开始拿在手里的牌的顺序是什么？",
        "answer": "解法一：\n这道题候选人容易出现折半的思路， 其实考虑的复杂了。 \n本质是将一个队列和栈做了两个操作\n1. 出队、入栈\n2. 出队、入队（队尾）\n\n因为是看得到结果， 看不到初始顺序， 那么这个操作就是一个逆操作。 \n1. 出栈、入队\n2. 出队（队尾）、入队（队首）\n答案：\n输入：\n1,2,3,4,5,6,7,8,9,10,11,12,13,\n输出：\n1,12,2,8,3,11,4,9,5,13,6,10,7,\n\n代码如下\n``` C++ 再改改\nint doTheWork(std::deque * pQ, std::stack * pS)\n{\n        if(NULL == pQ or NULL == pS)\n                return -1;\n        while(pS-&gt;size() &gt; 0)\n        {\n                int val = pS-&gt;top();\n                pS-&gt;pop();\n                if (pQ-&gt;size() &gt; 0)\n                {\n                        int tmp = pQ-&gt;back();\n                        pQ-&gt;pop_back();\n                        pQ-&gt;push_front(tmp);\n                        pQ-&gt;push_front(val);\n                }\n                else\n                {\n                        pQ-&gt;push_front(val);\n                }\n        }\n        return 0;\n}\n```\n\n解法二：\n对手上牌按照a，b，c...进行编码，直接按顺序操作，输出结果和桌上实际结果对应，即为原手上牌的顺序。",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "用js实现一个binarySearch二分查找",
        "desc": "定一个一个binarySearch的函数，传参能支持四个参数，分别是：\n&gt;1. arr: 一个数组，\n&gt;1. key: 一个需要查找的目标值，\n&gt;1. low: 左边界\n&gt;1. high: 右边界\n&gt;1. 如果能知道则访问素组的位置，否则返回-1\n```javascript\nfunction binarySearch(){\n  // 补全代码\n}\nvar arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\nvar result = binary_search2(arr, 5, 0, 6);\nconsole.log(result);   // 4\n```",
        "answer": "二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：\n&gt;1. 首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n&gt;1. 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n&gt;1. 如果某一步数组为空，则表示找不到目标元素。\n```javascript\n // 递归实现的js代码\n  function binary_search2(arr, key, low, high) {\n    if(low &gt; high) {\n      return -1;\n    }\n    var mid = parseInt((high + low) / 2);\n    if(arr[mid] == key) {\n      return mid;\n    } else if(arr[mid] &gt; key) {\n      high =mid -1;\n      return binary_search2(arr, key, low, high);\n    } else if(arr[mid] < key) {\n      low = mid +1;\n      return binary_search2(arr, key, low, high);\n    }\n  }\n\n  var arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\n  var arrSorted = arr.sort(function (a,b) {\n    return a-b;\n  })\n  var result = binary_search2(arrSorted, 5, 0, 10);\n  console.log(result);   // 4\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": [
            "查找",
            "js"
        ]
    },
    {
        "name": "通配符匹配",
        "desc": "给定字符串s和模式串p，实现函数match(s, p)，判断模式串p是否能完全匹配s\n\n模式串中有两个特殊字符'?'和'*'\n\n'?'匹配任意1个字符；'* '匹配任意r个字符，包括空\n\n例如:\n``` python\nmatch('a', 'a') = True\nmatch('aa', 'a') = False\nmatch('a', '?') = True\nmatch('aa', '*') = True\nmatch('abc', '?*') = True\n```",
        "answer": "本题可以用DP算法来解答。\n\n用dp[i, j]表示串s, p这两个串分别到i和j位置它们是否匹配。那么我们得到递推关系：\n\n如果p[j] != '* ', dp[i, j] = dp[i-1, j-1] and (s[i] == p[j] || p[j] == '?') \n\n如果p[j] == '* ', 那么dp[i][j] = dp[i - 1][j] || dp[i][j - 1]\n\n``` python\ndef match(s, p):\n\tm, n = len(s), len(p)\n\tdp = [[False] * (n + 1) for _ in range(m + 1)]\n\tdp[0][0] = True\n\tfor j in range(1, n + 1):\n\t\tdp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif p[j - 1] in [s[i - 1], '?']:\n\t\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\telif p[j - 1] == '*':\n\t\t\t\tdp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\treturn dp[m][n]\n```\n另外，本题也可以用贪心算法",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": []
    },
    {
        "name": "原子计数问题",
        "desc": "给出一个分子式，比如：\n     HMg2(H2O(N3Ag)2)3N2\n计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：\nmap[string]int {&#34;H&#34;: 7, &#34;Mg&#34;: 2,&#34;Ag&#34;: 6, ...}\n\n分子式的规则：\n1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H\n2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 [2-1000]\n3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N出现 6 次，Ag 出现 2 次\n4. 括号可以嵌套\n\n输入是合法的\n",
        "answer": "1. 最简单的方法是递归，碰到 ( 就开始递归\n2. 担心爆栈就把递归改成非递归\n3. 可以用正则表达式来做，这里不展开了，如果候选人懂的话让他解释",
        "types": [
            "数据结构与算法",
            "递归",
            "堆栈"
        ],
        "tags": [
            "校招类",
            "编程",
            "代码类",
            "基础算法",
            "字符串"
        ]
    },
    {
        "name": "安卓解锁密码数",
        "desc": "安卓系统采用9个点连线构成图案密码。\n\n要求连接以下9个点中**至少4个点**构成一条路径，从而得到1个密码。\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n任意点间均可连线，都有如下附加限制：\n1. 在一个密码路径里每个点只能用1次；\n2. 如果2号点没有被连，则1不能直接连3号点，即：1-&gt;3路径是非法的。类似情况还有1、7；2、8；1、9等等；\n3. 如果2点已经连过了，则1可以连到3，3也可以连到1，即：2-&gt;1-&gt;3路径是合法的。\n4. 1和6是可以直接连线的，因为二者之间没有点。\n\n本问题求所有的密码数，也就是路径数，包含4个点、5个点。。。9个点的所有路径数。",
        "answer": "本题目如果数据结构算法比较熟悉，会很快想到DFS。\n\n难点是路径不能直达问题如何解决？\n\n用visit记录某个点是否已经在路径中\n\n``` python\nvisit = [[0, 0 ,0],\n         [0, 0, 0],\n         [0, 0, 0]]\n```\n\n判断两个点能否连同，等价于判断两个点是否存在中间点问题，如果不存在可以直接连，如果存在要判断中间点是否已经访问过了。\n\n中间点坐标为：|i1 - i2| / 2, |j1 - j2| / 2\n\n另外，本题考虑到对称性会大大降低运算量\n\n1、3、7、9点对称\n\n2、4、6、8点对称",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "矩阵中的最长递增路径",
        "desc": "给定m * n矩阵matrix，可以从任意位置开始，向上、向下、向左、向右移动，但要求下一个位置上的元素要大于当前元素。\n\n找出最长的递增路径长度。",
        "answer": "本题很容易想到dfs，但问题是每个点开始递归搜索，重复计算很多，结合DP提升效率。\n\n用dp[i][j]表示从(i,j)开始的最长递增路径长度，当递归调用时，如果dp[i][j]不为0，直接返回dp[i][j]。\n\n``` python\ndef long_increase_path_len(matrix):\n\tif not matrix:\n\t\treturn 0\n\tres = 1\n\tm, n = len(martix), len(matrix[0])\n\tdp = [[0] * n for _ in range(m)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tres = max(res, dfs(matrix, dp, i, j, m, n))\n\treturn res\n\ndef dfs(matrix, dp, i, j, m, n):\n\tif dp[i][j]:\n\t\treturn dp[i][j]\n\ttmp_max = 1\n\tdirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]:\n\tfor ni, nj in dirs:\n\t\tii, jj = i + ni, j + nj\n\t\tif ii < 0 or ii &gt;= m or jj < 0 or jj &gt;= n or matrix[ii][jj] <= matrix[i][j]:\n\t\t\tcontinue\n\t\ttmp_max = max(tmp_max, 1 + dfs(matrix, dp, ii, jj, m, n)\n\tdp[i][j] = tmp_max\n  return dp[i][j]\n```",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "升序数组求平方数不同的个数",
        "desc": "给定一个升序数组1，元素有重复，对每个元素算一下平方后得到新的数组2，问数组2中不相同的元素共有多少个？给出算法和空间复杂度，要求尽量优化。\n举例：\n数组1 [-13,-10,-9,-6,-5,-1,3,4,6,7,10,11,15,21,42]\n平方后得到\n数组2 [169,100,81,36,25,1,9,16,36,49,100,121,225,441,1764]\n其中不相同的元素个数为13个。",
        "answer": "常规解法，按题目思路，先平方算好，再将结果插入hashset，最后输出hashset大小。\n优化1，平方没必要算，其实就是绝对值。\n优化2，注意到数组2其实是以0分隔的一个降序和一个升序数组。反序遍历降序数组，正序遍历升序数组，即可合并成一个升序数组，合并时做一下排重，最后输出合并后数组的元素个数。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "URL反转",
        "desc": "给定形如 `www.toutiao.com` 的 URL，将其转换成 `com.toutiao.www` 的形式，要求必须原地操作",
        "answer": "1. 原地全部翻转一遍；\n2. 遍历遇到&#34;.&#34;，继续翻转该部分字符串；\n该题目重点考察编码，需要保证代码简洁，要不不允许使用字符串库函数",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "判断单向链表是否有环",
        "desc": "<p>判断一个链表中是否有环</p><p>例如：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D</p><p>D指向B形成环</p><p>要求：在空间复杂度O(1)的情况下，时间复杂度最小</p>",
        "answer": "<p>创建两个指针slow，fast，同时指向这个链表的头节点。</p><p>然后让两个指针开始循环移动</p><p>slow每次向下移动一个节点，fast每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环</p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表",
            "单向链表"
        ]
    },
    {
        "name": "给定两个链表，求它们交叉节点",
        "desc": "1.  已知两个链表, 从某个节点开始就交叉了\n2.  已知这两个链表的头节点, 求出交叉的节点",
        "answer": "1. 依次遍历两个链表分别得到链表的长度M和N\n2. 然后让长的那个一个从头开始走|M-N|的步数;\n3. 两个指针同时走, 直到碰头",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "判断一个IP是否是国内",
        "desc": "如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段",
        "answer": "1. 将ip地址通过位移运算转成int\n2. 对ip地址进行排序(可以考察任意一种排序算法)\n3. 二分查找",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "计算机基础",
            "查找",
            "编程",
            "基础算法"
        ]
    },
    {
        "name": "用户在线峰值",
        "desc": "已知一天内用户登录登出的日志（数据量较大），求这一天用户在线的最大峰值和持续时间段\n- 日志包含字段（userid, login_time, logout_time）\n- 登录登出时间精确到秒\n",
        "answer": "可以将这一天看成0-24*3600的离散的时间点，构造一个dict\n每个用户在login_time对应value+1,logout_time对应value-1\n得到用户在线数量的变化趋势，然后再遍历此dict求和\n难点：\n- 想不到先求变化趋势\n- 峰值时间段可能存在多个\n```\ndef get_max(logs):\n    log_count = {}\n    for log in logs:\n        login_time = log['login_time']\n        logout_time = log['logout_time']\n        log_count[login_time] = log_count.setdefault(login_time, 0) + 1\n        log_count[logout_time] = log_count.setdefault(logout_time, 0) - 1\n    max, current_users, start, end, is_max, timeline = (0, 0, 0, 0, False, [])\n    keys = log_count.keys()\n    keys.sort(lambda a, b: a - b)\n    for time_node in keys:\n        current_users = current_users + log_count[time_node]\n        if current_users &gt; max:\n            max = current_users\n            start = time_node\n            is_max = True\n        elif current_users < max:\n            if is_max:\n                end = time_node\n                is_max = False\n        else:\n            if is_max:\n                end = time_node\n            else:\n                timeline.append((start, end))\n                start = time_node\n                is_max = True\n    timeline.append((start, end))\n    return max, timeline\n```\n\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "股票买卖问题",
        "desc": "给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？日期不重叠的情况下，可以买卖多次呢？\n输入: {100, 80, 120, 130, 70, 60, 100, 125} \n只能买一次：65（60 买进，125 卖出）\n可以买卖多次: 115（80买进，130卖出；60 买进，126卖出）\n\n提示：不用输出买卖的序列，只需要得到最大利润\n\n",
        "answer": "1. 对于只能买一次的情况：\n\n```\n    public static int maximumProfit(int[] stockPrices)\n    {\n        int profit = 0;\n        int minimumPrice = Integer.MAX_VALUE;\n        /* \n         * 对于给定的一天，最大利润等于 - \n         * max(昨天为止的最大利润, 当天的价格 - 之前的最小价格)\n         */\n        for(int i = 0; i < stockPrices.length; i++)\n        {\n            profit = Math.max(profit, stockPrices[i] - minimumPrice);\n            minimumPrice = Math.min(stockPrices[i], minimumPrice);\n        }    \n        return profit;\n    }\n```\n\n2. 对于可以买卖多次的情况，累积递增序列的差就可以了：\n```\n    public static int maximumProfit2(int[] stockPrices) {\n        int totalProfit = 0;\n        for(int i=1; i 0){\n                totalProfit += currentProfit;\n            }\n        }\n        return totalProfit;\n    }\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "编程"
        ]
    },
    {
        "name": "输出给定数字下一个比它大的数字",
        "desc": "比如数字：1234， 输出 1243\n\n比如 1243，则输出 1324",
        "answer": "用 1243 为例：\n1. 从右向左扫描，找到第一个不是升序的数字，比如 2\n2. 在 2 的右边，找到比它大的最小的数，是 3\n3. 交换 2和 3，得到 1342\n4. 把现在 3 右边的所有数字从大到小排序，得到 1324 （如果是排序则是 O(nlogn), 其实逆序就行了）",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "Path Sum",
        "desc": "给定一个二叉树和一个数字n，判断二叉树中是否有一个路径上的数字之和等于给定的数字n\n\n\nFor example:\nGiven the below binary tree and sum = 22,\n\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\nreturn true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.\n",
        "answer": "public class Solution {\n\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        int left = sum - root.val;\n        if(root.left == null &amp;&amp; root.right == null &amp;&amp; left == 0) {\n            return true;\n        }\n        return hasPathSum(root.left, left) || hasPathSum(root.right, left);\n    }\n}\n\n可以进一步问，输出所有和等于给定数字n的path",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "简单编程题"
        ]
    },
    {
        "name": "单链表每隔k个元素做一次反转",
        "desc": "给定一个链表，每隔k个元素做一次反转\n\nExample:\nInputs:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 3 \nOutput:  3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;8-&gt;7-&gt;NULL. \n\nInputs:   1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 5\nOutput:  5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;8-&gt;7-&gt;6-&gt;NULL. \n",
        "answer": "Node* rollback(Node *&amp;head, int k) {\n\tNode *pre = NULL;\n\tNode *next = NULL;\n\tNode *curr = head;\n\tint count = 0;\n\twhile (curr != NULL&amp;&amp;countnext;\n\t\tcurr-&gt;next = pre;\n\t\tpre = curr;\n\t\tcurr = next;\n\t\tcount++;\n\t}\n\tif (curr != NULL) {\n\t\thead-&gt;next = rollback(next, k);\n\t}\n \n\treturn pre;\n}\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "简单编程题",
            "单链表"
        ]
    },
    {
        "name": "用两个栈实现一个队列",
        "desc": "用两个堆栈模拟队列的功能，实现push，pop，count三个方法",
        "answer": "简单的做法：栈s1和s2，始终维护s1作为存储空间，以s2作为临时缓冲区，push直接进s1，pop时s1导入s2，栈顶出栈，导回s1\n优化做法：入队时，将元素压入s1，出队时，判断s2是否为空，如不为空，则直接弹出顶元素；如为空，则将s1的元素逐个“倒入”s2，把最后一个元素弹出并出队",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "赛马求最快N匹",
        "desc": "<p>条件：</p><p>1.64匹马</p><p>2.8个赛道</p><p>3.每次比赛只能知道比赛结果名次，不能知道具体时间</p><p>求：</p><p>用最少的比赛次数，找出最快的4匹</p>",
        "answer": "<p>1.每次比赛至少能淘汰4匹（树形淘汰算法），因此淘汰60匹，至少需要15次比赛，回答15，是最差答案</p><p>2.如果能回答出12次的（经过加速之后的简单排序），为次优解：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2）从第9次开始</p><p>\t\t*1.先取每组第一名，每次比赛，找出最快1匹，取出</p><p>\t\t*2.将最快这匹对应的组里次快的加入比赛，一共4次，找出最快4匹</p><p>3.如果能答出特定情况下10次，最差11次，为最优解（剪枝算法）：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2)  第9次，先取每组第一名，进行比赛，找出前四名</p><p>    3)  第10次，将前4名对应的组中的第2名加入比赛，一共8匹，比赛一次，如果对应的前四名没发生变化，说明前4名就是最快4名</p><p>\t4）第11次</p><p>\t\t*1.假设有一个组里的第2名，进入前四名：</p><p>\t\t\t①有一组的第1名被挤出前4名，该组所有的候选马无法进入前4名</p><p>\t\t\t②另外两组第2名之后无法进入前4名</p><p>\t\t\t因此，4（第2名在第10次进入前4名的组对应的前4名）+2（还在前4名的另外两个第1名）=6匹马进行比赛，决出前4名，即为最终答案</p><p>\t\t*2假设有两个组的第2名，进入前四名：</p><p>\t\t\t①则另外两组都无法进入前4名，而还在前4名的两组的前4名4+4=8，跑一次，最终能得到最快4名</p>",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "LRU cache",
        "desc": "实现一个LRU过期算法的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则按照LRU的规则剔除一个KV;\n4. 查询时如果已经过期, 则返回空;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;\n\n解法大致同上;\n为了实现LRU, 可在每次get后, 将该K从cache中删除并重新插入一遍;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "求数组的最大区间和",
        "desc": "# 输出一个 int 型数组的最大连续子数组（所有元素加和最大）各个元素之和\n# 保证数组中至少有一个正数\n\n例：\n\n输入：{1，2，5，-7，8，-10}\n\n输出：9  (子数组为: {1，2，5，-7，8})",
        "answer": "复杂度 `O(n)` 的算法\n\n```\nint _tmain(int A[], _TCHAR* argv[])\n{\n    int array_length = sizeof(A) / sizeof(A[0]);\n    int sum = 0;\n    int thisSum = 0;\n    for (int i = 0; i < array_length; i++)\n    {\n        thisSum += A[i];\n        if (thisSum &gt; sum)\n        {\n            sum = thisSum;\n        }\n        else if (thisSum < 0)\n        {\n            thisSum = 0;\n        }\n    }\n    printf(&#34;%d&#34;,sum);\n    return 0;\n}\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "最长无重复子串",
        "desc": "<p>无重复子串指：子串中每个字符都不相同 例如：s = 'aaabcdddd' 最长的无重复子串为'abcd'长度为4</p>",
        "answer": "<p>用两个指针left、right指向子串的起止位置 通过set记录是否有重复元素，只要没有重复都可以移动right，更新最长子串长度 如果有重复，移动left，并从set里移除对应的字符</p><pre><code>def max_sub_len(s): \n    existed = set() \n    res = 0 \n    left, right = 0, 0 \n    while right < len(s): \n        if s[right] not in existed: \n            existed.add(s[right]) \n            res = max(res, len(existed)) \n            right += 1\n        else: \n            t.remove(s[left]) \n            left += 1\n    return res </code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "服务循环依赖检测",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很长，如果出现循环依赖将出现非常恶劣的影响。</p><p>对于一个具体应用，已知各个服务的调用关系（即依赖关系），请判断是否存在循环调用。</p><p>输入：</p><p>一组服务依赖关系list，('A', 'B') 表示 A 会调用 B 服务</p><p>service_relations = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('D', 'A')]</p><p>输出：</p><p>由于存在 A - B - D - A 故存在循环依赖，返回True；反之如果不存在，返回False</p><p>Follow up：</p><p>1. 如果有多个环，请都检测出来</p><p>2. 返回每个环中的服务名</p>",
        "answer": "<p>可以采用拓扑排序 或者 DFS思路解决</p>",
        "types": [
            "数据结构与算法",
            "图"
        ],
        "tags": [
            "检测"
        ]
    },
    {
        "name": "比较版本号",
        "desc": "<p>比较两个版本号 version1 和 version2。</p><p>如果 version1 &gt; version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。</p><p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p><p> . 字符不代表小数点，而是用于分隔数字序列。</p><p>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p><p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p><p> </p><p>示例 1:</p><p>输入: version1 = &#34;0.1&#34;, version2 = &#34;1.1&#34;</p><p>输出: -1</p><p>示例 2:</p><p>输入: version1 = &#34;1.0.1&#34;, version2 = &#34;1&#34;</p><p>输出: 1</p><p>示例 3:</p><p>输入: version1 = &#34;7.5.2.4&#34;, version2 = &#34;7.5.3&#34;</p><p>输出: -1</p><p>示例 4：</p><p>输入：version1 = &#34;1.01&#34;, version2 = &#34;1.001&#34;</p><p>输出：0</p><p>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p><p>示例 5：</p><p>输入：version1 = &#34;1.0&#34;, version2 = &#34;1.0.0&#34;</p><p>输出：0</p><p>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>",
        "answer": "<h4><strong>方法1：分割+解析，两次遍历，线性空间</strong></h4><h4><strong>方法2：双指针，一次遍历，常数空间</strong></h4>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "单链表(奇数位升序，偶数位降序)的排序",
        "desc": "单链表，奇数位升序，偶数位降序，现在要求整体排成全局升序\n输入：1-&gt;200-&gt;10-&gt;120-&gt;30-&gt;8-&gt;88-&gt;4\n输出：1-&gt;4-&gt;8-&gt;10-&gt;30-&gt;88-&gt;120-&gt;200",
        "answer": "思路：链表可以随便拆、组合\n先把奇数和偶数拆开，形成两个链表，一个升序和一个降序\n1-&gt;10-&gt;30-&gt;88\n200-&gt;120-&gt;8-&gt;4\n然后将降序的反转，再合并成一个列表\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "蛇形打印二叉树",
        "desc": "输入一棵二叉树，比如：\n```\n              0\n        1            2\n      3     4      5     6\n          7            8   9\n```\n将它蛇形输出，结果如下：\n0，1，2，6，5，4，3，7，8，9",
        "answer": "1. 依赖栈记录每层节点值：层次便利，按偶数层（根是 0 层）从右到左，奇数层从左到右输出，时间空间复杂度都是 O(n)，n 是节点数\n2. 不依赖栈，递归：d 是层数，for i from 0 to d， 如果 i 是偶数，后序遍历二叉树的 0到i层，输出第i层的节点；如果i是奇数，先序遍历 0到 i 层，也只输出第i层节点。空间复杂度是 O(d) 即递归深度，时间复杂度是 o(d^2) 因为 0层节点会被访问 d 次，1 层节点 d-1 次，以此递推。",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "冒泡排序和快速排序的复杂度区别是什么，如何实现？",
        "desc": "```javascript\n/**\n * Quick Sort\n **/\nfunction quickSort(arr) {\n    // 补全代码\n}\nconsole.log(quickSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n\n/** \n * BubbleSort\n **/\n \nfunction bubbleSort(arr) {\n    // 补全代码\n}\nconsole.log(bubbleSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n```",
        "answer": "&gt;1. 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n&gt;1. 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```javascript\n/**\n * Quick Sort  O(NLogN)\n **/\nfunction quickSort(arr) {\n    const res = [];\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const leftArr = [];\n    const rightArr = [];\n    const q = arr[0];\n    for (let i = 1, l = arr.length; i < l; i++) {\n        if (arr[i] &gt; q) {\n            rightArr.push(arr[i]);\n        } else {\n            leftArr.push(arr[i]);\n        }\n    }\n    return res.concat(quickSort(leftArr), [q], quickSort(rightArr));\n}\n \n/** \n * BubbleSort O(N*N)\n **/\nfunction bubbleSort(arr) {\n    for (let i = 0, l = arr.length; i < l - 1; i++) {\n        for (let j = i + 1; j < l; j++) {\n            if (arr[i] &gt; arr[j]) {\n                let tem = arr[i];\n                arr[i] = arr[j];\n                arr[j] = tem;\n            }\n        }\n    }\n    return arr;\n}\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "岛屿数量",
        "desc": "<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1:</p><p>输入:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>输出: 1</p><p>示例 2:</p><p>输入:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>输出: 3</p><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><p><br></p>",
        "answer": "<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数</p><pre><code>class Solution {\nprivate:\n    void dfs(vector<vector<char&gt;&gt;&amp; grid, int r, int c) {\n        int nr = grid.size();\n        int nc = grid[0].size();\n\n        grid[r][c] = '0';\n        if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == '1') dfs(grid, r - 1, c);\n        if (r + 1 < nr &amp;&amp; grid[r+1][c] == '1') dfs(grid, r + 1, c);\n        if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == '1') dfs(grid, r, c - 1);\n        if (c + 1 < nc &amp;&amp; grid[r][c+1] == '1') dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector<vector<char&gt;&gt;&amp; grid) {\n        int nr = grid.size();\n        if (!nr) return 0;\n        int nc = grid[0].size();\n\n        int num_islands = 0;\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == '1') {\n                    ++num_islands;\n                    dfs(grid, r, c);\n                }\n            }\n        }\n\n        return num_islands;\n    }\n};\n</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把中文数字转成int数字",
        "desc": "<p>在中文页面解析、中文数据处理中，常常遇到用中文表示的数字，例如：五千三百万零五百零一。</p><p>我们一般需要把它转化成int型整数，进行实际存储和使用。 请完成一亿（不含）以内的中文数字到int整数的转换</p>",
        "answer": "<p><br></p><pre><code>// 递归解法\ndef cn2digital(number):\n  name2val = {u'一': 1, u'二': 2, u'三': 3, u'四': 4, u'五': 5,\n    u'六': 6, u'七': 7, u'八': 8, u'九': 9}\n  unit2count = {u'十': 10, u'百': 100, u'千': 1000, u'万': 10000}\n  for unit in [u'万', u'千', u'百', u'十']:\n    if unit in number:\n      n1, n2 = number.split(unit)\n      return cn2digital(n1) * unit2count.get(unit) + cn2digital(n2)\n  if not number:\n    return 0\n  for c in number:\n    if c == u'零':\n      continue\n    return name2val.get(c)\n\n// 非递归解法\ndef cn2digital(number):\n  name2val = {u'一': '1', u'二': '2', u'三': '3', u'四': '4', u'五': '5',\n        u'六': '6', u'七': '7', u'八': '8', u'九': '9'}\n  unit2count = {u'十': 1, u'百': 2, u'千': 3, u'万': 4}\n  res = []\n  base_count = 0 \n  for num in number[::-1]:\n    if num in name2val:\n      res.append(name2val.get(num))\n      continue\n    zero_count = 0\n    if num in unit2count:\n      zero_count = max(0, unit2count.get(num) + base_count - len(res))\n      if num == u'万':\n        base_count += 4\n    for _ in range(zero_count):\n      res.append('0') \n  return 0 if not res else int(''.join(res[::-1]))\n\nassert cn2digital(u'一万零一') == 10001\nassert cn2digital(u'三千五百万') == 35000000\nassert cn2digital(u'三千五百一十万') == 35100000\nassert cn2digital(u'三千五百零一万') == 35010000\nassert cn2digital(u'三千五百零一万零五百') == 35010500\nassert cn2digital(u'三千五百零一万五千五百五十五') == 35015555\nassert cn2digital(u'一百万') == 1000000\nassert cn2digital(u'二百三十四万三千四百九十三') == 2343493</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "Hash表设计",
        "desc": "常规的hash表设计及变通。问题由浅入深递进\n\n1. 基本的原理，负载因子，扩容的原理\n2. 假设内存受限4G，hash表已经占用3G内存，怎么使用剩下的那一个G的内存空间\n3. 怎么在文件中设计类似于hash表的结构，能够在文件中快速查找一个key/value对",
        "answer": "1. 扩容时注意关注 rehash 过程\n2. 类似于多个Hash组成一个List\n3. 类似于leveldb的思路",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "哈希表"
        ]
    },
    {
        "name": "1-n数字字典序第k大",
        "desc": "给你一个数字n(n < 1e9), \n再给你一个数字k(k < n), 要求你找到1, 2, 3, ... n按照字典序排序后, 第k大的数字;\n\n如, n = 15, k = 7;\n\n那1 ~ 15按照字典序排序为: 1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;\n\n则答案为15;",
        "answer": "利用字典树的思想;\n我们假设有这么一棵树, 每个节点都要10个儿子, 10条到儿子的边分别对应数据0~9;\n那么我们在这棵树上, 对边按照0~9的顺序进行DFS, 当走到第k个节点时, 该节点对应的数字既为我们的第k大字典序数字;",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "在数组中找出和值为给定值的两个数",
        "desc": "输入一维数组array和n，找出和值为0的任意两个元素。例如：\n``` python \narray = [2, 3, 1, 10, 4, 30]\nn = 31\n```\n则结果应该输出[1, 30] 顺序不重要\n\n如果有多个满足条件的，返回任意一对即可",
        "answer": "解法1： 本题容易想到用哈希表，迭代一次边建表边查找n - array[i]是否在hash_table中即可。\n\n该方法空间开销比较大\n\n解法2：先对数组做排序，然后首尾两个指针求和，如果小于n则左指针右移，如果大于n则右指针左移。\n\n该方法时间复杂度O(nlogn)\n\n推荐考察解法2，附带做了排序算法的考察",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "老虎吃羊问题",
        "desc": "在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。\n\n假设：\n\nA：每次只有一只老虎可以吃样，而且一旦他吃了羊，他自己就变成羊。\n\nB：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 \n\n问最后这只羊会不会被吃？如果是n只老虎和一只羊呢？",
        "answer": "思路：先simplify。\n- 1只老虎，肯定吃。 \n- 2只老虎肯定不吃，否则就被另一只吃了。 \n- 3只老虎，如果一只老虎吃掉了羊，问题就转换为2只老虎和1只羊的情况，显然另外两种老虎不敢轻举妄动。所以羊会被吃。 \n- 4只老虎，如果某一只老虎吃了羊，问题转化为3只老虎和1只羊的问题，它肯定会被接下来的某一只吃掉，然后其他两只只能等着。所以4只老虎，大家都不敢吃羊。\n\n这样归纳，我们就可以发现如果老虎数目是奇数，那么羊肯定被吃，如果是偶数，那么羊肯定不会被吃。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "爬虫url去重-多线程并发",
        "desc": "用爬虫抓取网页时, 一个较为重要的问题, 就是对爬去的网页去重;\n请你详细的设计一种数据结构, 用来检验某个URL之前是否已经被爬取过;\n并给出每次检验的复杂度, 以及整体的空间复杂度;\n\n一般爬虫在实现时, 都会利用多线程并发的爬取;\n现在需要你升级一下之前的实现, 以保证并发安全;",
        "answer": "通常来说, 不需要改变数据结构本身, 只需要在其外围包裹一些简单的操作, 就能大大提高其并发度;\n比如可以根据URL的后几位, 进行hash分桶;\n注意这里选取URL的后几位, 而不是前几位, 是为了让hash更加均匀, 因为同个域名下的前缀大多是相同的;\n然后每个桶内维护一个上述实现的去重的数据结构;",
        "types": [
            "数据结构与算法",
            "队列"
        ],
        "tags": [
            "多线程",
            "哈希",
            "Hash策略",
            "爬虫"
        ]
    },
    {
        "name": "蓄水问题, 1维",
        "desc": "给定一个一维数组用于描述一个海拔，相邻的海拔高度不同，则下雨后低洼海拔的洼地会有积水，假设雨水足够，能够填满所有低洼地段，计算下雨后所有低洼地段总蓄水量。\n\n例如给定数组为：\n\n5, 2, 1, 4, 3\n\n则：所有低洼地段蓄水为量为 5",
        "answer": "定义左极高点: 该点左边最高的那个点;\n\n定义右极高点: 该点右边最高的那个点;\n\n于是每个点的蓄水高度为: min(左极高点高度, 右极高点高度) - 该点高度，累加每个点的高度即可;所有点的左右极点可以分别通过一次向右和向左的扫描得到;\n\n算法复杂度为 O(n)",
        "types": [
            "数据结构与算法",
            "贪心",
            "队列",
            "堆栈",
            "数组"
        ],
        "tags": [
            "基础"
        ]
    },
    {
        "name": "轮流抛硬币问题",
        "desc": "# A和B玩抛硬币游戏，AB轮流抛一枚硬币，谁先抛到正面谁就获胜并结束游戏，硬币两面均匀。A先抛，请问A获胜的概率是多少？",
        "answer": "将A和B的获胜情况罗列，可以看到规律。A第一次抛获胜概率是1/2, A不获胜情况下B第一次获胜概率1/2*1/2=1/4。\n所以A获胜概率是：1/2+1/8+1/32+...=2/3。B获胜的概率是：1/4+1/16+...=1/3",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "查找第一个缺失的正整数",
        "desc": "查找第一个缺失的正整数。\n时间复杂度O(n) ，空间复杂度 O(1)\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\n",
        "answer": "1 排序之后查找\n\n2 把出现的数值放到与下标一致的位置，再判断什么位置最先出现不连续的数值，就是答案了。\n\n3 和2差不多，把出现过的数值的下标位置做好标识，如果没有出现过的数组的下标就没有标识，那么这个就是答案",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "简单编程题",
            "查找",
            "排序"
        ]
    },
    {
        "name": "微信跳一跳",
        "desc": "<p>从起点开始接下来有 100 个方块，相邻方块间的距离都为 1，每个方块上有增加体力的食用蘑菇或减少体力的毒蘑菇，蘑菇带来的体力改变是已知的。一个人初始体力为 m，每次可以往前跳任意个方块，体力耗尽就会死掉。</p><ol><li>每跳一次消耗的体力与跳的距离成正比，比例为 1。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方，每跳一个方块加 1 分。问这个人能否跳到终点，如果能，求可能得到的最高分数。</li></ol>",
        "answer": "<ul><li>第 1 问，贪心算法，时间复杂度 O(n)</li></ul><pre><code>def flip1(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第一问\n    :param m: 初始体力\n    :param array: 蘑菇带来的体力改变\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    for n in array:\n        m -= 1  # 消耗的体力与跳的距离成正比\n        if m <= 0:  # 体力不足死掉\n            return -1\n        if n &gt; 0:  # 只跳加体力的格子\n            m += n\n    if array[-1] < 0:  # 终点的蘑菇必须吃\n        m += array[-1]\n    return m if m &gt; 0 else -1</code></pre><ul><li>第 2 问，动态规划，时间复杂度 O(n^2)</li></ul><pre><code>def flip2(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第二问\n    :param m:\n    :param array:\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    # powers 表示在每个格子可能剩余的最大体力\n    powers = [m] + [0] * len(array)\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            if powers[j] &gt; (i - j) ** 2:\n                powers[i] = max(powers[i], powers[j] - (i - j) ** 2 + array[i - 1])\n    return powers[-1] if powers[-1] &gt; 0 else -1</code></pre><ul><li>第 3 问，动态规划，时间复杂度 O(n^3)</li></ul><pre><code>def flip3(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第三问\n    :param m:\n    :param array:\n    :return: 可能跳的最多格子数\n    &#34;&#34;&#34;\n    # scores 表示在每个格子得到不同分数时可能剩余的最大体力\n    scores = [{0: m}] + [{} for _ in range(len(array))]\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            for score, power in scores[j].items():\n                left = power - (i - j) ** 2\n                if left &gt; 0 and left + array[i - 1] &gt; 0:\n                    scores[i][score + 1] = max(scores[i].get(score + 1, 0), left + array[i - 1])\n    return max(scores[-1].keys()) if scores[-1].keys() else 0</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "二路归并",
        "desc": "<p>实现一个merge函数，功能是将两个有序数组，将它们合并成一个有序数组，如：</p><pre><code>let arr1 = [1, 2]\nlet arr2 = [-1, 2, 8, 9]\n\nmerge(arr1,arr2) // 返回 [-1, 1, 2, 2, 8, 9]</code></pre><p><br></p>",
        "answer": "<p><br></p><pre><code>function merge(arr1, arr2) {\n  // 可以判断一下arr1、arr2是否是数组\n  if(!(Array.isArray(arr1) &amp;&amp; Array.isArray(arr2))) throw '...'\n\n  let i = 0, j=0, t=0\n  let temp = [];\n  while (i < arr1.length &amp;&amp; j < arr2.length) {\n    temp[t++] = arr1[i] <= arr2[j] ? arr1[i++] : arr2[j++];\n  }\n\n  while (i < arr1.length) {  // 数组1有剩余\n    temp[t++] = arr1[i++];\n  }\n  while (j < arr2.length) {  // 数组2有剩余\n    temp[t++] = arr2[j++];\n  }\n  return temp\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据结构",
            "归并",
            "前端编码",
            "排序"
        ]
    },
    {
        "name": "拆分字符串",
        "desc": "输入一个列表的单词，及一个长字符串，判断字符串可否由列表中的单词组成。比如：\n输入：\n单词列表 dict：I, love, byte, bytedance\n字符串 s：Ilovebytedance\n输出：\nTrue",
        "answer": "1. 用一个数组 validWords[] 记录字符串当前位置之前的字符串是否可以用 dict 组成，validWords[i]=True 可以，否则不可以。默认不可以\n2. for 循环 i 从 0 到 s.length：\n    a. 如果 s[0-i] 在 dict 中，设置 validWords[i]=True\n\t\tb. 如果validWords[i]=True，for 循环 j 从 i+1 到 s.length-1，判断 s[i+1 到 j] 是否在 dict 中，如果是，设置 validWords[j]=True\n3. 如果 validWords[s.length-1] = True, return True\n",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": [
            "校招类",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "给定单链表，求离终点距离为 k 的节点",
        "desc": "给定单链表，求离终点距离为 k 的节点，要求只扫一次且空间复杂度为O(1)",
        "answer": "两个指针, 第一个先向后走k步;\n\n然后两个一起走;\n\n当第一个指针到达链表尾部时另一个指针指向的就是距离终点距离为 k 的节点。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "数组0值筛选",
        "desc": "给定一个非负数组，要求你对它进行操作, \n使得所有的0 放在数组左边， \n大于 0 的值位于数组右边,  \n\n要求空间为O(1), 时间为O(n);",
        "answer": "从右往左扫描，同时维护另一个指针指向出现在最右侧的 0，每次扫描到非 0 数字则和它交换",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针",
            "基础算法"
        ]
    },
    {
        "name": "区间合并",
        "desc": "给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。\n\n例如：[9, 10], [1,4], [3,6], [8, 12]\n\n那么合并后的区间段为：[1, 6], [8, 12]",
        "answer": "由于输入的区间段，不一定按照起点排好序，所以先按照起点坐下排序利于后续合并。\n\n``` python\n    def merge(intervals):\n        res = []\n        intervals = sorted(intervals, key=lambda x:x.start)\n        pre = None\n        for interval in intervals:\n            if not pre:\n                pre = interval\n                continue\n            if interval.start <= pre.end:\n                if interval.end &gt;= pre.end:\n                    pre.end = interval.end\n            else:\n                res.append(pre)\n                pre = interval\n        if pre:\n            res.append(pre)\n        return res\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "爬楼梯问题",
        "desc": "<ul><li>爬楼梯问题：爬楼梯时，每一步会有两个选择：爬一个台阶和爬两个台阶，问：楼梯总台阶数为n，则一共有多少种爬法，写一个函数f，使得：总的爬法= f(n)。举例：n=3时，则共有：（1,1,1)、(1,2) 、(2,1)三种爬法，则f(3)=3。</li></ul><p><br></p>",
        "answer": "<p>斐波拉契：f(n)=f(n-1)+f(n-2) </p><p>代码需要判断边界</p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "数学基础",
            "递归"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找零钱问题",
        "desc": "有1，2，5，10等不同零钱，问给N元，有多少种不同的组合方式？",
        "answer": "假设有m种零钱，具体面值存在arr中，要找的钱为n。\n\n使用m种零钱去找零n元，可以拆分为：\n\n完全不用第m种零钱 和 至少用一次第m种零钱\n\n``` python\ndef zhaolin(arr, n, m):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if m <= 0:\n        return 0\n    return zhaolin(arr, n, m - 1) \\ # 不用第m-1号零钱\n\t\t\t+ zhaolin(arr, n - arr[m - 1], m) # 至少使用1次m-1号零钱\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把二叉树压成单链表",
        "desc": "对于输入的二叉树，舍弃left指针，用right指针按照先根顺序串成单链表。例如：\n``` \n      1\n    2   5\n  3  4\n``` \n转为单链表为1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n要求in-place",
        "answer": "本题利用dfs递归比较好解，关键点是要把左子树的最后一个节点和右子树头接上。\n\n关键代码：\n``` python\ndef flatten(root):\n\tif not root:\n\t\treturn\n\tif root.left:\n\t\tflatten(root.left)\n\tif root.right:\n\t\tflatten(root.right)\n\ttmp = root.right\n\troot.right = root.left\n\troot.left = None\n\twhile root.right:\n\t\troot = root-&gt;right\n\troot.right = tmp\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "最短子数组之和",
        "desc": "给定1个正整数数组array和1个正整数n，从array中寻找和值**大于等于n**的最短子数组。\n\n如果存在，则返回最短子数组长度；如果不存在返回0。\n\n例如：array = [1, 3, 4, 3, 9, 1], n = 12,\n\n那么子数组[3, 9]满足条件且长度最短为2。\n\n",
        "answer": "本题用两个指针的思路解决，时间复杂度O(n)\n\n指针left和right记录子数组的左右边界位置，\n\n让right向右移，直到子数组和&gt;=n或到达数组末尾，更新最短距离，\n\n将left像右移一位，然后在和值中减去移去的值，\n\n重复上面的步骤，直到right到达末尾，且left也无法再右移\n\n``` python\ndef min_sub_len(arrary, n):\n\tres = sys.maxsize\n\tleft, cur_sum = 0, 0\n\tfor i in range(0, len(array)):\n\t\tcur_sum += array[i]\n\t\twhile left <= i &amp;&amp; cur_sum &gt;= n:\n\t\t\tres = min(res, i - left + 1)\n\t\t\tcur_sum -= array[left]\n\t\t\tleft += 1\n\treturn 0 if res == sys.maxsize else res\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针"
        ]
    },
    {
        "name": "二叉树最大宽度",
        "desc": "<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度（每一层的节点可能为空）。</p>",
        "answer": "<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>思路：主要想法是给每个节点一个 position 值，如果我们走向左子树，那么 position -&gt; position * 2，如果我们走向右子树，那么 position -&gt; positon * 2 + 1。当我们在看同一层深度的位置值 L 和 R 的时候，宽度就是 R - L + 1。</p><p><strong>方法 1：深度优先搜索</strong></p><h4><strong>方法 2：宽度优先搜索</strong></h4>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树"
        ]
    },
    {
        "name": "二叉树中序遍历打印节点信息",
        "desc": "实现一个二叉树中序遍历函数，打印所有节点信息。  \ntypedef string DataType;  \ntypedef struct BinTreeNode {  \n    DataType data;  \n    struct BinTreeNode* leftChild;  \n    struct BinTreeNode* rightChild;  \n} BinTreeNode;  \ntypedef BinTreeNode* BinaryTree;  \n  \nvoid MidOrderPrint(BinaryTree tree) {  \n    //打印二叉树节点信息  \n}  \n",
        "answer": "二叉树的遍历按照根节点位置的不同，分为前序遍历、中序遍历、后序遍历。\n前序遍历：根节点-&gt;左子树-&gt;右子树  \n中序遍历：左子树-&gt;根节点-&gt;右子树  \n后序遍历：左子树-&gt;右子树-&gt;根节点  \n例如二叉树结构如下  \n........... a  \n........../.....\\  \n........b........c  \n....../....\\  \n....d........e  \n.....\\ ...../  \n......f....g  \n  \n前序遍历：abdfegc  \n中序遍历：dfbgeac  \n后序遍历：fdgebca  \n  \n  \n解法一：递归方式  \nvoid MidOrderPrint(BinaryTree tree) {  \n    if(NULL == tree) {  \n        return;  \n\t\t}  \n\t\tMidOrderPrint(tree-&gt;leftChild);  \n\t\tprintf(&#34;%s &#34;, tree-&gt;data.c_str());  \n\t\tMidOrderPrint(tree-&gt;rightChild);  \n}  \n|  \n|    \n解法二：非递归方式  \n//假设 Stack 为已经实现的堆栈类型，支持push和pop方法  \nclass Stack {  \n    void push(BinTreeNode *);  \n    BinTreeNode *pop();  \n    BinTreeNode *top();  \n};  \n  \nvoid MidOrderPrint(BinaryTree tree){  \n    if(NULL == tree) {  \n        printf(&#34;this tree is empty!\\n&#34;);  \n        return;  \n    }  \n    Stack s;  \n    BinTreeNode *curNode = tree;  \n    while(curNode != NULL || s.top() != NULL) {  \n        while(curNode != NULL) {  \n            s.push(curNode);  \n            curNode = curNode-&gt;leftChild;  \n        }  \n        curNode = s.pop();  \n        printf(&#34;%s &#34;,curNode-&gt;data);  \n        curNode = curNode -&gt;rightChild;  \n    }  \n}  \n_",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "iOS算法考查"
        ]
    },
    {
        "name": "从日志文件中抽取指定分钟的行",
        "desc": "某个很大（假设有几十T）的日志文件，每行的前两列为日期和时间（时间相等或递增），之后为日志内容，日志内容长度不一。例如：\n\n2015-01-01 00:00:01 this is the first line\n2015-01-01 00:00:03 this is another line\n...\n...\n2017-12-31 12:34:45 this is the last line\n\n需要将这个日志文件的某一分钟（例如2017-10-01 10:02这一分钟）的日志保存到另一个文件中。",
        "answer": "使用二分法寻找位置，seek到文件的该位置读取下一行的内容来判断需要寻找的行。\n本题考察二分查找和对文件操作的了解。需要考虑seek到一行中间的情况。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "二分"
        ]
    },
    {
        "name": "概率问题：赌徒获胜胜率计算",
        "desc": "有两个技巧相当的赌徒 A 和 B（即两人赌博胜率各为0.5），现在设定这样的获胜规则：\n1. A只要赢了2局或以上就获胜\n2. B要赢3局或以上才能获胜。\n问双方胜率各为多少？",
        "answer": "如果直接列举所有情况也是可以得出答案的，但有简单方法可以剪枝。\n\n我们用a表示A取胜，用b表示B取胜。\n\n只要意识到，**无论结果如何，最多4局就可分出胜负**，这样就好计算了。\n\n可以列举所有可能的情形如下： \n\naaaa aaab abba bbab \\\nbaaa baba abab babb \\\nabaa bbaa aabb abbb \\\naaba baab bbba bbbb\n\n也可以计算B获胜的情况 1(bbbb)+ 4(abbb babb bbab bbba)\n\n所以A获胜概率是\\dfrac{11}{16}，B获胜概率是\\dfrac{5}{16}\n",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "旋转链表",
        "desc": "给定单链表，要求返回向右移k位后的新链表，例如：\n\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; NULL\n\nk = 3，则返回：4 -&gt; 5 -&gt; 6 -&gt; 1 -&gt; 2 -&gt;3 -&gt; null",
        "answer": "用一快一慢两个指针fast，slow，快指针提前走k步\n\n然后快慢一起走，直到fast.next == NULL\n\n这是slow-&gt;next即为新head，将fast.next指向head，并从slow处断开\n\n本题要注意参数处理：\n\n空链表\n\nk大于链表长度",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "链表求和",
        "desc": "给定一个链表`L1`、`L2`,每个元素是为10以内的正整数，链表表示一个数字，表头为高位。\n求两个链表之和，以链表形式返回\n如：\n```\nL1\n5 -&gt; 6 -&gt; 2 -&gt; 3 -&gt; 7\nL2\n1 -&gt; 7 -&gt; 0 -&gt; 9 -&gt; 2\n和为：\n56237+17092=73329\n```\n拓展1：\n表头改为低位\n拓展2：\n两表内数字不重复，优化\n拓展3：\n",
        "answer": "```java\n/**\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;      \n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param l1: the first list\n     * @param l2: the second list\n     * @return: the sum list of l1 and l2 \n     */\n    public ListNode addLists(ListNode l1, ListNode l2) {\n        if(l1 == null &amp;&amp; l2 == null) return null;\n        ListNode head = new ListNode(0);\n        ListNode tail = head;\n        int carry = 0;\n        while(l1 != null &amp;&amp; l2 != null){\n            int value = carry + l1.val + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        while(l1 != null){\n            int value = carry + l1.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n        }\n        while(l2 != null){\n            int value = carry + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l2 = l2.next;\n        }\n        if(carry &gt; 0){\n            ListNode node = new ListNode(carry);\n            tail.next = node;\n            tail = tail.next;\n        }\n        return head.next;\n    }\n}\n```\n拓展1 翻转\n拓展2 set/bitmap\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "多叉树最大高度",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>求多叉树的最大高度 getDepth(node)</li></ol>",
        "answer": "<p>节点信息</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>getDepth实现</p><pre><code>function getDepth(node){\n if (!node) return 0\n if (node.children &amp;&amp; node.children.length){\n  let depth=0;\n  for(let e of node.children){\n    depth=Math.max(getDepth(e),depth)\n  }\n  return depth+1\n }else{\n   return 1\n } \n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "前端编码"
        ]
    },
    {
        "name": "单链表对折",
        "desc": "对输入的链表做对折操作\n\n例如：有n个节点的单链表：1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n-2 -&gt; n-1 -&gt; n -&gt; NULL\n\n处理后的链表为1 -&gt; n &gt; 2 -&gt; n-1 -&gt; 3 -&gt; n-2 ...\n\n要求在原链表基础上操作。",
        "answer": "解题思路\n1. 先找到中点，将原链表1分为2，即为l_1, l_2；\n2. 然后翻转l_2;\n3. 最后对l_1和l_2归并。\n\n本题主要考查候选人的编程功底以及好的编程习惯。\n\n比较好的答案应该是4个函数：\n* def fold(head): # 对折入口函数\n* def find_middle(head): # 找中点函数，用一快一慢两指针\n* def reverse(head): # 链表翻转\n* def merger(l1, l2): # 链表合并",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "螺旋打印二维数组",
        "desc": "输入m * n的二维矩阵，要求从(0,0)开始螺旋向内完成打印输出。\n具体打印方法：\n1. ➡️先从左向右打印第一行；\n2. ⤵️再从上向下打印最后一列；\n3. ⬅️然后从右向左打印最后一行；\n4. ⤴️最后从下向上打印第一列。\n\n如此往复，完成所有元素打印。\n\n例如：\n``` python\ninput = [ [ 1,  2,  3,  4,  5],\n          [14, 15, 16, 17,  6],\n          [13, 20, 19, 18,  7],\n          [12, 11, 10,  9,  8],\n        ]\noutput = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n```\n附件要求：不允许再开辟O(mn)的存储，直接打印输出。",
        "answer": "``` python\ndef print_martix(matrix):\n    '''\n    : type martix: list[list]\n    '''\n    if not matrix:\n        return\n    start_row, start_col, end_row, end_col = 0, 0, len(matrix) - 1, len(matrix[0]) - 1\n    while start_row <= end_row and start_col <= end_col:\n        for k in xrange(start_col, end_col + 1):\n            print matrix[start_row][k]\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            print matrix[k][end_col]\n        end_col -= 1\n        if start_row &gt; end_row or start_col &gt; end_col:\n        break\n        for k in xrange(end_col, start_col - 1, -1):\n            print matrix[end_row][k]\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            print matrix[k][start_col]\n        start_col += 1\n```\n测试用例\n``` python\ninput0 = [[]]\ninput1 = [[1]]\ninput2 = [[1, 2]]\ninput3 = [[1], [2]]\n```",
        "types": [
            "数据结构与算法",
            "递归",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "字符串相似度-编辑距离",
        "desc": "百科定义：编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\nsitten （k→s）\n\nsittin （e→i）\n\nsitting （→g）\n",
        "answer": "本题用DP思路来解决，递推关系：\n\n若str1[i] == str2[j]，temp=0，否则temp=1\n\nd[i][j] = min([i-1][j] + 1, d[i][j-1] + 1, d[i - 1, j - 1] + temp)",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "找旋转数组的中位数",
        "desc": "有一个有序数组如：1，2，3，4，5，6，7\n随机选一个点比如5反转变成：5，6，7，1，2，3，4\n对于上面翻转后的数组，求它的中位数。",
        "answer": "1. 最简单的，排序，复杂度最高；\n2. 遍历整个数组，找到最小的数字比如 1，然后 (index+n/2)%n\n3. 二分，找到最小的数字就能找到中位数。淘汰哪一半？\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础算法",
            "查找"
        ]
    },
    {
        "name": "求二叉树的最长路径",
        "desc": "给定一棵二叉树，求其中的最长路径，所谓路径是指：连通两个节点的最小边数。",
        "answer": "使用后序遍历O(n)。遍历过程中计算以当前节点为根的最长路径，返回当前节点的高度。",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "精简文件路径",
        "desc": "对输入的unix风格的文件路径做精简。\n例如：/a/b/.././ 精简为 /a",
        "answer": "为了处理..，容易想到stack解决\n\n``` python \ndef simplify_path(ppath):\n\tsegs = path.split('/')\n\tstack = []\n\tfor seg in segs:\n\t\tif not seg or seg == '.':\n\t\t\tcontinue\n\t\telif seg == '..':\n\t\t\tif len(stack):\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.append(seg)\n\treturn '/' + '/'.join(stack)\n```\n特殊case：/../; ////foo/",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "stack"
        ]
    },
    {
        "name": "绝对众数",
        "desc": "<p>https://leetcode-cn.com/problems/majority-element/</p><p>定义：给定N个数，称出现次数最多的数为众数，若某数出现的次数大于N/2称为绝对众数。如</p><p>A={1, 2, 1, 3, 2}中，1和2都是众数，但都不是绝对众数</p><p>如A={1,2,1,3,1}中，1是绝对众数。</p>",
        "answer": "<p><strong>解题思路</strong>：任意删除2个不相同的数，不改变绝对众数</p><pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int m = nums[0]; // 绝对众数\n        int count = 0; // 计数\n        for(int i = 0; i< nums.length; i++) {\n            if(count == 0) {\n                m = nums[i];\n                count++;\n            }else if(m == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return m;\n    }\n}</code></pre><p><br/></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "环节点的走法数",
        "desc": "一个环上有10个点，编号为0-9，\n\n从0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，\n\n求：经过n步又回到0点有多少种不同的走法？\n\n举例：\n\n如果n = 1，则从0出发只能到1或者9，不可能回到0，共0种走法\n\n如果n = 2，则从0出发有4条路径：0-&gt;1-&gt;2, 0-&gt;1-&gt;0, 0-&gt;9-&gt;8, 0-&gt;9-&gt;0，其中有两条回到了0点，故一共有2中走法",
        "answer": "DP问题，令F(k, i)表示从0点出发经过k步到达i点的走法数，题目所求为F(n, 0)\n\nF(k, i) = F(k - 1,  (i + 1) % 10) + F(k - 1, ((i - 1) + 10) % 10)\n\n初始状态：f[1, 0] = 0, f[1, 1] = 1, f[1, 2] = 0, ... f[1, 9] = 1",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "单词搜索",
        "desc": "<p>给定1个二维字符数组cmap和单词1个word，搜索word是否在map中。</p><p>搜索的定义是从cmap的任意位置开始，可以上下左右移动，依次和word每个字符匹配，如果word能匹配完，则存在，否则不存在。 </p><p>注：cmap中的每个位置只能被访问1次</p><pre><code>a c d z\nx t r o\nf i w o</code></pre><p><br></p><p>例如上面的cmap，则'zoo'能搜索到，'wto'不能搜索到</p>",
        "answer": "<p>比较容易想到用DFS解决，如果候选没思路，可以提示属于哪类问题，如果想到图就好办了。</p><pre><code>def search(cmap, word):\n    if not cmap or not word:\n        return False\n    visited = [[False] * len(cmap[0]) for _ in range(len(cmap))]\n    for i in range(len(cmap)):\n        for j in range(len(cmap[0])):\n            if dfs(cmap, word, 0, i, j, visited):\n                return True\n\ndef dfs(cmap, word, pos, i, j, visited):\n    if pos == len(word):\n        return True\n    if i < 0 or i &gt;= len(cmap) or j < 0 or j &gt; len(cmap[0]) or visited[i][j] or cmap[i][j] != word[pos]:\n        return False\n    find = False\n    visited[i][j] = True\n    for (ii, jj) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if dfs(cmap, word, pos + 1, i + ii, j + jj, visited):\n            find = True\n            break\n    visited[i][j] = False  # 易错点\n    return find</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "寻找数组任一峰值",
        "desc": "峰值定义：比前后元素都大；数组可能存在多个峰值，返回任一个就行\n\n例如：1 2 3 2 1 4 3 可以返回3或者4\n\n可以默认前提：\n\n1 任意元素不等于相邻元素\n\n2 首、尾元素只要比右、左一个元素大即可认为是峰值",
        "answer": "O(n)肯定能解决问题，但本题结合二分能优化时间复杂度\n\n如果a[mid] < a[mid + 1]说明峰值后半段，否则在前半段\n\n核心代码\n``` python\ndef find_peak(a):\n\tleft, right = 0, len(a) - 1\n\twhile left < right:\n\t\tmid = left + (right - left) / 2\n\t\tif a[mid] < a[mid + 1]:\n\t\t\tleft = mid + 1\n\t\telse;\n\t\t\tright = mid\n\t\treturn right",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "对称树判断",
        "desc": "判断一棵二叉树，是否是（左右）对称树：\n对称例子：\n```\nFor example, this binary tree is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n不对称例子：\n```\n   1\n   / \\\n  2   2\n   \\   \\\n   3    3\n``` ",
        "answer": "```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return solve (root.left, root.right);\n    }\n    \n    public boolean solve(TreeNode t1, TreeNode t2) {\n        if (t1 == null &amp;&amp; t2 == null) return true;\n        if (t1 == null &amp;&amp; t2 != null || t1 != null &amp;&amp; t2 == null || t1.val != t2.val) return false;\n        return solve(t1.left, t2.right) &amp;&amp; solve(t1.right, t2.left);\n    }\n}\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "给定链表，将其中的某一部分翻转",
        "desc": "给定链表，将其中的某一部分翻转, 要求空间复杂度为O(1);",
        "answer": "指针a与d指向要翻转部分的第一个节点，指针b指向a的上一个节点；\n\n指针c指向a，并将a指向下一个节点，再将c插入到b的后面，重复执行该操作直到a走出要翻转的区间；\n\n最后将a接在d后面，完成翻转。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "带TTL的N-kv cache",
        "desc": "&#34;实现一个带过期的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则将最老的那一对KV给剔除;\n4. 查询时如果已经过期, 则返回空;\n5. 所有操作复杂度都为O(1)&#34;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "cache"
        ]
    },
    {
        "name": "二叉树的镜像",
        "desc": "实现一个函数，完成输入一个二叉树，输出该二叉树的镜像。\n二叉树结点的定义如下：\n```\nstruct BinaryTreeNode  \n{  \n    int data;  \n    BinaryTreeNode *Left;  \n    BinaryTreeNode *Right;  \n};\n```",
        "answer": "思路：先序遍历树的每个结点，若遍历到的结点有子结点，则交换它的两个子结点。\n有两种实现方法：\n1.递归实现:\n```\nvoid MirroRecursively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n    if(NULL == pNode-&gt;Left &amp;&amp; NULL == pNode-&gt;Right)  \n        return;  \n      \n    BinaryTreeNode *pTemp = pNode-&gt;Left;  \n    pNode-&gt;Left = pNode-&gt;Right;  \n    pNode-&gt;Right = pTemp;  \n      \n    if(pNode-&gt;Left)  \n        MirroRecursively(pNode-&gt;Left);  \n    if(pNode-&gt;Right)  \n        MirroRecursively(pNode-&gt;Right);  \n}  \n```\n2.非递归实现，即使用循环实现:\n```\nvoid MirrorNonRecurively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n  \n    stack stackTreeNode;  \n    stackTreeNode.push(pNode);  \n  \n    while(stackTreeNode.size())  \n    {  \n        BinaryTreeNode *pNode = stackTreeNode.top();  \n        stackTreeNode.pop();  \n  \n        if(NULL != pNode-&gt;Left || NULL != pNode-&gt;Right)  \n        {  \n            BinaryTreeNode *pTemp = pNode-&gt;Left;  \n            pNode-&gt;Left = pNode-&gt;Right;  \n            pNode-&gt;Right = pTemp;  \n        }  \n          \n        if(NULL != pNode-&gt;Left)  \n            stackTreeNode.push(pNode-&gt;Left);  \n  \n        if(NULL != pNode-&gt;Right)  \n            stackTreeNode.push(pNode-&gt;Right);  \n    }  \n} \n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出二叉树左视角能看到的节点",
        "desc": "给定一颗二叉树：\n\n```\n                1\n            2       3\n         4   5    6   7\n                        8\n```\n\n从左边看，输出能看到的 1，2，4，8 这四个节点，顺序无所谓。",
        "answer": "递归或者非递归都可以",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": [
            "校招类",
            "基础算法"
        ]
    },
    {
        "name": "日志提取",
        "desc": "你有一份非常大的日志文件;\n日志的格式为: timestamp: content;\n如 2017-01-01 20:00:00: hello hello hello;\n需要你提取日志中指定时间内的内容;\n如提取2017-01-01 20:00:00 ~ 2017-01-01 22:30:00的日志数据",
        "answer": "由于时间是递增的, 可以先二分到指定时间, 然后再进行读取;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "最多有两个不同字符的最长子串",
        "desc": "给定字符串s，返回最多包含两个不同字符的最长子串长度。\n\n例如：s = 'abbcceefffffg'\n\n最长子串为'eefffff'长度为5",
        "answer": "本题采用两个指针left、right指针指向子串的起始和结束位置。\n\nright不断前行，对left和right内的字符存入dict并计数，当dict的keys()超过2个时，向右移动left。\n\n如此往复，不断更新最长子串长度。\n\n``` python\ndef max_sub_len(s):\n\tmax_len, left = 0, 0\n\tcount = collections.Counter()\n\tfor right in xrange(len(s)):\n\t\tcount[s[right]] += 1\n\t\twhile len(count) &gt; 2:\n\t\t\tcount[s[left]] -= 1\n\t\t\tif count[s[left]] == 0:\n\t\t\t\tcount.pop(s[left])\n\t\t\tleft += 1\n\t\tmax_len = max(max_len, right - left + 1)\n\treturn max_len",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "滑动窗口",
            "字符串"
        ]
    },
    {
        "name": "生成n阶螺旋数组",
        "desc": "本题是http://marvel.byted.org/#/question/detail/?id=816&amp;nocontri=true的反向问题。\n\n``` python\ninput = 1\noutput = [[1]]\n\ninput = 2\noutput = [[1, 2],\n          [4, 3]]\n\t\t\t\t\t\ninput = 3 \noutput = [[ 1, 2, 3],\n          [ 8, 9, 4],\n          [ 7, 6, 5]]\n```",
        "answer": "``` python\ndef gen_matrix(n):\n    if n <= 0:\n        return None\n    matrix = [[0] * n for _ in xrange(n)]\n    val = 1\n    start_row, start_col, end_row, end_col = 0, 0, n - 1, n - 1\n    while val <= n * n:\n        for k in xrange(start_col, end_col + 1):\n            matrix[start_row][k] = val\n            val += 1\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            matrix[k][end_col] = val\n            val += 1\n        end_col -= 1\n        for k in xrange(end_col, start_col - 1, -1):\n            matrix[end_row][k] = val\n            val += 1\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            matrix[k][start_col] = val\n            val += 1\n        start_col += 1\n    return matrix\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "给定长度为n的整形数组，给定小一点的正数k，找到数组中出现次数大于 n/k 的数字",
        "desc": "举几个例子：\n1. 假设 n=100，k=2，那么需要找到数组中出现次数大于 50 的数。\n1. 假设 n=100，k=10，那么需要找到数组中出现次数大于 10 的数。",
        "answer": "1. 方案1：使用hashmap，遍历一次数组，将数组的数字当做key放入hashmap中，并将出现的次数作为value。之后再遍历hashmap将次数大于 n/k 的数打印出来即可\n2. 方案2：假设要求空间复杂度为O(K)，时间复杂度尽量低该怎么做？\n   - 可以给一点提示：换一个思路，每次都从数组中删除K个互不相同的数，那么删除 n/k 次后，还在数组中的数的出现次数，应该至少都大于 n/k \n\t - 最终答案：申请一个K空间的hashmap，按照方案1的思路遍历数组并插入hashmap，每当hashmap有K个值时，就将hashmap里的value减1，如果为0，就从hashmap中删除该key。当数组遍历完，hashmap中剩余的key/value对，就基本是我们要找的数（还需要再次遍历hashmap检查一下次数）",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "平均延迟最大的调用链",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很多也很长，我们需要找出耗时最大的链条进行优化。（假设服务同时调用其依赖的下游服务）</p><p><br></p><p>例如：</p><p>A服务依赖B服务，平均调用延迟100ms，记为(A, B, 100)</p><p>其他依赖和延迟如下：</p><p>(A, C, 200)</p><p>(A, F, 100)</p><p>(B, D, 100)</p><p>(D, E, 50)</p><p>(C, G, 300)</p><p>那么服务A有三条调用链：A-B-D-E，A-C-G，A-F，平均延迟250，500，100</p><p>延迟最大的调用链是A-C-G，延迟为500ms</p><p><br></p><p>输入：</p><p>[(A, B, 100), (A, C, 200), (A, F, 100), (B, D, 100), (D, E, 50), (C, G, 300)]</p><p>输出：</p><p>500</p><p><br></p><p>Follow up：</p><p>1. 能否输出延迟最大的调用链，如果存在多条，都输出</p>",
        "answer": "<p>可以采用搜索的思路解决，例如DFS</p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "最大能连续观看剧集数",
        "desc": "小明常常用BT下载连载电视剧、综艺观看。\n\n因为种子、网络等诸多因素，可能不是所有的剧集都能现在下来，且现在的顺序也不一定按照从第一集到第n集排列。\n\n请问：已知小明已下载的某部电视剧的剧集列表，求小明最多能连续观看多少集？\n\n例如：episodes = [10, 1, 3, 4, 7, 6, 20, 5, 13, 23, 14]\n\n那么小明做多能连续看[3, 4, 5, 6, 7]共5集\n\n希望时间复杂度O(N)",
        "answer": "我们看一般的case寻找连续剧集，其实就看当前剧集i的前一集i-1下载了没，或者后一集i+1下载了没\n\n也就是往前查查、往后查查，为了方便查，我们可以用hash，例如python里的set。\n\n知道这个原理后，我们可以比较容易的写出代码。\n\n``` python\ndef long_episode_count(episodes):\n    remains = set(episodes)\n   \tlong_count = 0\n    for i in episodes:\n        if i not in remains:\n            continue\n        remains.remove(i)\n        while pre in remains:\n            remains.remove(pre)\n            pre -= 1\n        while next in remains:\n            remains.remove(next)\n            next += 1\n        long_count = max(long_count, next - pre - 1)\n   return long_count\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "hash"
        ]
    },
    {
        "name": "根据访问日志统计出头条每日最火的n篇文章",
        "desc": "每日的访问日志记录有文章id，简化起见，访问的文章id存在输入数组中，给定n，要求返回查看次数最多的文章id\n\n例如：visit_log = [ 10001, 1002, 10001, 20032, 302, 302]\n\n如果n = 2，则根据上面的访问日志，不难看出[10001、302]是最火的2篇文章\n",
        "answer": "首先对访问日志的文章id做计数，然后根据计数做排序得到top n。\n\n在排序方法选择方面，top n适合用堆来实现。\n\n``` python\ndef top_article_id(visit_log, n):\n\tarticle_cnt = collections.Counter()\n\tfor article_id in visit_log:\n\t\tarticle_cnt[article_id] += 1\n\theap = article_cnt.keys()\n\t\n\tdef _heap_adjust(heap, parent, heap_size, article_cnt):\n\t\twhile parent < heap_size:\n\t\t\tleft, right = parent * 2 + 1, parent * 2 + 2\n\t\t\tswap_pos = parent\n\t\t\tif left < heap_size and article_cnt[heap[left]] < article_cnt[heap[parent]]:\n\t\t\t\tswap_pos = left\n\t\t\tif right < heap_size and article_cnt[heap[right]] < article_cnt[heap[swap_pos]]:\n\t\t\t\tswap_pos = right\n\t\t\tif swap_pos != parent:\n\t\t\t\theap[parent], heap[swap_pos] = heap[swap_pos], heap[parent]\n\t\t\t\tparent = swap_pos\n\t\t\telse:\n\t\t\t\tbreak\n\n\tfor i in range(int(math.ceil(n / 2) - 1), -1, -1):\n\t\theap_adjust(heap, i, n, article_cnt)\n\tfor i in range(n, len(heap)):\n\t\tif article_cnt[heap[0]] < article_cnt[heap[i]]:\n\t\t\theap[0] = heap[i]\n\t\t\theap_adjust(heap, 0, n, article_cnt)\n\treturn heap[:n]",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "排序",
            "堆",
            "统计"
        ]
    },
    {
        "name": "实现字典树",
        "desc": "字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n它有3个基本性质：根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。\n\n请实现字典树Class，并完成单词插入和查找函数。",
        "answer": "参考实现代码：\n``` python\nclass TrieNode(object):\n    def __init__(self):\n        self.is_leaf = False\n        self.children = [None] * 26\n        \nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        if not word:\n            return\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                cur_node.children[index] = TrieNode()\n            cur_node = cur_node.children[index]\n        cur_node.is_leaf = True\n        \n    def search(self, word):\n        if not word:\n            return False\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                return False\n            cur_node = cur_node.children[index]\n        return cur_node.is_leaf\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "Trie"
        ]
    },
    {
        "name": "36进制正整数加法",
        "desc": "36进制由0-9，a-z，共36个字符表示，最小为'0'\n\n'0'~'9'对应十进制的0~9，'a'~'z'对应十进制的10~35\n\n例如：'1b' 换算成10进制等于 1 * 36^1 + 11 * 36^0 = 36 + 11 = 47\n\n要求按照加法规则计算出任意两个36进制正整数的和\n\n如：按照加法规则，计算'1b' + '2x' = '48'\n\n要求：**不允许把36进制数字整体转为10进制数字，计算出10进制累加结果再转回为36进制**\n\n本题可任意改变进制，如加入大写字母变为62进制。",
        "answer": "``` python\ndef add(num1, num2):\n    '''\n    &gt;&gt;&gt; add('', '')\n    ''\n    &gt;&gt;&gt; add('', '1')\n    '1'\n    &gt;&gt;&gt; add('ab', '')\n    'ab'\n    &gt;&gt;&gt; add('1b', '2x')\n    '49'\n    &gt;&gt;&gt; add('0', '2x')\n    '2x'\n    &gt;&gt;&gt; add('zz', '1')\n    '100'\n    '''\n    def _get_value(num):\n        if ord('0') <= ord(num) <= ord('9'):\n            return ord(num) - ord('0')\n        return ord(num) - ord('a') + 10\n\n    def _to_chr(num):\n        if 0 <= num <= 9:\n            return str(num)\n        return chr(ord('a') + num - 10)\n\n    def _add(n1, n2, carry):\n        result = _get_value(n1) +  _get_value(n2) + carry\n        carry = 1 if result &gt;= 36 else 0\n        result %= 36\n        return _to_chr(result), carry\n\n    len1, len2 = len(num1), len(num2)\n    if len1 &gt; len2: # 取巧：把两个数字长度对齐\n        num2 = '0' * (len1 - len2) + num2\n    elif len2 &gt; len1:\n        num1 = '0' * (len2 - len1) + num1\n    res = []\n    carry = 0\n    for i in xrange(max(len1, len2) - 1, -1, -1):\n        tmp, carry = _add(num1[i], num2[i], carry)\n        res.append(tmp)\n    if carry:  # 易错点：很容易遗漏\n        res.append('1')\n    return ''.join(res[::-1])  # 易错点：需要翻转\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "字符串",
            "编程",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数",
        "desc": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数的位置，从 1 开始计数。例如：\n-2，-1，0，0，0，0，4，5\n最后一个负数出现的位置为：2，第一个正数出现的位置为7。",
        "answer": "1. 二分查找 0 的位置;\n2. 注意边界位置 0 的处理，在二分条件上需要做一些处理，如果只是找到 0 的位置然后遍历找到第一个和最后一个 0 的话， 复杂度为恶化;\n3. 整体复杂度为 O(lg(n));",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "青蛙跳石子",
        "desc": "在长度为m的地面格子上，每个格子里面有一些石子；有一只青蛙, 从格子开始处起跳，每次可以跳3到5个格子，求青蛙跳出格子最少需要踩几个石子；",
        "answer": "简单DP\ndp[i]表示调到第i的位置最少需要踩几个石子;\n于是dp[i]可由dp[i-3], dp[i-4], dp[i-5]得来;",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "给定一个字符串如下，请统计字符串中出现最多的字母和次数",
        "desc": "```javascript\nfunction findMaxDuplicateChar(str) {\n       let maxChar = '', maxValue = 1;\n    // 补全代码.....\n    return {\n        maxChar,\n        maxValue\n    };\n}\nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "answer": "```javascript\nfunction findMaxDuplicateChar(str) {\n    if (str.length === 1) {\n        return str;\n    }\n    const charObj = {};\n    let maxChar = '', maxValue = 1;\n    for(let i = 0; i < str.length; i++) {\n        if (str[i].trim() !== '') {\n            if (!charObj[str.charAt(i)]) {\n                charObj[str.charAt(i)] = 1;\n            } else {\n                charObj[str.charAt(i)] += 1;\n            }\n        }\n    }\n    for (const k in charObj) {\n        if (charObj[k] &gt;= maxValue) {\n            maxChar = k;\n            maxValue = charObj[k];\n        }\n    }\n    return {\n        maxChar,\n        maxValue\n    };\n}\n \nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表",
            "基础算法",
            "统计"
        ]
    },
    {
        "name": "数组排序",
        "desc": "<p>输入数组nums，要求输出升序排序后的结果。已知数组元素为非负整数，且当数组长度为n时，所有元素的值都小于n；</p><p>例：</p><p>[3, 2, 1, 3, 5, 0]  -&gt; [0, 1, 2, 3, 3, 5]</p><p>[0] -&gt; [0]</p>",
        "answer": "<p>O(n2)的排序算法：冒泡排序，插入排序，选择排序 等；</p><p>O(nlog(n))的排序算法：归并排序，快排 等；</p><p>O(N)的排序算法：空间换时间，利用计数实现，需要O(n)空间复杂度；</p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "二叉树转换成双向链表",
        "desc": "转换结果满足下面条件：\n1. 不要新建一个链表空间，要原地做；直接使用 left 和 right 指针\n2. 转换后的双向链表节点顺序要与中序遍历的结果一致\n3. 二叉树最左边的节点作为双向链表的头节点\n\n例如:\n二叉树:\n\n                    1\n            2                3\n        4        5        6        7\n\n双向链表: 4 <-&gt; 2 <-&gt; 5 <-&gt; 1 <-&gt; 6 <-&gt; 3 <-&gt; 7",
        "answer": "二叉树遍历；递归；链表操作\n\n原理上看，对根节点、根的左子树、根的右子树分别作处理：\n1. 比如根节点1， 对于左子树，找到它的最右节点 5， 把 5 和 1 连接起来；\n2. 对于 1 的右子树，找到它的最左节点 6，把 6 和 1 连接起来。\n\n实现上，假设已经把左子树变做双向链表了，让指针一直向右走，就能找到最右节点和根连接；\n右子树同理。\n\n返回结果的时候，找到双向链表的最左节点就可以了。\n\n```\n    private Node convertToDoublyLinkedList(Node root) {\n        if (root.getLeft() != null) {\n            Node left = convertToDoublyLinkedList(root.getLeft());\n            while (left.getRight() != null) {\n                left = left.getRight();\n            }\n            left.setRight(root);\n            root.setLeft(left);\n        }\n         \n        if (root.getRight() != null) {\n            Node right = convertToDoublyLinkedList(root.getRight());\n            while (right.getLeft() != null) {\n                right = right.getLeft();\n            }\n            right.setLeft(root);\n            root.setRight(right);\n        }\n        return root;\n    }\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "双向链表"
        ]
    },
    {
        "name": "翻转单词",
        "desc": "给定一个字符串，逐个翻转字符串中的每个单词。",
        "answer": "根据情况，选择栈和队列即可\n栈必须，队列可选",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "字符串"
        ]
    },
    {
        "name": "两个数的和相加",
        "desc": "<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p>",
        "answer": "<p><br></p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "二叉树所有根到叶子路径组成的数字之和",
        "desc": "二叉树每个节点的value范围是1-9\n\n例如：\n```\n\t\t   1\n\t 2\t\t    3 \n 4\t  5\n```\n从根到叶子共3条：1-&gt;2-&gt;4, 1-&gt;2-&gt;5, 1-&gt;3\n\n构成的数字为124，125，13，求和124 + 125 + 13 = 262即为所求",
        "answer": "``` python\ndef tree_path_sum(root, val):\n\tif not root:\n\t\treturn 0\n\tval = val * 10 + root.val\n\tif not root.left and not root.right:\n\t\treturn val\n\treturn tree_path_sum(root.left, val) + tree_path_sum(root.right, val)\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "三门问题/蒙蒂大厅难题",
        "desc": "你面前有三扇门，每个门后都有一个奖品，其中一个是一辆车，另外两个是山羊。\n你首先挑选一扇门，姑且称之为A，其他两个门分别是B和C。\n在打开你选择的门前，我先从B和C中选择一个没有车的门打开。\n给你一个选择，你是坚持最开始的选择还是换到剩下未打开的门上？\n\n如果我打开门的策略从随机选择，变成总是优先选择门B，只有在迫不得已的时候选择C。\n问结果有变化么？",
        "answer": "使用贝叶斯公式求解，p(a|b)*p(b) = p(a)*p(b|a)\n三种假设，即假设车在门A，门B，门C后面。\nD表示打开了门B但是车不在门后。\n假设A：先验概率=1/3，似然度=1/2，后验概率=(1/3)*(1/2)/(1/2)=1/3\n假设B：先验概率=1/3，似然度=0, 后验概率=0\n假设C：先验概率=1/3，似然度=1，后验概率=2/3\n\n变化之后概率相同。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "贝叶斯",
            "概率"
        ]
    },
    {
        "name": "海盗分金问题",
        "desc": "5个海盗要分100块金币，分配的协议是：按顺序一个一个来，轮到当前的海盗，他提出一个分配方案，如果包括他在内至少有50%的人同意，那么方案通过，否则这个海盗就会被喂鲨鱼，下一个海盗继续提出分配方案。 \n假设海盗都是纯理性而且冷血的，他们的第一原则是生存，第二原则就是拿到尽可能多的金子，第三原则是如果给的金币一样，他们倾向于选择有更少的海盗的分配方案。",
        "answer": "思路： \n5个人太多了，首先把问题简化。从1个人到5个人逐个分析。\n* 1个人，显然自己全拿\n* 2个人。1，2。2号海盗显然可以全部拿走，因为他自己的一票保证了50%。\n* 3个人。1，2，3。首先，如果3号的方案没通过，那么1号将什么都得不到，而2号必定要除3号而后快。因此3号必须征得1号的支持，但又不能完全不给1号任何金币（第三原则）。因此分配方案是1 2 3 = 1 0 99。这样3号的方案能够得到1和3的支持。\n* 4个人。1，2，3，4。首先，如果4号的方案没通过，那么2号将什么都得不到。因此4号只需要分配1 2 3 4 = 0 1 0 99\n* 5个人。1，2，3，4，5。5号清楚的知道一旦他的方案不通过，1和3将什么都得不到，因而他只需要分配1 2 3 4 5 = 1 0 1 0 98，这样即足以保证。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "牛过河",
        "desc": "<p><strong>有一堆牛要过河，河的长度是ｌ，河中间有ｎ个石头，牛只能踩着石头过河，问去掉ｍ个石头后（去掉这ｍ个石头的方式是随机的）的每种情况牛能走的石头间距最小值中，最大的那一个是多少</strong></p>",
        "answer": "<p>二分最大值最小化问题</p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "求二叉树是否存在和值为N的路径",
        "desc": "从二叉树的根到叶子节点称为一条路径\n\n路径上每个节点的value之和为路径和值\n\n本题要求所有的路径中是否存在一条和值为N的。\n\nfollow-up：可以要求返回所有符合条件的路径",
        "answer": "要求自己给出二叉树数类定义\n\n本题很容易用递归解决，基本思路如下：\n\n```\ndef path_exists(root, n):\n\tif not root:\n\t\treturn False\n\tif not root.left and not root.right and root.value == n:\n\t\treturn True\n\treturn path_exists(root.left, n - root.value) or path_exists(root.right, n - root.value)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "special trim",
        "desc": "对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'\n\n例如：\n\n'aacbd' -&gt; 'ad'\n\n'aabcd' -&gt; 'ad'\n\n'aaabbccc' -&gt; ''\n\n不允许使用类似string.replace函数。要求时间、空间复杂度尽量优化",
        "answer": "本题不好处理的是aaabccc，即：c和a相遇就要都去掉。\n\n比较好的思路是用栈的思路解决。\n\n``` python\ndef special_trim(s):\n    if not s:\n        return s\n    res = []\n    for c in s:\n       if c == 'b':\n            continue\n       if c == 'c' and res and res[-1] == 'a':\n            res.pop()\n            continue\n       res.append(c)\n    return ''.join(res)\n```",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "栈",
            "字符串"
        ]
    },
    {
        "name": "约瑟夫问题",
        "desc": "假设有n个人，标号为1-n。\n从第一个人开始计数，到第k个人则出列，随后从第k+1个人重新计数，到第k再出列。\n直至剩下最后一个人。问最后剩下的人的编号？",
        "answer": "考察链表使用。最简单直接的方法是使用循环链表。\n具体思路是：\n1. 构建循环链表，初始化数据；\n2. 每到第k-1个结点，便p-&gt;next = p-&gt;next-&gt;next。\n3. 循环结束条件为p = p-&gt;next，即只有一个结点，该结点所对应的值即为最后剩下的人。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "二叉搜索树中的第K小的元素",
        "desc": "给定二叉搜索树，求所有元素中第k小的。k<=节点总数",
        "answer": "结合BST的性质，用递归很好解决，按照中序遍历即可\n核心代码：\n``` python \ndef find_k_small(root, k):\n\tdef _find(root):\n\t\tif not root:\n\t\t\treturn -1\n\t\tval = _find(root)\n\t\tif not k:\n\t\t\treturn val\n\t\tk -= 1\n\t\tif not k:\n\t\t\treturn root.val\n\t\treturn _find(root)\n\t_find(root)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "序列化和反序列化二叉树",
        "desc": "将一棵二叉树序列化为字符串，并能字符串反序列为一棵树。",
        "answer": "本题解法应该有不少，大体思路是按照某种遍历的顺序记录下每个节点，叶子节点的空指针可以用特殊字符表示\n\n例如用先根遍历解决：\n``` python \n    def serialize(root):\n        def pre_order(node):\n            if node:\n                vals.append(str(node.val))\n                pre_order(node.left)\n                pre_order(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        pre_order(root)\n        return ' '.join(vals)\n\n    def deserialize(data):\n        def pre_order():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = pre_order()\n            node.right = pre_order()\n            return node\n            \n        vals = iter(data.split())\n        return pre_order()",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "带过期和最大对象数限制的LRU-CACHE",
        "desc": "设计一个对象cache, 他支持下列两个基本操作:\nset(id, object), 根据id设置对象;\nget(id): 根据id得到一个对象;\n同时它有下面几个性质:\n1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期;\n2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数;\n3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象;\n请你设计这样一个cache;",
        "answer": "通过组合一些基本的数据结构, \n来实现一些更高级的性质;\n\n内部维护一个链表, list, 其元素为一个三元组(ID, timestamp, obj), 分别为对象ID, 上次被访问时间, 和对象内容;\n在维护该list时, 需要保持一个性质, 越靠后的元素越新, 既timestamp越大;\n内部再维护一个map, 该map表示一个ID到list节点的索引, 格式为map(ID, node);\n对于get(id)操作:\n1: 先在map中查找ID对应的list node;\n2: 将node从list中取出, 即list.Remove(node);\n3: 检查node.timestamp, 如果过期, 则返回null, 表示无数据, 并将ID从map中删除;\n4: 如果未过期, 设置node.timestamp = now(), 并将node添加到list尾部, 即list.Append(node);\n5: 返回node.obj;\n对于set(id, obj)操作:\n1: 同get(id)的1~3步操作, 删除对应的ID;\n2: 如果此时空间满了, 既对象数为n, 则将list中表头的那个元素删除;\n3: 更新list和map: node = new(ID, now(), obj), list.Append(node), map[ID] = node;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "n sum",
        "desc": "<p>输入一维数组array和n，找出和值为sum的n个元素即可，不用找出所有组合。</p><pre><code>array = [2, 3, 1, 10, 4, 30] n = 2, sum = 31\nresult = find(array, n, sum)\n// result = [1, 30]</code></pre><p><br></p>",
        "answer": "<p>基础解法供参考</p><pre><code>function find(arr, n, sum, shouldSort = true) {\n let sorted = arr;\n if (shouldSort) {\n  sorted = arr.sort();\n }\n const length = sorted.length;\n if (n === 2) {\n  let front = 0;\n  let back = length - 1;\n  while(front < back) {\n   const value = sorted[front] + sorted[back];\n   if (value === sum) {\n    return [sorted[front], sorted[back]];\n   } else if (value &gt; sum) {\n    back -= 1;\n   } else {\n    front += 1;\n   }\n  }\n  return null;\n }\n for(let i = 0; i < length; i += 1) {\n  const val = sorted[i];\n  const result = find(sorted.slice([i + 1]), n - 1, sum - val, false);\n  if (!result) {\n   return null;\n  } else {\n   return [val, ...result];\n  }\n }\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表",
            "算法"
        ]
    },
    {
        "name": "多叉树广度优先遍历查找",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>按照广度优先查找符合要求的节点（没有符合要求的节点返回null），比如查找电话号码为 phone的用户信息，调用如下：</li></ol><p><br></p><pre><code>let node = wideTraversal(node,(e)=&gt;e.phone===phone)</code></pre><p><br></p>",
        "answer": "<p>节点定义：</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>实现：</p><pre><code>wideTraversal(node: Node, predict): Node | null {\n  if (!node) return null\n  let queue: Array<Node&gt; = [];\n  queue.push(node)\n  while (queue.length) {\n    let cur = queue.shift()\n    if (!cur) continue\n    if (predict(cur)) return cur\n    if (cur.children&amp;&amp; cur.children.length) {\n      queue.push(...cur.children)\n    }\n  }\n  return null\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "广度优先遍历",
            "前端编码",
            "多叉树"
        ]
    },
    {
        "name": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点",
        "desc": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点，各个相邻顶点间距离为1",
        "answer": "方案：对图进行K步的BFS, 注意处理被重复走过的点;\n",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出所有根节点到叶子节点的路径",
        "desc": "比如:\n\n            1\n          2   3\n         4  5 6  7\n                  8\n\n输出：\n\n    1，2，4\n    1，2，5\n    1，3，6\n    1，3，7，8\n",
        "answer": "二叉树遍历",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找出旋转有序数组中的最小值",
        "desc": "假设原数组为1，2，3，4，5那4，5，1，2，3就是旋转有序的数组\n\n注：数组无重复元素",
        "answer": "暴力可以O(n)，但没用到旋转有序的特征。\n\n本题可以用二分的思想降低时间复杂度\n\n定义左右两个指针left、right指向头尾元素\n\n如果a[left] < a[right]则没有移位，直接输出a[left]即可，反之二分搜索。\n\n如果a[left] &gt; a[mid] 则要搜索右半段，因为a[left]也大于a[right]；反之搜索左半段。\n\n核心代码\n``` python\ndef find_min(arr):\n\tleft, right = 0, len(arr) - 1\n\tif arr[left] < arr[right]:\n\t\treturn arr[left]\n\twhile left != right - 1:\n\t\tmid = left + (right - left) / 2\n\t\tif arr[left] < arr[mid]:\n\t\t\tleft = mid\n\t\telse:\n\t\t\tright = mid\n\t\treturn min(arr[left], arr[right])\n\t\t",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "有序数组"
        ]
    },
    {
        "name": "搜索二维矩阵",
        "desc": "给定二维m * n矩阵matrix，满足一定特性：\n1. 每行从左到右递增\n2. 每列从上到下递增\n给定目标元素num，判断num是否在矩阵中存在\n\n例如：\n``` python \nmatrix = [\n\t[1, 3, 5, 10],\n\t[2, 4, 6, 11],\n\t[7, 9, 12, 20],\n]\n```\nnum = 4存在；num = 13不存在\n",
        "answer": "结合数组定义，观察例子，有两个特殊位置很特殊：左下角和右上角。\n\n左下角的7往上所有的数变小，往右所有的数变大。\n\n那么我们就可以将目标数字num和左下角比较，比目标小就往右搜，比目标大就往上搜。\n\n如此往复可以判断num是否在matrix中。\n\n``` python\ndef search(matrix, num):\n\tif not matrix:\n\t\treturn False\n\trows, cols = len(matrix), len(matrix[0])\n\tif num < matrix[0][0] or num &gt; matrix[rows - 1][cols - 1]:\n\t\treturn False\n\ti, j = rows - 1, 0 # 左下角\n\twhile i &gt;= 0 and j < cols:\n\t\tif matrix[i][j] < num:\n\t\t\tj += 1\n\t\telif matrix[i][j] &gt; num:\n\t\t\ti -= 1\n\t\telse:\n\t\t\treturn True\n\treturn False\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "扑克牌的堆栈、队列操作",
        "desc": "我手中有一堆扑克牌， 但是观众不知道它的顺序。\n\n*  第一步， 我从牌顶拿出一张牌， 放到桌子上。\n*  第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。\n*  第三步， 重复第一步的操作， 直到我手中所有的牌都放到了桌子上。 \n\n最后， 观众可以看到桌子上牌的顺序是：13\\12\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\n请问， 我刚开始拿在手里的牌的顺序是什么？",
        "answer": "解法一：\n这道题候选人容易出现折半的思路， 其实考虑的复杂了。 \n本质是将一个队列和栈做了两个操作\n1. 出队、入栈\n2. 出队、入队（队尾）\n\n因为是看得到结果， 看不到初始顺序， 那么这个操作就是一个逆操作。 \n1. 出栈、入队\n2. 出队（队尾）、入队（队首）\n答案：\n输入：\n1,2,3,4,5,6,7,8,9,10,11,12,13,\n输出：\n1,12,2,8,3,11,4,9,5,13,6,10,7,\n\n代码如下\n``` C++ 再改改\nint doTheWork(std::deque * pQ, std::stack * pS)\n{\n        if(NULL == pQ or NULL == pS)\n                return -1;\n        while(pS-&gt;size() &gt; 0)\n        {\n                int val = pS-&gt;top();\n                pS-&gt;pop();\n                if (pQ-&gt;size() &gt; 0)\n                {\n                        int tmp = pQ-&gt;back();\n                        pQ-&gt;pop_back();\n                        pQ-&gt;push_front(tmp);\n                        pQ-&gt;push_front(val);\n                }\n                else\n                {\n                        pQ-&gt;push_front(val);\n                }\n        }\n        return 0;\n}\n```\n\n解法二：\n对手上牌按照a，b，c...进行编码，直接按顺序操作，输出结果和桌上实际结果对应，即为原手上牌的顺序。",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "用js实现一个binarySearch二分查找",
        "desc": "定一个一个binarySearch的函数，传参能支持四个参数，分别是：\n&gt;1. arr: 一个数组，\n&gt;1. key: 一个需要查找的目标值，\n&gt;1. low: 左边界\n&gt;1. high: 右边界\n&gt;1. 如果能知道则访问素组的位置，否则返回-1\n```javascript\nfunction binarySearch(){\n  // 补全代码\n}\nvar arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\nvar result = binary_search2(arr, 5, 0, 6);\nconsole.log(result);   // 4\n```",
        "answer": "二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：\n&gt;1. 首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n&gt;1. 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n&gt;1. 如果某一步数组为空，则表示找不到目标元素。\n```javascript\n // 递归实现的js代码\n  function binary_search2(arr, key, low, high) {\n    if(low &gt; high) {\n      return -1;\n    }\n    var mid = parseInt((high + low) / 2);\n    if(arr[mid] == key) {\n      return mid;\n    } else if(arr[mid] &gt; key) {\n      high =mid -1;\n      return binary_search2(arr, key, low, high);\n    } else if(arr[mid] < key) {\n      low = mid +1;\n      return binary_search2(arr, key, low, high);\n    }\n  }\n\n  var arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\n  var arrSorted = arr.sort(function (a,b) {\n    return a-b;\n  })\n  var result = binary_search2(arrSorted, 5, 0, 10);\n  console.log(result);   // 4\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": [
            "查找",
            "js"
        ]
    },
    {
        "name": "通配符匹配",
        "desc": "给定字符串s和模式串p，实现函数match(s, p)，判断模式串p是否能完全匹配s\n\n模式串中有两个特殊字符'?'和'*'\n\n'?'匹配任意1个字符；'* '匹配任意r个字符，包括空\n\n例如:\n``` python\nmatch('a', 'a') = True\nmatch('aa', 'a') = False\nmatch('a', '?') = True\nmatch('aa', '*') = True\nmatch('abc', '?*') = True\n```",
        "answer": "本题可以用DP算法来解答。\n\n用dp[i, j]表示串s, p这两个串分别到i和j位置它们是否匹配。那么我们得到递推关系：\n\n如果p[j] != '* ', dp[i, j] = dp[i-1, j-1] and (s[i] == p[j] || p[j] == '?') \n\n如果p[j] == '* ', 那么dp[i][j] = dp[i - 1][j] || dp[i][j - 1]\n\n``` python\ndef match(s, p):\n\tm, n = len(s), len(p)\n\tdp = [[False] * (n + 1) for _ in range(m + 1)]\n\tdp[0][0] = True\n\tfor j in range(1, n + 1):\n\t\tdp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif p[j - 1] in [s[i - 1], '?']:\n\t\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\telif p[j - 1] == '*':\n\t\t\t\tdp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\treturn dp[m][n]\n```\n另外，本题也可以用贪心算法",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": []
    },
    {
        "name": "原子计数问题",
        "desc": "给出一个分子式，比如：\n     HMg2(H2O(N3Ag)2)3N2\n计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：\nmap[string]int {&#34;H&#34;: 7, &#34;Mg&#34;: 2,&#34;Ag&#34;: 6, ...}\n\n分子式的规则：\n1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H\n2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 [2-1000]\n3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N出现 6 次，Ag 出现 2 次\n4. 括号可以嵌套\n\n输入是合法的\n",
        "answer": "1. 最简单的方法是递归，碰到 ( 就开始递归\n2. 担心爆栈就把递归改成非递归\n3. 可以用正则表达式来做，这里不展开了，如果候选人懂的话让他解释",
        "types": [
            "数据结构与算法",
            "递归",
            "堆栈"
        ],
        "tags": [
            "校招类",
            "编程",
            "代码类",
            "基础算法",
            "字符串"
        ]
    },
    {
        "name": "安卓解锁密码数",
        "desc": "安卓系统采用9个点连线构成图案密码。\n\n要求连接以下9个点中**至少4个点**构成一条路径，从而得到1个密码。\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n任意点间均可连线，都有如下附加限制：\n1. 在一个密码路径里每个点只能用1次；\n2. 如果2号点没有被连，则1不能直接连3号点，即：1-&gt;3路径是非法的。类似情况还有1、7；2、8；1、9等等；\n3. 如果2点已经连过了，则1可以连到3，3也可以连到1，即：2-&gt;1-&gt;3路径是合法的。\n4. 1和6是可以直接连线的，因为二者之间没有点。\n\n本问题求所有的密码数，也就是路径数，包含4个点、5个点。。。9个点的所有路径数。",
        "answer": "本题目如果数据结构算法比较熟悉，会很快想到DFS。\n\n难点是路径不能直达问题如何解决？\n\n用visit记录某个点是否已经在路径中\n\n``` python\nvisit = [[0, 0 ,0],\n         [0, 0, 0],\n         [0, 0, 0]]\n```\n\n判断两个点能否连同，等价于判断两个点是否存在中间点问题，如果不存在可以直接连，如果存在要判断中间点是否已经访问过了。\n\n中间点坐标为：|i1 - i2| / 2, |j1 - j2| / 2\n\n另外，本题考虑到对称性会大大降低运算量\n\n1、3、7、9点对称\n\n2、4、6、8点对称",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "矩阵中的最长递增路径",
        "desc": "给定m * n矩阵matrix，可以从任意位置开始，向上、向下、向左、向右移动，但要求下一个位置上的元素要大于当前元素。\n\n找出最长的递增路径长度。",
        "answer": "本题很容易想到dfs，但问题是每个点开始递归搜索，重复计算很多，结合DP提升效率。\n\n用dp[i][j]表示从(i,j)开始的最长递增路径长度，当递归调用时，如果dp[i][j]不为0，直接返回dp[i][j]。\n\n``` python\ndef long_increase_path_len(matrix):\n\tif not matrix:\n\t\treturn 0\n\tres = 1\n\tm, n = len(martix), len(matrix[0])\n\tdp = [[0] * n for _ in range(m)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tres = max(res, dfs(matrix, dp, i, j, m, n))\n\treturn res\n\ndef dfs(matrix, dp, i, j, m, n):\n\tif dp[i][j]:\n\t\treturn dp[i][j]\n\ttmp_max = 1\n\tdirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]:\n\tfor ni, nj in dirs:\n\t\tii, jj = i + ni, j + nj\n\t\tif ii < 0 or ii &gt;= m or jj < 0 or jj &gt;= n or matrix[ii][jj] <= matrix[i][j]:\n\t\t\tcontinue\n\t\ttmp_max = max(tmp_max, 1 + dfs(matrix, dp, ii, jj, m, n)\n\tdp[i][j] = tmp_max\n  return dp[i][j]\n```",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "升序数组求平方数不同的个数",
        "desc": "给定一个升序数组1，元素有重复，对每个元素算一下平方后得到新的数组2，问数组2中不相同的元素共有多少个？给出算法和空间复杂度，要求尽量优化。\n举例：\n数组1 [-13,-10,-9,-6,-5,-1,3,4,6,7,10,11,15,21,42]\n平方后得到\n数组2 [169,100,81,36,25,1,9,16,36,49,100,121,225,441,1764]\n其中不相同的元素个数为13个。",
        "answer": "常规解法，按题目思路，先平方算好，再将结果插入hashset，最后输出hashset大小。\n优化1，平方没必要算，其实就是绝对值。\n优化2，注意到数组2其实是以0分隔的一个降序和一个升序数组。反序遍历降序数组，正序遍历升序数组，即可合并成一个升序数组，合并时做一下排重，最后输出合并后数组的元素个数。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "URL反转",
        "desc": "给定形如 `www.toutiao.com` 的 URL，将其转换成 `com.toutiao.www` 的形式，要求必须原地操作",
        "answer": "1. 原地全部翻转一遍；\n2. 遍历遇到&#34;.&#34;，继续翻转该部分字符串；\n该题目重点考察编码，需要保证代码简洁，要不不允许使用字符串库函数",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "判断单向链表是否有环",
        "desc": "<p>判断一个链表中是否有环</p><p>例如：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D</p><p>D指向B形成环</p><p>要求：在空间复杂度O(1)的情况下，时间复杂度最小</p>",
        "answer": "<p>创建两个指针slow，fast，同时指向这个链表的头节点。</p><p>然后让两个指针开始循环移动</p><p>slow每次向下移动一个节点，fast每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环</p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表",
            "单向链表"
        ]
    },
    {
        "name": "给定两个链表，求它们交叉节点",
        "desc": "1.  已知两个链表, 从某个节点开始就交叉了\n2.  已知这两个链表的头节点, 求出交叉的节点",
        "answer": "1. 依次遍历两个链表分别得到链表的长度M和N\n2. 然后让长的那个一个从头开始走|M-N|的步数;\n3. 两个指针同时走, 直到碰头",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "判断一个IP是否是国内",
        "desc": "如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段",
        "answer": "1. 将ip地址通过位移运算转成int\n2. 对ip地址进行排序(可以考察任意一种排序算法)\n3. 二分查找",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "计算机基础",
            "查找",
            "编程",
            "基础算法"
        ]
    },
    {
        "name": "用户在线峰值",
        "desc": "已知一天内用户登录登出的日志（数据量较大），求这一天用户在线的最大峰值和持续时间段\n- 日志包含字段（userid, login_time, logout_time）\n- 登录登出时间精确到秒\n",
        "answer": "可以将这一天看成0-24*3600的离散的时间点，构造一个dict\n每个用户在login_time对应value+1,logout_time对应value-1\n得到用户在线数量的变化趋势，然后再遍历此dict求和\n难点：\n- 想不到先求变化趋势\n- 峰值时间段可能存在多个\n```\ndef get_max(logs):\n    log_count = {}\n    for log in logs:\n        login_time = log['login_time']\n        logout_time = log['logout_time']\n        log_count[login_time] = log_count.setdefault(login_time, 0) + 1\n        log_count[logout_time] = log_count.setdefault(logout_time, 0) - 1\n    max, current_users, start, end, is_max, timeline = (0, 0, 0, 0, False, [])\n    keys = log_count.keys()\n    keys.sort(lambda a, b: a - b)\n    for time_node in keys:\n        current_users = current_users + log_count[time_node]\n        if current_users &gt; max:\n            max = current_users\n            start = time_node\n            is_max = True\n        elif current_users < max:\n            if is_max:\n                end = time_node\n                is_max = False\n        else:\n            if is_max:\n                end = time_node\n            else:\n                timeline.append((start, end))\n                start = time_node\n                is_max = True\n    timeline.append((start, end))\n    return max, timeline\n```\n\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "股票买卖问题",
        "desc": "给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？日期不重叠的情况下，可以买卖多次呢？\n输入: {100, 80, 120, 130, 70, 60, 100, 125} \n只能买一次：65（60 买进，125 卖出）\n可以买卖多次: 115（80买进，130卖出；60 买进，126卖出）\n\n提示：不用输出买卖的序列，只需要得到最大利润\n\n",
        "answer": "1. 对于只能买一次的情况：\n\n```\n    public static int maximumProfit(int[] stockPrices)\n    {\n        int profit = 0;\n        int minimumPrice = Integer.MAX_VALUE;\n        /* \n         * 对于给定的一天，最大利润等于 - \n         * max(昨天为止的最大利润, 当天的价格 - 之前的最小价格)\n         */\n        for(int i = 0; i < stockPrices.length; i++)\n        {\n            profit = Math.max(profit, stockPrices[i] - minimumPrice);\n            minimumPrice = Math.min(stockPrices[i], minimumPrice);\n        }    \n        return profit;\n    }\n```\n\n2. 对于可以买卖多次的情况，累积递增序列的差就可以了：\n```\n    public static int maximumProfit2(int[] stockPrices) {\n        int totalProfit = 0;\n        for(int i=1; i 0){\n                totalProfit += currentProfit;\n            }\n        }\n        return totalProfit;\n    }\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "编程"
        ]
    },
    {
        "name": "输出给定数字下一个比它大的数字",
        "desc": "比如数字：1234， 输出 1243\n\n比如 1243，则输出 1324",
        "answer": "用 1243 为例：\n1. 从右向左扫描，找到第一个不是升序的数字，比如 2\n2. 在 2 的右边，找到比它大的最小的数，是 3\n3. 交换 2和 3，得到 1342\n4. 把现在 3 右边的所有数字从大到小排序，得到 1324 （如果是排序则是 O(nlogn), 其实逆序就行了）",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "Path Sum",
        "desc": "给定一个二叉树和一个数字n，判断二叉树中是否有一个路径上的数字之和等于给定的数字n\n\n\nFor example:\nGiven the below binary tree and sum = 22,\n\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\nreturn true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.\n",
        "answer": "public class Solution {\n\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        int left = sum - root.val;\n        if(root.left == null &amp;&amp; root.right == null &amp;&amp; left == 0) {\n            return true;\n        }\n        return hasPathSum(root.left, left) || hasPathSum(root.right, left);\n    }\n}\n\n可以进一步问，输出所有和等于给定数字n的path",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "简单编程题"
        ]
    },
    {
        "name": "单链表每隔k个元素做一次反转",
        "desc": "给定一个链表，每隔k个元素做一次反转\n\nExample:\nInputs:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 3 \nOutput:  3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;8-&gt;7-&gt;NULL. \n\nInputs:   1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 5\nOutput:  5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;8-&gt;7-&gt;6-&gt;NULL. \n",
        "answer": "Node* rollback(Node *&amp;head, int k) {\n\tNode *pre = NULL;\n\tNode *next = NULL;\n\tNode *curr = head;\n\tint count = 0;\n\twhile (curr != NULL&amp;&amp;countnext;\n\t\tcurr-&gt;next = pre;\n\t\tpre = curr;\n\t\tcurr = next;\n\t\tcount++;\n\t}\n\tif (curr != NULL) {\n\t\thead-&gt;next = rollback(next, k);\n\t}\n \n\treturn pre;\n}\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "简单编程题",
            "单链表"
        ]
    },
    {
        "name": "用两个栈实现一个队列",
        "desc": "用两个堆栈模拟队列的功能，实现push，pop，count三个方法",
        "answer": "简单的做法：栈s1和s2，始终维护s1作为存储空间，以s2作为临时缓冲区，push直接进s1，pop时s1导入s2，栈顶出栈，导回s1\n优化做法：入队时，将元素压入s1，出队时，判断s2是否为空，如不为空，则直接弹出顶元素；如为空，则将s1的元素逐个“倒入”s2，把最后一个元素弹出并出队",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "赛马求最快N匹",
        "desc": "<p>条件：</p><p>1.64匹马</p><p>2.8个赛道</p><p>3.每次比赛只能知道比赛结果名次，不能知道具体时间</p><p>求：</p><p>用最少的比赛次数，找出最快的4匹</p>",
        "answer": "<p>1.每次比赛至少能淘汰4匹（树形淘汰算法），因此淘汰60匹，至少需要15次比赛，回答15，是最差答案</p><p>2.如果能回答出12次的（经过加速之后的简单排序），为次优解：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2）从第9次开始</p><p>\t\t*1.先取每组第一名，每次比赛，找出最快1匹，取出</p><p>\t\t*2.将最快这匹对应的组里次快的加入比赛，一共4次，找出最快4匹</p><p>3.如果能答出特定情况下10次，最差11次，为最优解（剪枝算法）：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2)  第9次，先取每组第一名，进行比赛，找出前四名</p><p>    3)  第10次，将前4名对应的组中的第2名加入比赛，一共8匹，比赛一次，如果对应的前四名没发生变化，说明前4名就是最快4名</p><p>\t4）第11次</p><p>\t\t*1.假设有一个组里的第2名，进入前四名：</p><p>\t\t\t①有一组的第1名被挤出前4名，该组所有的候选马无法进入前4名</p><p>\t\t\t②另外两组第2名之后无法进入前4名</p><p>\t\t\t因此，4（第2名在第10次进入前4名的组对应的前4名）+2（还在前4名的另外两个第1名）=6匹马进行比赛，决出前4名，即为最终答案</p><p>\t\t*2假设有两个组的第2名，进入前四名：</p><p>\t\t\t①则另外两组都无法进入前4名，而还在前4名的两组的前4名4+4=8，跑一次，最终能得到最快4名</p>",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "LRU cache",
        "desc": "实现一个LRU过期算法的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则按照LRU的规则剔除一个KV;\n4. 查询时如果已经过期, 则返回空;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;\n\n解法大致同上;\n为了实现LRU, 可在每次get后, 将该K从cache中删除并重新插入一遍;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "求数组的最大区间和",
        "desc": "# 输出一个 int 型数组的最大连续子数组（所有元素加和最大）各个元素之和\n# 保证数组中至少有一个正数\n\n例：\n\n输入：{1，2，5，-7，8，-10}\n\n输出：9  (子数组为: {1，2，5，-7，8})",
        "answer": "复杂度 `O(n)` 的算法\n\n```\nint _tmain(int A[], _TCHAR* argv[])\n{\n    int array_length = sizeof(A) / sizeof(A[0]);\n    int sum = 0;\n    int thisSum = 0;\n    for (int i = 0; i < array_length; i++)\n    {\n        thisSum += A[i];\n        if (thisSum &gt; sum)\n        {\n            sum = thisSum;\n        }\n        else if (thisSum < 0)\n        {\n            thisSum = 0;\n        }\n    }\n    printf(&#34;%d&#34;,sum);\n    return 0;\n}\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "最长无重复子串",
        "desc": "<p>无重复子串指：子串中每个字符都不相同 例如：s = 'aaabcdddd' 最长的无重复子串为'abcd'长度为4</p>",
        "answer": "<p>用两个指针left、right指向子串的起止位置 通过set记录是否有重复元素，只要没有重复都可以移动right，更新最长子串长度 如果有重复，移动left，并从set里移除对应的字符</p><pre><code>def max_sub_len(s): \n    existed = set() \n    res = 0 \n    left, right = 0, 0 \n    while right < len(s): \n        if s[right] not in existed: \n            existed.add(s[right]) \n            res = max(res, len(existed)) \n            right += 1\n        else: \n            t.remove(s[left]) \n            left += 1\n    return res </code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "服务循环依赖检测",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很长，如果出现循环依赖将出现非常恶劣的影响。</p><p>对于一个具体应用，已知各个服务的调用关系（即依赖关系），请判断是否存在循环调用。</p><p>输入：</p><p>一组服务依赖关系list，('A', 'B') 表示 A 会调用 B 服务</p><p>service_relations = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('D', 'A')]</p><p>输出：</p><p>由于存在 A - B - D - A 故存在循环依赖，返回True；反之如果不存在，返回False</p><p>Follow up：</p><p>1. 如果有多个环，请都检测出来</p><p>2. 返回每个环中的服务名</p>",
        "answer": "<p>可以采用拓扑排序 或者 DFS思路解决</p>",
        "types": [
            "数据结构与算法",
            "图"
        ],
        "tags": [
            "检测"
        ]
    },
    {
        "name": "比较版本号",
        "desc": "<p>比较两个版本号 version1 和 version2。</p><p>如果 version1 &gt; version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。</p><p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p><p> . 字符不代表小数点，而是用于分隔数字序列。</p><p>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p><p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p><p> </p><p>示例 1:</p><p>输入: version1 = &#34;0.1&#34;, version2 = &#34;1.1&#34;</p><p>输出: -1</p><p>示例 2:</p><p>输入: version1 = &#34;1.0.1&#34;, version2 = &#34;1&#34;</p><p>输出: 1</p><p>示例 3:</p><p>输入: version1 = &#34;7.5.2.4&#34;, version2 = &#34;7.5.3&#34;</p><p>输出: -1</p><p>示例 4：</p><p>输入：version1 = &#34;1.01&#34;, version2 = &#34;1.001&#34;</p><p>输出：0</p><p>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p><p>示例 5：</p><p>输入：version1 = &#34;1.0&#34;, version2 = &#34;1.0.0&#34;</p><p>输出：0</p><p>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>",
        "answer": "<h4><strong>方法1：分割+解析，两次遍历，线性空间</strong></h4><h4><strong>方法2：双指针，一次遍历，常数空间</strong></h4>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "单链表(奇数位升序，偶数位降序)的排序",
        "desc": "单链表，奇数位升序，偶数位降序，现在要求整体排成全局升序\n输入：1-&gt;200-&gt;10-&gt;120-&gt;30-&gt;8-&gt;88-&gt;4\n输出：1-&gt;4-&gt;8-&gt;10-&gt;30-&gt;88-&gt;120-&gt;200",
        "answer": "思路：链表可以随便拆、组合\n先把奇数和偶数拆开，形成两个链表，一个升序和一个降序\n1-&gt;10-&gt;30-&gt;88\n200-&gt;120-&gt;8-&gt;4\n然后将降序的反转，再合并成一个列表\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "蛇形打印二叉树",
        "desc": "输入一棵二叉树，比如：\n```\n              0\n        1            2\n      3     4      5     6\n          7            8   9\n```\n将它蛇形输出，结果如下：\n0，1，2，6，5，4，3，7，8，9",
        "answer": "1. 依赖栈记录每层节点值：层次便利，按偶数层（根是 0 层）从右到左，奇数层从左到右输出，时间空间复杂度都是 O(n)，n 是节点数\n2. 不依赖栈，递归：d 是层数，for i from 0 to d， 如果 i 是偶数，后序遍历二叉树的 0到i层，输出第i层的节点；如果i是奇数，先序遍历 0到 i 层，也只输出第i层节点。空间复杂度是 O(d) 即递归深度，时间复杂度是 o(d^2) 因为 0层节点会被访问 d 次，1 层节点 d-1 次，以此递推。",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "冒泡排序和快速排序的复杂度区别是什么，如何实现？",
        "desc": "```javascript\n/**\n * Quick Sort\n **/\nfunction quickSort(arr) {\n    // 补全代码\n}\nconsole.log(quickSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n\n/** \n * BubbleSort\n **/\n \nfunction bubbleSort(arr) {\n    // 补全代码\n}\nconsole.log(bubbleSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n```",
        "answer": "&gt;1. 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n&gt;1. 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```javascript\n/**\n * Quick Sort  O(NLogN)\n **/\nfunction quickSort(arr) {\n    const res = [];\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const leftArr = [];\n    const rightArr = [];\n    const q = arr[0];\n    for (let i = 1, l = arr.length; i < l; i++) {\n        if (arr[i] &gt; q) {\n            rightArr.push(arr[i]);\n        } else {\n            leftArr.push(arr[i]);\n        }\n    }\n    return res.concat(quickSort(leftArr), [q], quickSort(rightArr));\n}\n \n/** \n * BubbleSort O(N*N)\n **/\nfunction bubbleSort(arr) {\n    for (let i = 0, l = arr.length; i < l - 1; i++) {\n        for (let j = i + 1; j < l; j++) {\n            if (arr[i] &gt; arr[j]) {\n                let tem = arr[i];\n                arr[i] = arr[j];\n                arr[j] = tem;\n            }\n        }\n    }\n    return arr;\n}\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "岛屿数量",
        "desc": "<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1:</p><p>输入:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>输出: 1</p><p>示例 2:</p><p>输入:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>输出: 3</p><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><p><br></p>",
        "answer": "<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数</p><pre><code>class Solution {\nprivate:\n    void dfs(vector<vector<char&gt;&gt;&amp; grid, int r, int c) {\n        int nr = grid.size();\n        int nc = grid[0].size();\n\n        grid[r][c] = '0';\n        if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == '1') dfs(grid, r - 1, c);\n        if (r + 1 < nr &amp;&amp; grid[r+1][c] == '1') dfs(grid, r + 1, c);\n        if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == '1') dfs(grid, r, c - 1);\n        if (c + 1 < nc &amp;&amp; grid[r][c+1] == '1') dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector<vector<char&gt;&gt;&amp; grid) {\n        int nr = grid.size();\n        if (!nr) return 0;\n        int nc = grid[0].size();\n\n        int num_islands = 0;\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == '1') {\n                    ++num_islands;\n                    dfs(grid, r, c);\n                }\n            }\n        }\n\n        return num_islands;\n    }\n};\n</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把中文数字转成int数字",
        "desc": "<p>在中文页面解析、中文数据处理中，常常遇到用中文表示的数字，例如：五千三百万零五百零一。</p><p>我们一般需要把它转化成int型整数，进行实际存储和使用。 请完成一亿（不含）以内的中文数字到int整数的转换</p>",
        "answer": "<p><br></p><pre><code>// 递归解法\ndef cn2digital(number):\n  name2val = {u'一': 1, u'二': 2, u'三': 3, u'四': 4, u'五': 5,\n    u'六': 6, u'七': 7, u'八': 8, u'九': 9}\n  unit2count = {u'十': 10, u'百': 100, u'千': 1000, u'万': 10000}\n  for unit in [u'万', u'千', u'百', u'十']:\n    if unit in number:\n      n1, n2 = number.split(unit)\n      return cn2digital(n1) * unit2count.get(unit) + cn2digital(n2)\n  if not number:\n    return 0\n  for c in number:\n    if c == u'零':\n      continue\n    return name2val.get(c)\n\n// 非递归解法\ndef cn2digital(number):\n  name2val = {u'一': '1', u'二': '2', u'三': '3', u'四': '4', u'五': '5',\n        u'六': '6', u'七': '7', u'八': '8', u'九': '9'}\n  unit2count = {u'十': 1, u'百': 2, u'千': 3, u'万': 4}\n  res = []\n  base_count = 0 \n  for num in number[::-1]:\n    if num in name2val:\n      res.append(name2val.get(num))\n      continue\n    zero_count = 0\n    if num in unit2count:\n      zero_count = max(0, unit2count.get(num) + base_count - len(res))\n      if num == u'万':\n        base_count += 4\n    for _ in range(zero_count):\n      res.append('0') \n  return 0 if not res else int(''.join(res[::-1]))\n\nassert cn2digital(u'一万零一') == 10001\nassert cn2digital(u'三千五百万') == 35000000\nassert cn2digital(u'三千五百一十万') == 35100000\nassert cn2digital(u'三千五百零一万') == 35010000\nassert cn2digital(u'三千五百零一万零五百') == 35010500\nassert cn2digital(u'三千五百零一万五千五百五十五') == 35015555\nassert cn2digital(u'一百万') == 1000000\nassert cn2digital(u'二百三十四万三千四百九十三') == 2343493</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "Hash表设计",
        "desc": "常规的hash表设计及变通。问题由浅入深递进\n\n1. 基本的原理，负载因子，扩容的原理\n2. 假设内存受限4G，hash表已经占用3G内存，怎么使用剩下的那一个G的内存空间\n3. 怎么在文件中设计类似于hash表的结构，能够在文件中快速查找一个key/value对",
        "answer": "1. 扩容时注意关注 rehash 过程\n2. 类似于多个Hash组成一个List\n3. 类似于leveldb的思路",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "哈希表"
        ]
    },
    {
        "name": "1-n数字字典序第k大",
        "desc": "给你一个数字n(n < 1e9), \n再给你一个数字k(k < n), 要求你找到1, 2, 3, ... n按照字典序排序后, 第k大的数字;\n\n如, n = 15, k = 7;\n\n那1 ~ 15按照字典序排序为: 1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;\n\n则答案为15;",
        "answer": "利用字典树的思想;\n我们假设有这么一棵树, 每个节点都要10个儿子, 10条到儿子的边分别对应数据0~9;\n那么我们在这棵树上, 对边按照0~9的顺序进行DFS, 当走到第k个节点时, 该节点对应的数字既为我们的第k大字典序数字;",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "在数组中找出和值为给定值的两个数",
        "desc": "输入一维数组array和n，找出和值为0的任意两个元素。例如：\n``` python \narray = [2, 3, 1, 10, 4, 30]\nn = 31\n```\n则结果应该输出[1, 30] 顺序不重要\n\n如果有多个满足条件的，返回任意一对即可",
        "answer": "解法1： 本题容易想到用哈希表，迭代一次边建表边查找n - array[i]是否在hash_table中即可。\n\n该方法空间开销比较大\n\n解法2：先对数组做排序，然后首尾两个指针求和，如果小于n则左指针右移，如果大于n则右指针左移。\n\n该方法时间复杂度O(nlogn)\n\n推荐考察解法2，附带做了排序算法的考察",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "老虎吃羊问题",
        "desc": "在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。\n\n假设：\n\nA：每次只有一只老虎可以吃样，而且一旦他吃了羊，他自己就变成羊。\n\nB：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 \n\n问最后这只羊会不会被吃？如果是n只老虎和一只羊呢？",
        "answer": "思路：先simplify。\n- 1只老虎，肯定吃。 \n- 2只老虎肯定不吃，否则就被另一只吃了。 \n- 3只老虎，如果一只老虎吃掉了羊，问题就转换为2只老虎和1只羊的情况，显然另外两种老虎不敢轻举妄动。所以羊会被吃。 \n- 4只老虎，如果某一只老虎吃了羊，问题转化为3只老虎和1只羊的问题，它肯定会被接下来的某一只吃掉，然后其他两只只能等着。所以4只老虎，大家都不敢吃羊。\n\n这样归纳，我们就可以发现如果老虎数目是奇数，那么羊肯定被吃，如果是偶数，那么羊肯定不会被吃。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "爬虫url去重-多线程并发",
        "desc": "用爬虫抓取网页时, 一个较为重要的问题, 就是对爬去的网页去重;\n请你详细的设计一种数据结构, 用来检验某个URL之前是否已经被爬取过;\n并给出每次检验的复杂度, 以及整体的空间复杂度;\n\n一般爬虫在实现时, 都会利用多线程并发的爬取;\n现在需要你升级一下之前的实现, 以保证并发安全;",
        "answer": "通常来说, 不需要改变数据结构本身, 只需要在其外围包裹一些简单的操作, 就能大大提高其并发度;\n比如可以根据URL的后几位, 进行hash分桶;\n注意这里选取URL的后几位, 而不是前几位, 是为了让hash更加均匀, 因为同个域名下的前缀大多是相同的;\n然后每个桶内维护一个上述实现的去重的数据结构;",
        "types": [
            "数据结构与算法",
            "队列"
        ],
        "tags": [
            "多线程",
            "哈希",
            "Hash策略",
            "爬虫"
        ]
    },
    {
        "name": "蓄水问题, 1维",
        "desc": "给定一个一维数组用于描述一个海拔，相邻的海拔高度不同，则下雨后低洼海拔的洼地会有积水，假设雨水足够，能够填满所有低洼地段，计算下雨后所有低洼地段总蓄水量。\n\n例如给定数组为：\n\n5, 2, 1, 4, 3\n\n则：所有低洼地段蓄水为量为 5",
        "answer": "定义左极高点: 该点左边最高的那个点;\n\n定义右极高点: 该点右边最高的那个点;\n\n于是每个点的蓄水高度为: min(左极高点高度, 右极高点高度) - 该点高度，累加每个点的高度即可;所有点的左右极点可以分别通过一次向右和向左的扫描得到;\n\n算法复杂度为 O(n)",
        "types": [
            "数据结构与算法",
            "贪心",
            "队列",
            "堆栈",
            "数组"
        ],
        "tags": [
            "基础"
        ]
    },
    {
        "name": "轮流抛硬币问题",
        "desc": "# A和B玩抛硬币游戏，AB轮流抛一枚硬币，谁先抛到正面谁就获胜并结束游戏，硬币两面均匀。A先抛，请问A获胜的概率是多少？",
        "answer": "将A和B的获胜情况罗列，可以看到规律。A第一次抛获胜概率是1/2, A不获胜情况下B第一次获胜概率1/2*1/2=1/4。\n所以A获胜概率是：1/2+1/8+1/32+...=2/3。B获胜的概率是：1/4+1/16+...=1/3",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "查找第一个缺失的正整数",
        "desc": "查找第一个缺失的正整数。\n时间复杂度O(n) ，空间复杂度 O(1)\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\n",
        "answer": "1 排序之后查找\n\n2 把出现的数值放到与下标一致的位置，再判断什么位置最先出现不连续的数值，就是答案了。\n\n3 和2差不多，把出现过的数值的下标位置做好标识，如果没有出现过的数组的下标就没有标识，那么这个就是答案",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "简单编程题",
            "查找",
            "排序"
        ]
    },
    {
        "name": "微信跳一跳",
        "desc": "<p>从起点开始接下来有 100 个方块，相邻方块间的距离都为 1，每个方块上有增加体力的食用蘑菇或减少体力的毒蘑菇，蘑菇带来的体力改变是已知的。一个人初始体力为 m，每次可以往前跳任意个方块，体力耗尽就会死掉。</p><ol><li>每跳一次消耗的体力与跳的距离成正比，比例为 1。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方，每跳一个方块加 1 分。问这个人能否跳到终点，如果能，求可能得到的最高分数。</li></ol>",
        "answer": "<ul><li>第 1 问，贪心算法，时间复杂度 O(n)</li></ul><pre><code>def flip1(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第一问\n    :param m: 初始体力\n    :param array: 蘑菇带来的体力改变\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    for n in array:\n        m -= 1  # 消耗的体力与跳的距离成正比\n        if m <= 0:  # 体力不足死掉\n            return -1\n        if n &gt; 0:  # 只跳加体力的格子\n            m += n\n    if array[-1] < 0:  # 终点的蘑菇必须吃\n        m += array[-1]\n    return m if m &gt; 0 else -1</code></pre><ul><li>第 2 问，动态规划，时间复杂度 O(n^2)</li></ul><pre><code>def flip2(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第二问\n    :param m:\n    :param array:\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    # powers 表示在每个格子可能剩余的最大体力\n    powers = [m] + [0] * len(array)\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            if powers[j] &gt; (i - j) ** 2:\n                powers[i] = max(powers[i], powers[j] - (i - j) ** 2 + array[i - 1])\n    return powers[-1] if powers[-1] &gt; 0 else -1</code></pre><ul><li>第 3 问，动态规划，时间复杂度 O(n^3)</li></ul><pre><code>def flip3(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第三问\n    :param m:\n    :param array:\n    :return: 可能跳的最多格子数\n    &#34;&#34;&#34;\n    # scores 表示在每个格子得到不同分数时可能剩余的最大体力\n    scores = [{0: m}] + [{} for _ in range(len(array))]\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            for score, power in scores[j].items():\n                left = power - (i - j) ** 2\n                if left &gt; 0 and left + array[i - 1] &gt; 0:\n                    scores[i][score + 1] = max(scores[i].get(score + 1, 0), left + array[i - 1])\n    return max(scores[-1].keys()) if scores[-1].keys() else 0</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "二路归并",
        "desc": "<p>实现一个merge函数，功能是将两个有序数组，将它们合并成一个有序数组，如：</p><pre><code>let arr1 = [1, 2]\nlet arr2 = [-1, 2, 8, 9]\n\nmerge(arr1,arr2) // 返回 [-1, 1, 2, 2, 8, 9]</code></pre><p><br></p>",
        "answer": "<p><br></p><pre><code>function merge(arr1, arr2) {\n  // 可以判断一下arr1、arr2是否是数组\n  if(!(Array.isArray(arr1) &amp;&amp; Array.isArray(arr2))) throw '...'\n\n  let i = 0, j=0, t=0\n  let temp = [];\n  while (i < arr1.length &amp;&amp; j < arr2.length) {\n    temp[t++] = arr1[i] <= arr2[j] ? arr1[i++] : arr2[j++];\n  }\n\n  while (i < arr1.length) {  // 数组1有剩余\n    temp[t++] = arr1[i++];\n  }\n  while (j < arr2.length) {  // 数组2有剩余\n    temp[t++] = arr2[j++];\n  }\n  return temp\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据结构",
            "归并",
            "前端编码",
            "排序"
        ]
    },
    {
        "name": "拆分字符串",
        "desc": "输入一个列表的单词，及一个长字符串，判断字符串可否由列表中的单词组成。比如：\n输入：\n单词列表 dict：I, love, byte, bytedance\n字符串 s：Ilovebytedance\n输出：\nTrue",
        "answer": "1. 用一个数组 validWords[] 记录字符串当前位置之前的字符串是否可以用 dict 组成，validWords[i]=True 可以，否则不可以。默认不可以\n2. for 循环 i 从 0 到 s.length：\n    a. 如果 s[0-i] 在 dict 中，设置 validWords[i]=True\n\t\tb. 如果validWords[i]=True，for 循环 j 从 i+1 到 s.length-1，判断 s[i+1 到 j] 是否在 dict 中，如果是，设置 validWords[j]=True\n3. 如果 validWords[s.length-1] = True, return True\n",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": [
            "校招类",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "给定单链表，求离终点距离为 k 的节点",
        "desc": "给定单链表，求离终点距离为 k 的节点，要求只扫一次且空间复杂度为O(1)",
        "answer": "两个指针, 第一个先向后走k步;\n\n然后两个一起走;\n\n当第一个指针到达链表尾部时另一个指针指向的就是距离终点距离为 k 的节点。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "数组0值筛选",
        "desc": "给定一个非负数组，要求你对它进行操作, \n使得所有的0 放在数组左边， \n大于 0 的值位于数组右边,  \n\n要求空间为O(1), 时间为O(n);",
        "answer": "从右往左扫描，同时维护另一个指针指向出现在最右侧的 0，每次扫描到非 0 数字则和它交换",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针",
            "基础算法"
        ]
    },
    {
        "name": "区间合并",
        "desc": "给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。\n\n例如：[9, 10], [1,4], [3,6], [8, 12]\n\n那么合并后的区间段为：[1, 6], [8, 12]",
        "answer": "由于输入的区间段，不一定按照起点排好序，所以先按照起点坐下排序利于后续合并。\n\n``` python\n    def merge(intervals):\n        res = []\n        intervals = sorted(intervals, key=lambda x:x.start)\n        pre = None\n        for interval in intervals:\n            if not pre:\n                pre = interval\n                continue\n            if interval.start <= pre.end:\n                if interval.end &gt;= pre.end:\n                    pre.end = interval.end\n            else:\n                res.append(pre)\n                pre = interval\n        if pre:\n            res.append(pre)\n        return res\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "爬楼梯问题",
        "desc": "<ul><li>爬楼梯问题：爬楼梯时，每一步会有两个选择：爬一个台阶和爬两个台阶，问：楼梯总台阶数为n，则一共有多少种爬法，写一个函数f，使得：总的爬法= f(n)。举例：n=3时，则共有：（1,1,1)、(1,2) 、(2,1)三种爬法，则f(3)=3。</li></ul><p><br></p>",
        "answer": "<p>斐波拉契：f(n)=f(n-1)+f(n-2) </p><p>代码需要判断边界</p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "数学基础",
            "递归"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找零钱问题",
        "desc": "有1，2，5，10等不同零钱，问给N元，有多少种不同的组合方式？",
        "answer": "假设有m种零钱，具体面值存在arr中，要找的钱为n。\n\n使用m种零钱去找零n元，可以拆分为：\n\n完全不用第m种零钱 和 至少用一次第m种零钱\n\n``` python\ndef zhaolin(arr, n, m):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if m <= 0:\n        return 0\n    return zhaolin(arr, n, m - 1) \\ # 不用第m-1号零钱\n\t\t\t+ zhaolin(arr, n - arr[m - 1], m) # 至少使用1次m-1号零钱\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把二叉树压成单链表",
        "desc": "对于输入的二叉树，舍弃left指针，用right指针按照先根顺序串成单链表。例如：\n``` \n      1\n    2   5\n  3  4\n``` \n转为单链表为1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n要求in-place",
        "answer": "本题利用dfs递归比较好解，关键点是要把左子树的最后一个节点和右子树头接上。\n\n关键代码：\n``` python\ndef flatten(root):\n\tif not root:\n\t\treturn\n\tif root.left:\n\t\tflatten(root.left)\n\tif root.right:\n\t\tflatten(root.right)\n\ttmp = root.right\n\troot.right = root.left\n\troot.left = None\n\twhile root.right:\n\t\troot = root-&gt;right\n\troot.right = tmp\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "最短子数组之和",
        "desc": "给定1个正整数数组array和1个正整数n，从array中寻找和值**大于等于n**的最短子数组。\n\n如果存在，则返回最短子数组长度；如果不存在返回0。\n\n例如：array = [1, 3, 4, 3, 9, 1], n = 12,\n\n那么子数组[3, 9]满足条件且长度最短为2。\n\n",
        "answer": "本题用两个指针的思路解决，时间复杂度O(n)\n\n指针left和right记录子数组的左右边界位置，\n\n让right向右移，直到子数组和&gt;=n或到达数组末尾，更新最短距离，\n\n将left像右移一位，然后在和值中减去移去的值，\n\n重复上面的步骤，直到right到达末尾，且left也无法再右移\n\n``` python\ndef min_sub_len(arrary, n):\n\tres = sys.maxsize\n\tleft, cur_sum = 0, 0\n\tfor i in range(0, len(array)):\n\t\tcur_sum += array[i]\n\t\twhile left <= i &amp;&amp; cur_sum &gt;= n:\n\t\t\tres = min(res, i - left + 1)\n\t\t\tcur_sum -= array[left]\n\t\t\tleft += 1\n\treturn 0 if res == sys.maxsize else res\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针"
        ]
    },
    {
        "name": "二叉树最大宽度",
        "desc": "<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度（每一层的节点可能为空）。</p>",
        "answer": "<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>思路：主要想法是给每个节点一个 position 值，如果我们走向左子树，那么 position -&gt; position * 2，如果我们走向右子树，那么 position -&gt; positon * 2 + 1。当我们在看同一层深度的位置值 L 和 R 的时候，宽度就是 R - L + 1。</p><p><strong>方法 1：深度优先搜索</strong></p><h4><strong>方法 2：宽度优先搜索</strong></h4>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树"
        ]
    },
    {
        "name": "二叉树中序遍历打印节点信息",
        "desc": "实现一个二叉树中序遍历函数，打印所有节点信息。  \ntypedef string DataType;  \ntypedef struct BinTreeNode {  \n    DataType data;  \n    struct BinTreeNode* leftChild;  \n    struct BinTreeNode* rightChild;  \n} BinTreeNode;  \ntypedef BinTreeNode* BinaryTree;  \n  \nvoid MidOrderPrint(BinaryTree tree) {  \n    //打印二叉树节点信息  \n}  \n",
        "answer": "二叉树的遍历按照根节点位置的不同，分为前序遍历、中序遍历、后序遍历。\n前序遍历：根节点-&gt;左子树-&gt;右子树  \n中序遍历：左子树-&gt;根节点-&gt;右子树  \n后序遍历：左子树-&gt;右子树-&gt;根节点  \n例如二叉树结构如下  \n........... a  \n........../.....\\  \n........b........c  \n....../....\\  \n....d........e  \n.....\\ ...../  \n......f....g  \n  \n前序遍历：abdfegc  \n中序遍历：dfbgeac  \n后序遍历：fdgebca  \n  \n  \n解法一：递归方式  \nvoid MidOrderPrint(BinaryTree tree) {  \n    if(NULL == tree) {  \n        return;  \n\t\t}  \n\t\tMidOrderPrint(tree-&gt;leftChild);  \n\t\tprintf(&#34;%s &#34;, tree-&gt;data.c_str());  \n\t\tMidOrderPrint(tree-&gt;rightChild);  \n}  \n|  \n|    \n解法二：非递归方式  \n//假设 Stack 为已经实现的堆栈类型，支持push和pop方法  \nclass Stack {  \n    void push(BinTreeNode *);  \n    BinTreeNode *pop();  \n    BinTreeNode *top();  \n};  \n  \nvoid MidOrderPrint(BinaryTree tree){  \n    if(NULL == tree) {  \n        printf(&#34;this tree is empty!\\n&#34;);  \n        return;  \n    }  \n    Stack s;  \n    BinTreeNode *curNode = tree;  \n    while(curNode != NULL || s.top() != NULL) {  \n        while(curNode != NULL) {  \n            s.push(curNode);  \n            curNode = curNode-&gt;leftChild;  \n        }  \n        curNode = s.pop();  \n        printf(&#34;%s &#34;,curNode-&gt;data);  \n        curNode = curNode -&gt;rightChild;  \n    }  \n}  \n_",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "iOS算法考查"
        ]
    },
    {
        "name": "从日志文件中抽取指定分钟的行",
        "desc": "某个很大（假设有几十T）的日志文件，每行的前两列为日期和时间（时间相等或递增），之后为日志内容，日志内容长度不一。例如：\n\n2015-01-01 00:00:01 this is the first line\n2015-01-01 00:00:03 this is another line\n...\n...\n2017-12-31 12:34:45 this is the last line\n\n需要将这个日志文件的某一分钟（例如2017-10-01 10:02这一分钟）的日志保存到另一个文件中。",
        "answer": "使用二分法寻找位置，seek到文件的该位置读取下一行的内容来判断需要寻找的行。\n本题考察二分查找和对文件操作的了解。需要考虑seek到一行中间的情况。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "二分"
        ]
    },
    {
        "name": "概率问题：赌徒获胜胜率计算",
        "desc": "有两个技巧相当的赌徒 A 和 B（即两人赌博胜率各为0.5），现在设定这样的获胜规则：\n1. A只要赢了2局或以上就获胜\n2. B要赢3局或以上才能获胜。\n问双方胜率各为多少？",
        "answer": "如果直接列举所有情况也是可以得出答案的，但有简单方法可以剪枝。\n\n我们用a表示A取胜，用b表示B取胜。\n\n只要意识到，**无论结果如何，最多4局就可分出胜负**，这样就好计算了。\n\n可以列举所有可能的情形如下： \n\naaaa aaab abba bbab \\\nbaaa baba abab babb \\\nabaa bbaa aabb abbb \\\naaba baab bbba bbbb\n\n也可以计算B获胜的情况 1(bbbb)+ 4(abbb babb bbab bbba)\n\n所以A获胜概率是\\dfrac{11}{16}，B获胜概率是\\dfrac{5}{16}\n",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "旋转链表",
        "desc": "给定单链表，要求返回向右移k位后的新链表，例如：\n\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; NULL\n\nk = 3，则返回：4 -&gt; 5 -&gt; 6 -&gt; 1 -&gt; 2 -&gt;3 -&gt; null",
        "answer": "用一快一慢两个指针fast，slow，快指针提前走k步\n\n然后快慢一起走，直到fast.next == NULL\n\n这是slow-&gt;next即为新head，将fast.next指向head，并从slow处断开\n\n本题要注意参数处理：\n\n空链表\n\nk大于链表长度",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "链表求和",
        "desc": "给定一个链表`L1`、`L2`,每个元素是为10以内的正整数，链表表示一个数字，表头为高位。\n求两个链表之和，以链表形式返回\n如：\n```\nL1\n5 -&gt; 6 -&gt; 2 -&gt; 3 -&gt; 7\nL2\n1 -&gt; 7 -&gt; 0 -&gt; 9 -&gt; 2\n和为：\n56237+17092=73329\n```\n拓展1：\n表头改为低位\n拓展2：\n两表内数字不重复，优化\n拓展3：\n",
        "answer": "```java\n/**\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;      \n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param l1: the first list\n     * @param l2: the second list\n     * @return: the sum list of l1 and l2 \n     */\n    public ListNode addLists(ListNode l1, ListNode l2) {\n        if(l1 == null &amp;&amp; l2 == null) return null;\n        ListNode head = new ListNode(0);\n        ListNode tail = head;\n        int carry = 0;\n        while(l1 != null &amp;&amp; l2 != null){\n            int value = carry + l1.val + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        while(l1 != null){\n            int value = carry + l1.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n        }\n        while(l2 != null){\n            int value = carry + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l2 = l2.next;\n        }\n        if(carry &gt; 0){\n            ListNode node = new ListNode(carry);\n            tail.next = node;\n            tail = tail.next;\n        }\n        return head.next;\n    }\n}\n```\n拓展1 翻转\n拓展2 set/bitmap\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "多叉树最大高度",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>求多叉树的最大高度 getDepth(node)</li></ol>",
        "answer": "<p>节点信息</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>getDepth实现</p><pre><code>function getDepth(node){\n if (!node) return 0\n if (node.children &amp;&amp; node.children.length){\n  let depth=0;\n  for(let e of node.children){\n    depth=Math.max(getDepth(e),depth)\n  }\n  return depth+1\n }else{\n   return 1\n } \n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "前端编码"
        ]
    },
    {
        "name": "单链表对折",
        "desc": "对输入的链表做对折操作\n\n例如：有n个节点的单链表：1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n-2 -&gt; n-1 -&gt; n -&gt; NULL\n\n处理后的链表为1 -&gt; n &gt; 2 -&gt; n-1 -&gt; 3 -&gt; n-2 ...\n\n要求在原链表基础上操作。",
        "answer": "解题思路\n1. 先找到中点，将原链表1分为2，即为l_1, l_2；\n2. 然后翻转l_2;\n3. 最后对l_1和l_2归并。\n\n本题主要考查候选人的编程功底以及好的编程习惯。\n\n比较好的答案应该是4个函数：\n* def fold(head): # 对折入口函数\n* def find_middle(head): # 找中点函数，用一快一慢两指针\n* def reverse(head): # 链表翻转\n* def merger(l1, l2): # 链表合并",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "螺旋打印二维数组",
        "desc": "输入m * n的二维矩阵，要求从(0,0)开始螺旋向内完成打印输出。\n具体打印方法：\n1. ➡️先从左向右打印第一行；\n2. ⤵️再从上向下打印最后一列；\n3. ⬅️然后从右向左打印最后一行；\n4. ⤴️最后从下向上打印第一列。\n\n如此往复，完成所有元素打印。\n\n例如：\n``` python\ninput = [ [ 1,  2,  3,  4,  5],\n          [14, 15, 16, 17,  6],\n          [13, 20, 19, 18,  7],\n          [12, 11, 10,  9,  8],\n        ]\noutput = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n```\n附件要求：不允许再开辟O(mn)的存储，直接打印输出。",
        "answer": "``` python\ndef print_martix(matrix):\n    '''\n    : type martix: list[list]\n    '''\n    if not matrix:\n        return\n    start_row, start_col, end_row, end_col = 0, 0, len(matrix) - 1, len(matrix[0]) - 1\n    while start_row <= end_row and start_col <= end_col:\n        for k in xrange(start_col, end_col + 1):\n            print matrix[start_row][k]\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            print matrix[k][end_col]\n        end_col -= 1\n        if start_row &gt; end_row or start_col &gt; end_col:\n        break\n        for k in xrange(end_col, start_col - 1, -1):\n            print matrix[end_row][k]\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            print matrix[k][start_col]\n        start_col += 1\n```\n测试用例\n``` python\ninput0 = [[]]\ninput1 = [[1]]\ninput2 = [[1, 2]]\ninput3 = [[1], [2]]\n```",
        "types": [
            "数据结构与算法",
            "递归",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "字符串相似度-编辑距离",
        "desc": "百科定义：编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\nsitten （k→s）\n\nsittin （e→i）\n\nsitting （→g）\n",
        "answer": "本题用DP思路来解决，递推关系：\n\n若str1[i] == str2[j]，temp=0，否则temp=1\n\nd[i][j] = min([i-1][j] + 1, d[i][j-1] + 1, d[i - 1, j - 1] + temp)",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "找旋转数组的中位数",
        "desc": "有一个有序数组如：1，2，3，4，5，6，7\n随机选一个点比如5反转变成：5，6，7，1，2，3，4\n对于上面翻转后的数组，求它的中位数。",
        "answer": "1. 最简单的，排序，复杂度最高；\n2. 遍历整个数组，找到最小的数字比如 1，然后 (index+n/2)%n\n3. 二分，找到最小的数字就能找到中位数。淘汰哪一半？\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础算法",
            "查找"
        ]
    },
    {
        "name": "求二叉树的最长路径",
        "desc": "给定一棵二叉树，求其中的最长路径，所谓路径是指：连通两个节点的最小边数。",
        "answer": "使用后序遍历O(n)。遍历过程中计算以当前节点为根的最长路径，返回当前节点的高度。",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "精简文件路径",
        "desc": "对输入的unix风格的文件路径做精简。\n例如：/a/b/.././ 精简为 /a",
        "answer": "为了处理..，容易想到stack解决\n\n``` python \ndef simplify_path(ppath):\n\tsegs = path.split('/')\n\tstack = []\n\tfor seg in segs:\n\t\tif not seg or seg == '.':\n\t\t\tcontinue\n\t\telif seg == '..':\n\t\t\tif len(stack):\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.append(seg)\n\treturn '/' + '/'.join(stack)\n```\n特殊case：/../; ////foo/",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "stack"
        ]
    },
    {
        "name": "绝对众数",
        "desc": "<p>https://leetcode-cn.com/problems/majority-element/</p><p>定义：给定N个数，称出现次数最多的数为众数，若某数出现的次数大于N/2称为绝对众数。如</p><p>A={1, 2, 1, 3, 2}中，1和2都是众数，但都不是绝对众数</p><p>如A={1,2,1,3,1}中，1是绝对众数。</p>",
        "answer": "<p><strong>解题思路</strong>：任意删除2个不相同的数，不改变绝对众数</p><pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int m = nums[0]; // 绝对众数\n        int count = 0; // 计数\n        for(int i = 0; i< nums.length; i++) {\n            if(count == 0) {\n                m = nums[i];\n                count++;\n            }else if(m == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return m;\n    }\n}</code></pre><p><br/></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "环节点的走法数",
        "desc": "一个环上有10个点，编号为0-9，\n\n从0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，\n\n求：经过n步又回到0点有多少种不同的走法？\n\n举例：\n\n如果n = 1，则从0出发只能到1或者9，不可能回到0，共0种走法\n\n如果n = 2，则从0出发有4条路径：0-&gt;1-&gt;2, 0-&gt;1-&gt;0, 0-&gt;9-&gt;8, 0-&gt;9-&gt;0，其中有两条回到了0点，故一共有2中走法",
        "answer": "DP问题，令F(k, i)表示从0点出发经过k步到达i点的走法数，题目所求为F(n, 0)\n\nF(k, i) = F(k - 1,  (i + 1) % 10) + F(k - 1, ((i - 1) + 10) % 10)\n\n初始状态：f[1, 0] = 0, f[1, 1] = 1, f[1, 2] = 0, ... f[1, 9] = 1",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "单词搜索",
        "desc": "<p>给定1个二维字符数组cmap和单词1个word，搜索word是否在map中。</p><p>搜索的定义是从cmap的任意位置开始，可以上下左右移动，依次和word每个字符匹配，如果word能匹配完，则存在，否则不存在。 </p><p>注：cmap中的每个位置只能被访问1次</p><pre><code>a c d z\nx t r o\nf i w o</code></pre><p><br></p><p>例如上面的cmap，则'zoo'能搜索到，'wto'不能搜索到</p>",
        "answer": "<p>比较容易想到用DFS解决，如果候选没思路，可以提示属于哪类问题，如果想到图就好办了。</p><pre><code>def search(cmap, word):\n    if not cmap or not word:\n        return False\n    visited = [[False] * len(cmap[0]) for _ in range(len(cmap))]\n    for i in range(len(cmap)):\n        for j in range(len(cmap[0])):\n            if dfs(cmap, word, 0, i, j, visited):\n                return True\n\ndef dfs(cmap, word, pos, i, j, visited):\n    if pos == len(word):\n        return True\n    if i < 0 or i &gt;= len(cmap) or j < 0 or j &gt; len(cmap[0]) or visited[i][j] or cmap[i][j] != word[pos]:\n        return False\n    find = False\n    visited[i][j] = True\n    for (ii, jj) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if dfs(cmap, word, pos + 1, i + ii, j + jj, visited):\n            find = True\n            break\n    visited[i][j] = False  # 易错点\n    return find</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "寻找数组任一峰值",
        "desc": "峰值定义：比前后元素都大；数组可能存在多个峰值，返回任一个就行\n\n例如：1 2 3 2 1 4 3 可以返回3或者4\n\n可以默认前提：\n\n1 任意元素不等于相邻元素\n\n2 首、尾元素只要比右、左一个元素大即可认为是峰值",
        "answer": "O(n)肯定能解决问题，但本题结合二分能优化时间复杂度\n\n如果a[mid] < a[mid + 1]说明峰值后半段，否则在前半段\n\n核心代码\n``` python\ndef find_peak(a):\n\tleft, right = 0, len(a) - 1\n\twhile left < right:\n\t\tmid = left + (right - left) / 2\n\t\tif a[mid] < a[mid + 1]:\n\t\t\tleft = mid + 1\n\t\telse;\n\t\t\tright = mid\n\t\treturn right",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "对称树判断",
        "desc": "判断一棵二叉树，是否是（左右）对称树：\n对称例子：\n```\nFor example, this binary tree is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n不对称例子：\n```\n   1\n   / \\\n  2   2\n   \\   \\\n   3    3\n``` ",
        "answer": "```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return solve (root.left, root.right);\n    }\n    \n    public boolean solve(TreeNode t1, TreeNode t2) {\n        if (t1 == null &amp;&amp; t2 == null) return true;\n        if (t1 == null &amp;&amp; t2 != null || t1 != null &amp;&amp; t2 == null || t1.val != t2.val) return false;\n        return solve(t1.left, t2.right) &amp;&amp; solve(t1.right, t2.left);\n    }\n}\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "给定链表，将其中的某一部分翻转",
        "desc": "给定链表，将其中的某一部分翻转, 要求空间复杂度为O(1);",
        "answer": "指针a与d指向要翻转部分的第一个节点，指针b指向a的上一个节点；\n\n指针c指向a，并将a指向下一个节点，再将c插入到b的后面，重复执行该操作直到a走出要翻转的区间；\n\n最后将a接在d后面，完成翻转。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "带TTL的N-kv cache",
        "desc": "&#34;实现一个带过期的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则将最老的那一对KV给剔除;\n4. 查询时如果已经过期, 则返回空;\n5. 所有操作复杂度都为O(1)&#34;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "cache"
        ]
    },
    {
        "name": "二叉树的镜像",
        "desc": "实现一个函数，完成输入一个二叉树，输出该二叉树的镜像。\n二叉树结点的定义如下：\n```\nstruct BinaryTreeNode  \n{  \n    int data;  \n    BinaryTreeNode *Left;  \n    BinaryTreeNode *Right;  \n};\n```",
        "answer": "思路：先序遍历树的每个结点，若遍历到的结点有子结点，则交换它的两个子结点。\n有两种实现方法：\n1.递归实现:\n```\nvoid MirroRecursively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n    if(NULL == pNode-&gt;Left &amp;&amp; NULL == pNode-&gt;Right)  \n        return;  \n      \n    BinaryTreeNode *pTemp = pNode-&gt;Left;  \n    pNode-&gt;Left = pNode-&gt;Right;  \n    pNode-&gt;Right = pTemp;  \n      \n    if(pNode-&gt;Left)  \n        MirroRecursively(pNode-&gt;Left);  \n    if(pNode-&gt;Right)  \n        MirroRecursively(pNode-&gt;Right);  \n}  \n```\n2.非递归实现，即使用循环实现:\n```\nvoid MirrorNonRecurively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n  \n    stack stackTreeNode;  \n    stackTreeNode.push(pNode);  \n  \n    while(stackTreeNode.size())  \n    {  \n        BinaryTreeNode *pNode = stackTreeNode.top();  \n        stackTreeNode.pop();  \n  \n        if(NULL != pNode-&gt;Left || NULL != pNode-&gt;Right)  \n        {  \n            BinaryTreeNode *pTemp = pNode-&gt;Left;  \n            pNode-&gt;Left = pNode-&gt;Right;  \n            pNode-&gt;Right = pTemp;  \n        }  \n          \n        if(NULL != pNode-&gt;Left)  \n            stackTreeNode.push(pNode-&gt;Left);  \n  \n        if(NULL != pNode-&gt;Right)  \n            stackTreeNode.push(pNode-&gt;Right);  \n    }  \n} \n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出二叉树左视角能看到的节点",
        "desc": "给定一颗二叉树：\n\n```\n                1\n            2       3\n         4   5    6   7\n                        8\n```\n\n从左边看，输出能看到的 1，2，4，8 这四个节点，顺序无所谓。",
        "answer": "递归或者非递归都可以",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": [
            "校招类",
            "基础算法"
        ]
    },
    {
        "name": "日志提取",
        "desc": "你有一份非常大的日志文件;\n日志的格式为: timestamp: content;\n如 2017-01-01 20:00:00: hello hello hello;\n需要你提取日志中指定时间内的内容;\n如提取2017-01-01 20:00:00 ~ 2017-01-01 22:30:00的日志数据",
        "answer": "由于时间是递增的, 可以先二分到指定时间, 然后再进行读取;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "最多有两个不同字符的最长子串",
        "desc": "给定字符串s，返回最多包含两个不同字符的最长子串长度。\n\n例如：s = 'abbcceefffffg'\n\n最长子串为'eefffff'长度为5",
        "answer": "本题采用两个指针left、right指针指向子串的起始和结束位置。\n\nright不断前行，对left和right内的字符存入dict并计数，当dict的keys()超过2个时，向右移动left。\n\n如此往复，不断更新最长子串长度。\n\n``` python\ndef max_sub_len(s):\n\tmax_len, left = 0, 0\n\tcount = collections.Counter()\n\tfor right in xrange(len(s)):\n\t\tcount[s[right]] += 1\n\t\twhile len(count) &gt; 2:\n\t\t\tcount[s[left]] -= 1\n\t\t\tif count[s[left]] == 0:\n\t\t\t\tcount.pop(s[left])\n\t\t\tleft += 1\n\t\tmax_len = max(max_len, right - left + 1)\n\treturn max_len",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "滑动窗口",
            "字符串"
        ]
    },
    {
        "name": "生成n阶螺旋数组",
        "desc": "本题是http://marvel.byted.org/#/question/detail/?id=816&amp;nocontri=true的反向问题。\n\n``` python\ninput = 1\noutput = [[1]]\n\ninput = 2\noutput = [[1, 2],\n          [4, 3]]\n\t\t\t\t\t\ninput = 3 \noutput = [[ 1, 2, 3],\n          [ 8, 9, 4],\n          [ 7, 6, 5]]\n```",
        "answer": "``` python\ndef gen_matrix(n):\n    if n <= 0:\n        return None\n    matrix = [[0] * n for _ in xrange(n)]\n    val = 1\n    start_row, start_col, end_row, end_col = 0, 0, n - 1, n - 1\n    while val <= n * n:\n        for k in xrange(start_col, end_col + 1):\n            matrix[start_row][k] = val\n            val += 1\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            matrix[k][end_col] = val\n            val += 1\n        end_col -= 1\n        for k in xrange(end_col, start_col - 1, -1):\n            matrix[end_row][k] = val\n            val += 1\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            matrix[k][start_col] = val\n            val += 1\n        start_col += 1\n    return matrix\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "给定长度为n的整形数组，给定小一点的正数k，找到数组中出现次数大于 n/k 的数字",
        "desc": "举几个例子：\n1. 假设 n=100，k=2，那么需要找到数组中出现次数大于 50 的数。\n1. 假设 n=100，k=10，那么需要找到数组中出现次数大于 10 的数。",
        "answer": "1. 方案1：使用hashmap，遍历一次数组，将数组的数字当做key放入hashmap中，并将出现的次数作为value。之后再遍历hashmap将次数大于 n/k 的数打印出来即可\n2. 方案2：假设要求空间复杂度为O(K)，时间复杂度尽量低该怎么做？\n   - 可以给一点提示：换一个思路，每次都从数组中删除K个互不相同的数，那么删除 n/k 次后，还在数组中的数的出现次数，应该至少都大于 n/k \n\t - 最终答案：申请一个K空间的hashmap，按照方案1的思路遍历数组并插入hashmap，每当hashmap有K个值时，就将hashmap里的value减1，如果为0，就从hashmap中删除该key。当数组遍历完，hashmap中剩余的key/value对，就基本是我们要找的数（还需要再次遍历hashmap检查一下次数）",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "平均延迟最大的调用链",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很多也很长，我们需要找出耗时最大的链条进行优化。（假设服务同时调用其依赖的下游服务）</p><p><br></p><p>例如：</p><p>A服务依赖B服务，平均调用延迟100ms，记为(A, B, 100)</p><p>其他依赖和延迟如下：</p><p>(A, C, 200)</p><p>(A, F, 100)</p><p>(B, D, 100)</p><p>(D, E, 50)</p><p>(C, G, 300)</p><p>那么服务A有三条调用链：A-B-D-E，A-C-G，A-F，平均延迟250，500，100</p><p>延迟最大的调用链是A-C-G，延迟为500ms</p><p><br></p><p>输入：</p><p>[(A, B, 100), (A, C, 200), (A, F, 100), (B, D, 100), (D, E, 50), (C, G, 300)]</p><p>输出：</p><p>500</p><p><br></p><p>Follow up：</p><p>1. 能否输出延迟最大的调用链，如果存在多条，都输出</p>",
        "answer": "<p>可以采用搜索的思路解决，例如DFS</p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "最大能连续观看剧集数",
        "desc": "小明常常用BT下载连载电视剧、综艺观看。\n\n因为种子、网络等诸多因素，可能不是所有的剧集都能现在下来，且现在的顺序也不一定按照从第一集到第n集排列。\n\n请问：已知小明已下载的某部电视剧的剧集列表，求小明最多能连续观看多少集？\n\n例如：episodes = [10, 1, 3, 4, 7, 6, 20, 5, 13, 23, 14]\n\n那么小明做多能连续看[3, 4, 5, 6, 7]共5集\n\n希望时间复杂度O(N)",
        "answer": "我们看一般的case寻找连续剧集，其实就看当前剧集i的前一集i-1下载了没，或者后一集i+1下载了没\n\n也就是往前查查、往后查查，为了方便查，我们可以用hash，例如python里的set。\n\n知道这个原理后，我们可以比较容易的写出代码。\n\n``` python\ndef long_episode_count(episodes):\n    remains = set(episodes)\n   \tlong_count = 0\n    for i in episodes:\n        if i not in remains:\n            continue\n        remains.remove(i)\n        while pre in remains:\n            remains.remove(pre)\n            pre -= 1\n        while next in remains:\n            remains.remove(next)\n            next += 1\n        long_count = max(long_count, next - pre - 1)\n   return long_count\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "hash"
        ]
    },
    {
        "name": "根据访问日志统计出头条每日最火的n篇文章",
        "desc": "每日的访问日志记录有文章id，简化起见，访问的文章id存在输入数组中，给定n，要求返回查看次数最多的文章id\n\n例如：visit_log = [ 10001, 1002, 10001, 20032, 302, 302]\n\n如果n = 2，则根据上面的访问日志，不难看出[10001、302]是最火的2篇文章\n",
        "answer": "首先对访问日志的文章id做计数，然后根据计数做排序得到top n。\n\n在排序方法选择方面，top n适合用堆来实现。\n\n``` python\ndef top_article_id(visit_log, n):\n\tarticle_cnt = collections.Counter()\n\tfor article_id in visit_log:\n\t\tarticle_cnt[article_id] += 1\n\theap = article_cnt.keys()\n\t\n\tdef _heap_adjust(heap, parent, heap_size, article_cnt):\n\t\twhile parent < heap_size:\n\t\t\tleft, right = parent * 2 + 1, parent * 2 + 2\n\t\t\tswap_pos = parent\n\t\t\tif left < heap_size and article_cnt[heap[left]] < article_cnt[heap[parent]]:\n\t\t\t\tswap_pos = left\n\t\t\tif right < heap_size and article_cnt[heap[right]] < article_cnt[heap[swap_pos]]:\n\t\t\t\tswap_pos = right\n\t\t\tif swap_pos != parent:\n\t\t\t\theap[parent], heap[swap_pos] = heap[swap_pos], heap[parent]\n\t\t\t\tparent = swap_pos\n\t\t\telse:\n\t\t\t\tbreak\n\n\tfor i in range(int(math.ceil(n / 2) - 1), -1, -1):\n\t\theap_adjust(heap, i, n, article_cnt)\n\tfor i in range(n, len(heap)):\n\t\tif article_cnt[heap[0]] < article_cnt[heap[i]]:\n\t\t\theap[0] = heap[i]\n\t\t\theap_adjust(heap, 0, n, article_cnt)\n\treturn heap[:n]",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "排序",
            "堆",
            "统计"
        ]
    },
    {
        "name": "实现字典树",
        "desc": "字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n它有3个基本性质：根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。\n\n请实现字典树Class，并完成单词插入和查找函数。",
        "answer": "参考实现代码：\n``` python\nclass TrieNode(object):\n    def __init__(self):\n        self.is_leaf = False\n        self.children = [None] * 26\n        \nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        if not word:\n            return\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                cur_node.children[index] = TrieNode()\n            cur_node = cur_node.children[index]\n        cur_node.is_leaf = True\n        \n    def search(self, word):\n        if not word:\n            return False\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                return False\n            cur_node = cur_node.children[index]\n        return cur_node.is_leaf\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "Trie"
        ]
    },
    {
        "name": "36进制正整数加法",
        "desc": "36进制由0-9，a-z，共36个字符表示，最小为'0'\n\n'0'~'9'对应十进制的0~9，'a'~'z'对应十进制的10~35\n\n例如：'1b' 换算成10进制等于 1 * 36^1 + 11 * 36^0 = 36 + 11 = 47\n\n要求按照加法规则计算出任意两个36进制正整数的和\n\n如：按照加法规则，计算'1b' + '2x' = '48'\n\n要求：**不允许把36进制数字整体转为10进制数字，计算出10进制累加结果再转回为36进制**\n\n本题可任意改变进制，如加入大写字母变为62进制。",
        "answer": "``` python\ndef add(num1, num2):\n    '''\n    &gt;&gt;&gt; add('', '')\n    ''\n    &gt;&gt;&gt; add('', '1')\n    '1'\n    &gt;&gt;&gt; add('ab', '')\n    'ab'\n    &gt;&gt;&gt; add('1b', '2x')\n    '49'\n    &gt;&gt;&gt; add('0', '2x')\n    '2x'\n    &gt;&gt;&gt; add('zz', '1')\n    '100'\n    '''\n    def _get_value(num):\n        if ord('0') <= ord(num) <= ord('9'):\n            return ord(num) - ord('0')\n        return ord(num) - ord('a') + 10\n\n    def _to_chr(num):\n        if 0 <= num <= 9:\n            return str(num)\n        return chr(ord('a') + num - 10)\n\n    def _add(n1, n2, carry):\n        result = _get_value(n1) +  _get_value(n2) + carry\n        carry = 1 if result &gt;= 36 else 0\n        result %= 36\n        return _to_chr(result), carry\n\n    len1, len2 = len(num1), len(num2)\n    if len1 &gt; len2: # 取巧：把两个数字长度对齐\n        num2 = '0' * (len1 - len2) + num2\n    elif len2 &gt; len1:\n        num1 = '0' * (len2 - len1) + num1\n    res = []\n    carry = 0\n    for i in xrange(max(len1, len2) - 1, -1, -1):\n        tmp, carry = _add(num1[i], num2[i], carry)\n        res.append(tmp)\n    if carry:  # 易错点：很容易遗漏\n        res.append('1')\n    return ''.join(res[::-1])  # 易错点：需要翻转\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "字符串",
            "编程",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数",
        "desc": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数的位置，从 1 开始计数。例如：\n-2，-1，0，0，0，0，4，5\n最后一个负数出现的位置为：2，第一个正数出现的位置为7。",
        "answer": "1. 二分查找 0 的位置;\n2. 注意边界位置 0 的处理，在二分条件上需要做一些处理，如果只是找到 0 的位置然后遍历找到第一个和最后一个 0 的话， 复杂度为恶化;\n3. 整体复杂度为 O(lg(n));",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "青蛙跳石子",
        "desc": "在长度为m的地面格子上，每个格子里面有一些石子；有一只青蛙, 从格子开始处起跳，每次可以跳3到5个格子，求青蛙跳出格子最少需要踩几个石子；",
        "answer": "简单DP\ndp[i]表示调到第i的位置最少需要踩几个石子;\n于是dp[i]可由dp[i-3], dp[i-4], dp[i-5]得来;",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "给定一个字符串如下，请统计字符串中出现最多的字母和次数",
        "desc": "```javascript\nfunction findMaxDuplicateChar(str) {\n       let maxChar = '', maxValue = 1;\n    // 补全代码.....\n    return {\n        maxChar,\n        maxValue\n    };\n}\nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "answer": "```javascript\nfunction findMaxDuplicateChar(str) {\n    if (str.length === 1) {\n        return str;\n    }\n    const charObj = {};\n    let maxChar = '', maxValue = 1;\n    for(let i = 0; i < str.length; i++) {\n        if (str[i].trim() !== '') {\n            if (!charObj[str.charAt(i)]) {\n                charObj[str.charAt(i)] = 1;\n            } else {\n                charObj[str.charAt(i)] += 1;\n            }\n        }\n    }\n    for (const k in charObj) {\n        if (charObj[k] &gt;= maxValue) {\n            maxChar = k;\n            maxValue = charObj[k];\n        }\n    }\n    return {\n        maxChar,\n        maxValue\n    };\n}\n \nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表",
            "基础算法",
            "统计"
        ]
    },
    {
        "name": "数组排序",
        "desc": "<p>输入数组nums，要求输出升序排序后的结果。已知数组元素为非负整数，且当数组长度为n时，所有元素的值都小于n；</p><p>例：</p><p>[3, 2, 1, 3, 5, 0]  -&gt; [0, 1, 2, 3, 3, 5]</p><p>[0] -&gt; [0]</p>",
        "answer": "<p>O(n2)的排序算法：冒泡排序，插入排序，选择排序 等；</p><p>O(nlog(n))的排序算法：归并排序，快排 等；</p><p>O(N)的排序算法：空间换时间，利用计数实现，需要O(n)空间复杂度；</p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "二叉树转换成双向链表",
        "desc": "转换结果满足下面条件：\n1. 不要新建一个链表空间，要原地做；直接使用 left 和 right 指针\n2. 转换后的双向链表节点顺序要与中序遍历的结果一致\n3. 二叉树最左边的节点作为双向链表的头节点\n\n例如:\n二叉树:\n\n                    1\n            2                3\n        4        5        6        7\n\n双向链表: 4 <-&gt; 2 <-&gt; 5 <-&gt; 1 <-&gt; 6 <-&gt; 3 <-&gt; 7",
        "answer": "二叉树遍历；递归；链表操作\n\n原理上看，对根节点、根的左子树、根的右子树分别作处理：\n1. 比如根节点1， 对于左子树，找到它的最右节点 5， 把 5 和 1 连接起来；\n2. 对于 1 的右子树，找到它的最左节点 6，把 6 和 1 连接起来。\n\n实现上，假设已经把左子树变做双向链表了，让指针一直向右走，就能找到最右节点和根连接；\n右子树同理。\n\n返回结果的时候，找到双向链表的最左节点就可以了。\n\n```\n    private Node convertToDoublyLinkedList(Node root) {\n        if (root.getLeft() != null) {\n            Node left = convertToDoublyLinkedList(root.getLeft());\n            while (left.getRight() != null) {\n                left = left.getRight();\n            }\n            left.setRight(root);\n            root.setLeft(left);\n        }\n         \n        if (root.getRight() != null) {\n            Node right = convertToDoublyLinkedList(root.getRight());\n            while (right.getLeft() != null) {\n                right = right.getLeft();\n            }\n            right.setLeft(root);\n            root.setRight(right);\n        }\n        return root;\n    }\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "双向链表"
        ]
    },
    {
        "name": "翻转单词",
        "desc": "给定一个字符串，逐个翻转字符串中的每个单词。",
        "answer": "根据情况，选择栈和队列即可\n栈必须，队列可选",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "字符串"
        ]
    },
    {
        "name": "两个数的和相加",
        "desc": "<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p>",
        "answer": "<p><br></p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "二叉树所有根到叶子路径组成的数字之和",
        "desc": "二叉树每个节点的value范围是1-9\n\n例如：\n```\n\t\t   1\n\t 2\t\t    3 \n 4\t  5\n```\n从根到叶子共3条：1-&gt;2-&gt;4, 1-&gt;2-&gt;5, 1-&gt;3\n\n构成的数字为124，125，13，求和124 + 125 + 13 = 262即为所求",
        "answer": "``` python\ndef tree_path_sum(root, val):\n\tif not root:\n\t\treturn 0\n\tval = val * 10 + root.val\n\tif not root.left and not root.right:\n\t\treturn val\n\treturn tree_path_sum(root.left, val) + tree_path_sum(root.right, val)\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "三门问题/蒙蒂大厅难题",
        "desc": "你面前有三扇门，每个门后都有一个奖品，其中一个是一辆车，另外两个是山羊。\n你首先挑选一扇门，姑且称之为A，其他两个门分别是B和C。\n在打开你选择的门前，我先从B和C中选择一个没有车的门打开。\n给你一个选择，你是坚持最开始的选择还是换到剩下未打开的门上？\n\n如果我打开门的策略从随机选择，变成总是优先选择门B，只有在迫不得已的时候选择C。\n问结果有变化么？",
        "answer": "使用贝叶斯公式求解，p(a|b)*p(b) = p(a)*p(b|a)\n三种假设，即假设车在门A，门B，门C后面。\nD表示打开了门B但是车不在门后。\n假设A：先验概率=1/3，似然度=1/2，后验概率=(1/3)*(1/2)/(1/2)=1/3\n假设B：先验概率=1/3，似然度=0, 后验概率=0\n假设C：先验概率=1/3，似然度=1，后验概率=2/3\n\n变化之后概率相同。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "贝叶斯",
            "概率"
        ]
    },
    {
        "name": "海盗分金问题",
        "desc": "5个海盗要分100块金币，分配的协议是：按顺序一个一个来，轮到当前的海盗，他提出一个分配方案，如果包括他在内至少有50%的人同意，那么方案通过，否则这个海盗就会被喂鲨鱼，下一个海盗继续提出分配方案。 \n假设海盗都是纯理性而且冷血的，他们的第一原则是生存，第二原则就是拿到尽可能多的金子，第三原则是如果给的金币一样，他们倾向于选择有更少的海盗的分配方案。",
        "answer": "思路： \n5个人太多了，首先把问题简化。从1个人到5个人逐个分析。\n* 1个人，显然自己全拿\n* 2个人。1，2。2号海盗显然可以全部拿走，因为他自己的一票保证了50%。\n* 3个人。1，2，3。首先，如果3号的方案没通过，那么1号将什么都得不到，而2号必定要除3号而后快。因此3号必须征得1号的支持，但又不能完全不给1号任何金币（第三原则）。因此分配方案是1 2 3 = 1 0 99。这样3号的方案能够得到1和3的支持。\n* 4个人。1，2，3，4。首先，如果4号的方案没通过，那么2号将什么都得不到。因此4号只需要分配1 2 3 4 = 0 1 0 99\n* 5个人。1，2，3，4，5。5号清楚的知道一旦他的方案不通过，1和3将什么都得不到，因而他只需要分配1 2 3 4 5 = 1 0 1 0 98，这样即足以保证。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "牛过河",
        "desc": "<p><strong>有一堆牛要过河，河的长度是ｌ，河中间有ｎ个石头，牛只能踩着石头过河，问去掉ｍ个石头后（去掉这ｍ个石头的方式是随机的）的每种情况牛能走的石头间距最小值中，最大的那一个是多少</strong></p>",
        "answer": "<p>二分最大值最小化问题</p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "求二叉树是否存在和值为N的路径",
        "desc": "从二叉树的根到叶子节点称为一条路径\n\n路径上每个节点的value之和为路径和值\n\n本题要求所有的路径中是否存在一条和值为N的。\n\nfollow-up：可以要求返回所有符合条件的路径",
        "answer": "要求自己给出二叉树数类定义\n\n本题很容易用递归解决，基本思路如下：\n\n```\ndef path_exists(root, n):\n\tif not root:\n\t\treturn False\n\tif not root.left and not root.right and root.value == n:\n\t\treturn True\n\treturn path_exists(root.left, n - root.value) or path_exists(root.right, n - root.value)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "special trim",
        "desc": "对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'\n\n例如：\n\n'aacbd' -&gt; 'ad'\n\n'aabcd' -&gt; 'ad'\n\n'aaabbccc' -&gt; ''\n\n不允许使用类似string.replace函数。要求时间、空间复杂度尽量优化",
        "answer": "本题不好处理的是aaabccc，即：c和a相遇就要都去掉。\n\n比较好的思路是用栈的思路解决。\n\n``` python\ndef special_trim(s):\n    if not s:\n        return s\n    res = []\n    for c in s:\n       if c == 'b':\n            continue\n       if c == 'c' and res and res[-1] == 'a':\n            res.pop()\n            continue\n       res.append(c)\n    return ''.join(res)\n```",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "栈",
            "字符串"
        ]
    },
    {
        "name": "约瑟夫问题",
        "desc": "假设有n个人，标号为1-n。\n从第一个人开始计数，到第k个人则出列，随后从第k+1个人重新计数，到第k再出列。\n直至剩下最后一个人。问最后剩下的人的编号？",
        "answer": "考察链表使用。最简单直接的方法是使用循环链表。\n具体思路是：\n1. 构建循环链表，初始化数据；\n2. 每到第k-1个结点，便p-&gt;next = p-&gt;next-&gt;next。\n3. 循环结束条件为p = p-&gt;next，即只有一个结点，该结点所对应的值即为最后剩下的人。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "二叉搜索树中的第K小的元素",
        "desc": "给定二叉搜索树，求所有元素中第k小的。k<=节点总数",
        "answer": "结合BST的性质，用递归很好解决，按照中序遍历即可\n核心代码：\n``` python \ndef find_k_small(root, k):\n\tdef _find(root):\n\t\tif not root:\n\t\t\treturn -1\n\t\tval = _find(root)\n\t\tif not k:\n\t\t\treturn val\n\t\tk -= 1\n\t\tif not k:\n\t\t\treturn root.val\n\t\treturn _find(root)\n\t_find(root)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "序列化和反序列化二叉树",
        "desc": "将一棵二叉树序列化为字符串，并能字符串反序列为一棵树。",
        "answer": "本题解法应该有不少，大体思路是按照某种遍历的顺序记录下每个节点，叶子节点的空指针可以用特殊字符表示\n\n例如用先根遍历解决：\n``` python \n    def serialize(root):\n        def pre_order(node):\n            if node:\n                vals.append(str(node.val))\n                pre_order(node.left)\n                pre_order(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        pre_order(root)\n        return ' '.join(vals)\n\n    def deserialize(data):\n        def pre_order():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = pre_order()\n            node.right = pre_order()\n            return node\n            \n        vals = iter(data.split())\n        return pre_order()",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "带过期和最大对象数限制的LRU-CACHE",
        "desc": "设计一个对象cache, 他支持下列两个基本操作:\nset(id, object), 根据id设置对象;\nget(id): 根据id得到一个对象;\n同时它有下面几个性质:\n1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期;\n2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数;\n3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象;\n请你设计这样一个cache;",
        "answer": "通过组合一些基本的数据结构, \n来实现一些更高级的性质;\n\n内部维护一个链表, list, 其元素为一个三元组(ID, timestamp, obj), 分别为对象ID, 上次被访问时间, 和对象内容;\n在维护该list时, 需要保持一个性质, 越靠后的元素越新, 既timestamp越大;\n内部再维护一个map, 该map表示一个ID到list节点的索引, 格式为map(ID, node);\n对于get(id)操作:\n1: 先在map中查找ID对应的list node;\n2: 将node从list中取出, 即list.Remove(node);\n3: 检查node.timestamp, 如果过期, 则返回null, 表示无数据, 并将ID从map中删除;\n4: 如果未过期, 设置node.timestamp = now(), 并将node添加到list尾部, 即list.Append(node);\n5: 返回node.obj;\n对于set(id, obj)操作:\n1: 同get(id)的1~3步操作, 删除对应的ID;\n2: 如果此时空间满了, 既对象数为n, 则将list中表头的那个元素删除;\n3: 更新list和map: node = new(ID, now(), obj), list.Append(node), map[ID] = node;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "n sum",
        "desc": "<p>输入一维数组array和n，找出和值为sum的n个元素即可，不用找出所有组合。</p><pre><code>array = [2, 3, 1, 10, 4, 30] n = 2, sum = 31\nresult = find(array, n, sum)\n// result = [1, 30]</code></pre><p><br></p>",
        "answer": "<p>基础解法供参考</p><pre><code>function find(arr, n, sum, shouldSort = true) {\n let sorted = arr;\n if (shouldSort) {\n  sorted = arr.sort();\n }\n const length = sorted.length;\n if (n === 2) {\n  let front = 0;\n  let back = length - 1;\n  while(front < back) {\n   const value = sorted[front] + sorted[back];\n   if (value === sum) {\n    return [sorted[front], sorted[back]];\n   } else if (value &gt; sum) {\n    back -= 1;\n   } else {\n    front += 1;\n   }\n  }\n  return null;\n }\n for(let i = 0; i < length; i += 1) {\n  const val = sorted[i];\n  const result = find(sorted.slice([i + 1]), n - 1, sum - val, false);\n  if (!result) {\n   return null;\n  } else {\n   return [val, ...result];\n  }\n }\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表",
            "算法"
        ]
    },
    {
        "name": "多叉树广度优先遍历查找",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>按照广度优先查找符合要求的节点（没有符合要求的节点返回null），比如查找电话号码为 phone的用户信息，调用如下：</li></ol><p><br></p><pre><code>let node = wideTraversal(node,(e)=&gt;e.phone===phone)</code></pre><p><br></p>",
        "answer": "<p>节点定义：</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>实现：</p><pre><code>wideTraversal(node: Node, predict): Node | null {\n  if (!node) return null\n  let queue: Array<Node&gt; = [];\n  queue.push(node)\n  while (queue.length) {\n    let cur = queue.shift()\n    if (!cur) continue\n    if (predict(cur)) return cur\n    if (cur.children&amp;&amp; cur.children.length) {\n      queue.push(...cur.children)\n    }\n  }\n  return null\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "广度优先遍历",
            "前端编码",
            "多叉树"
        ]
    },
    {
        "name": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点",
        "desc": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点，各个相邻顶点间距离为1",
        "answer": "方案：对图进行K步的BFS, 注意处理被重复走过的点;\n",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出所有根节点到叶子节点的路径",
        "desc": "比如:\n\n            1\n          2   3\n         4  5 6  7\n                  8\n\n输出：\n\n    1，2，4\n    1，2，5\n    1，3，6\n    1，3，7，8\n",
        "answer": "二叉树遍历",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找出旋转有序数组中的最小值",
        "desc": "假设原数组为1，2，3，4，5那4，5，1，2，3就是旋转有序的数组\n\n注：数组无重复元素",
        "answer": "暴力可以O(n)，但没用到旋转有序的特征。\n\n本题可以用二分的思想降低时间复杂度\n\n定义左右两个指针left、right指向头尾元素\n\n如果a[left] < a[right]则没有移位，直接输出a[left]即可，反之二分搜索。\n\n如果a[left] &gt; a[mid] 则要搜索右半段，因为a[left]也大于a[right]；反之搜索左半段。\n\n核心代码\n``` python\ndef find_min(arr):\n\tleft, right = 0, len(arr) - 1\n\tif arr[left] < arr[right]:\n\t\treturn arr[left]\n\twhile left != right - 1:\n\t\tmid = left + (right - left) / 2\n\t\tif arr[left] < arr[mid]:\n\t\t\tleft = mid\n\t\telse:\n\t\t\tright = mid\n\t\treturn min(arr[left], arr[right])\n\t\t",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "有序数组"
        ]
    },
    {
        "name": "搜索二维矩阵",
        "desc": "给定二维m * n矩阵matrix，满足一定特性：\n1. 每行从左到右递增\n2. 每列从上到下递增\n给定目标元素num，判断num是否在矩阵中存在\n\n例如：\n``` python \nmatrix = [\n\t[1, 3, 5, 10],\n\t[2, 4, 6, 11],\n\t[7, 9, 12, 20],\n]\n```\nnum = 4存在；num = 13不存在\n",
        "answer": "结合数组定义，观察例子，有两个特殊位置很特殊：左下角和右上角。\n\n左下角的7往上所有的数变小，往右所有的数变大。\n\n那么我们就可以将目标数字num和左下角比较，比目标小就往右搜，比目标大就往上搜。\n\n如此往复可以判断num是否在matrix中。\n\n``` python\ndef search(matrix, num):\n\tif not matrix:\n\t\treturn False\n\trows, cols = len(matrix), len(matrix[0])\n\tif num < matrix[0][0] or num &gt; matrix[rows - 1][cols - 1]:\n\t\treturn False\n\ti, j = rows - 1, 0 # 左下角\n\twhile i &gt;= 0 and j < cols:\n\t\tif matrix[i][j] < num:\n\t\t\tj += 1\n\t\telif matrix[i][j] &gt; num:\n\t\t\ti -= 1\n\t\telse:\n\t\t\treturn True\n\treturn False\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "扑克牌的堆栈、队列操作",
        "desc": "我手中有一堆扑克牌， 但是观众不知道它的顺序。\n\n*  第一步， 我从牌顶拿出一张牌， 放到桌子上。\n*  第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。\n*  第三步， 重复第一步的操作， 直到我手中所有的牌都放到了桌子上。 \n\n最后， 观众可以看到桌子上牌的顺序是：13\\12\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\n请问， 我刚开始拿在手里的牌的顺序是什么？",
        "answer": "解法一：\n这道题候选人容易出现折半的思路， 其实考虑的复杂了。 \n本质是将一个队列和栈做了两个操作\n1. 出队、入栈\n2. 出队、入队（队尾）\n\n因为是看得到结果， 看不到初始顺序， 那么这个操作就是一个逆操作。 \n1. 出栈、入队\n2. 出队（队尾）、入队（队首）\n答案：\n输入：\n1,2,3,4,5,6,7,8,9,10,11,12,13,\n输出：\n1,12,2,8,3,11,4,9,5,13,6,10,7,\n\n代码如下\n``` C++ 再改改\nint doTheWork(std::deque * pQ, std::stack * pS)\n{\n        if(NULL == pQ or NULL == pS)\n                return -1;\n        while(pS-&gt;size() &gt; 0)\n        {\n                int val = pS-&gt;top();\n                pS-&gt;pop();\n                if (pQ-&gt;size() &gt; 0)\n                {\n                        int tmp = pQ-&gt;back();\n                        pQ-&gt;pop_back();\n                        pQ-&gt;push_front(tmp);\n                        pQ-&gt;push_front(val);\n                }\n                else\n                {\n                        pQ-&gt;push_front(val);\n                }\n        }\n        return 0;\n}\n```\n\n解法二：\n对手上牌按照a，b，c...进行编码，直接按顺序操作，输出结果和桌上实际结果对应，即为原手上牌的顺序。",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "用js实现一个binarySearch二分查找",
        "desc": "定一个一个binarySearch的函数，传参能支持四个参数，分别是：\n&gt;1. arr: 一个数组，\n&gt;1. key: 一个需要查找的目标值，\n&gt;1. low: 左边界\n&gt;1. high: 右边界\n&gt;1. 如果能知道则访问素组的位置，否则返回-1\n```javascript\nfunction binarySearch(){\n  // 补全代码\n}\nvar arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\nvar result = binary_search2(arr, 5, 0, 6);\nconsole.log(result);   // 4\n```",
        "answer": "二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：\n&gt;1. 首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n&gt;1. 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n&gt;1. 如果某一步数组为空，则表示找不到目标元素。\n```javascript\n // 递归实现的js代码\n  function binary_search2(arr, key, low, high) {\n    if(low &gt; high) {\n      return -1;\n    }\n    var mid = parseInt((high + low) / 2);\n    if(arr[mid] == key) {\n      return mid;\n    } else if(arr[mid] &gt; key) {\n      high =mid -1;\n      return binary_search2(arr, key, low, high);\n    } else if(arr[mid] < key) {\n      low = mid +1;\n      return binary_search2(arr, key, low, high);\n    }\n  }\n\n  var arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\n  var arrSorted = arr.sort(function (a,b) {\n    return a-b;\n  })\n  var result = binary_search2(arrSorted, 5, 0, 10);\n  console.log(result);   // 4\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": [
            "查找",
            "js"
        ]
    },
    {
        "name": "通配符匹配",
        "desc": "给定字符串s和模式串p，实现函数match(s, p)，判断模式串p是否能完全匹配s\n\n模式串中有两个特殊字符'?'和'*'\n\n'?'匹配任意1个字符；'* '匹配任意r个字符，包括空\n\n例如:\n``` python\nmatch('a', 'a') = True\nmatch('aa', 'a') = False\nmatch('a', '?') = True\nmatch('aa', '*') = True\nmatch('abc', '?*') = True\n```",
        "answer": "本题可以用DP算法来解答。\n\n用dp[i, j]表示串s, p这两个串分别到i和j位置它们是否匹配。那么我们得到递推关系：\n\n如果p[j] != '* ', dp[i, j] = dp[i-1, j-1] and (s[i] == p[j] || p[j] == '?') \n\n如果p[j] == '* ', 那么dp[i][j] = dp[i - 1][j] || dp[i][j - 1]\n\n``` python\ndef match(s, p):\n\tm, n = len(s), len(p)\n\tdp = [[False] * (n + 1) for _ in range(m + 1)]\n\tdp[0][0] = True\n\tfor j in range(1, n + 1):\n\t\tdp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif p[j - 1] in [s[i - 1], '?']:\n\t\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\telif p[j - 1] == '*':\n\t\t\t\tdp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\treturn dp[m][n]\n```\n另外，本题也可以用贪心算法",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": []
    },
    {
        "name": "原子计数问题",
        "desc": "给出一个分子式，比如：\n     HMg2(H2O(N3Ag)2)3N2\n计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：\nmap[string]int {&#34;H&#34;: 7, &#34;Mg&#34;: 2,&#34;Ag&#34;: 6, ...}\n\n分子式的规则：\n1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H\n2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 [2-1000]\n3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N出现 6 次，Ag 出现 2 次\n4. 括号可以嵌套\n\n输入是合法的\n",
        "answer": "1. 最简单的方法是递归，碰到 ( 就开始递归\n2. 担心爆栈就把递归改成非递归\n3. 可以用正则表达式来做，这里不展开了，如果候选人懂的话让他解释",
        "types": [
            "数据结构与算法",
            "递归",
            "堆栈"
        ],
        "tags": [
            "校招类",
            "编程",
            "代码类",
            "基础算法",
            "字符串"
        ]
    },
    {
        "name": "安卓解锁密码数",
        "desc": "安卓系统采用9个点连线构成图案密码。\n\n要求连接以下9个点中**至少4个点**构成一条路径，从而得到1个密码。\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n任意点间均可连线，都有如下附加限制：\n1. 在一个密码路径里每个点只能用1次；\n2. 如果2号点没有被连，则1不能直接连3号点，即：1-&gt;3路径是非法的。类似情况还有1、7；2、8；1、9等等；\n3. 如果2点已经连过了，则1可以连到3，3也可以连到1，即：2-&gt;1-&gt;3路径是合法的。\n4. 1和6是可以直接连线的，因为二者之间没有点。\n\n本问题求所有的密码数，也就是路径数，包含4个点、5个点。。。9个点的所有路径数。",
        "answer": "本题目如果数据结构算法比较熟悉，会很快想到DFS。\n\n难点是路径不能直达问题如何解决？\n\n用visit记录某个点是否已经在路径中\n\n``` python\nvisit = [[0, 0 ,0],\n         [0, 0, 0],\n         [0, 0, 0]]\n```\n\n判断两个点能否连同，等价于判断两个点是否存在中间点问题，如果不存在可以直接连，如果存在要判断中间点是否已经访问过了。\n\n中间点坐标为：|i1 - i2| / 2, |j1 - j2| / 2\n\n另外，本题考虑到对称性会大大降低运算量\n\n1、3、7、9点对称\n\n2、4、6、8点对称",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "矩阵中的最长递增路径",
        "desc": "给定m * n矩阵matrix，可以从任意位置开始，向上、向下、向左、向右移动，但要求下一个位置上的元素要大于当前元素。\n\n找出最长的递增路径长度。",
        "answer": "本题很容易想到dfs，但问题是每个点开始递归搜索，重复计算很多，结合DP提升效率。\n\n用dp[i][j]表示从(i,j)开始的最长递增路径长度，当递归调用时，如果dp[i][j]不为0，直接返回dp[i][j]。\n\n``` python\ndef long_increase_path_len(matrix):\n\tif not matrix:\n\t\treturn 0\n\tres = 1\n\tm, n = len(martix), len(matrix[0])\n\tdp = [[0] * n for _ in range(m)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tres = max(res, dfs(matrix, dp, i, j, m, n))\n\treturn res\n\ndef dfs(matrix, dp, i, j, m, n):\n\tif dp[i][j]:\n\t\treturn dp[i][j]\n\ttmp_max = 1\n\tdirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]:\n\tfor ni, nj in dirs:\n\t\tii, jj = i + ni, j + nj\n\t\tif ii < 0 or ii &gt;= m or jj < 0 or jj &gt;= n or matrix[ii][jj] <= matrix[i][j]:\n\t\t\tcontinue\n\t\ttmp_max = max(tmp_max, 1 + dfs(matrix, dp, ii, jj, m, n)\n\tdp[i][j] = tmp_max\n  return dp[i][j]\n```",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "升序数组求平方数不同的个数",
        "desc": "给定一个升序数组1，元素有重复，对每个元素算一下平方后得到新的数组2，问数组2中不相同的元素共有多少个？给出算法和空间复杂度，要求尽量优化。\n举例：\n数组1 [-13,-10,-9,-6,-5,-1,3,4,6,7,10,11,15,21,42]\n平方后得到\n数组2 [169,100,81,36,25,1,9,16,36,49,100,121,225,441,1764]\n其中不相同的元素个数为13个。",
        "answer": "常规解法，按题目思路，先平方算好，再将结果插入hashset，最后输出hashset大小。\n优化1，平方没必要算，其实就是绝对值。\n优化2，注意到数组2其实是以0分隔的一个降序和一个升序数组。反序遍历降序数组，正序遍历升序数组，即可合并成一个升序数组，合并时做一下排重，最后输出合并后数组的元素个数。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "URL反转",
        "desc": "给定形如 `www.toutiao.com` 的 URL，将其转换成 `com.toutiao.www` 的形式，要求必须原地操作",
        "answer": "1. 原地全部翻转一遍；\n2. 遍历遇到&#34;.&#34;，继续翻转该部分字符串；\n该题目重点考察编码，需要保证代码简洁，要不不允许使用字符串库函数",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "判断单向链表是否有环",
        "desc": "<p>判断一个链表中是否有环</p><p>例如：A-&gt;B-&gt;C-&gt;D-&gt;B-&gt;C-&gt;D</p><p>D指向B形成环</p><p>要求：在空间复杂度O(1)的情况下，时间复杂度最小</p>",
        "answer": "<p>创建两个指针slow，fast，同时指向这个链表的头节点。</p><p>然后让两个指针开始循环移动</p><p>slow每次向下移动一个节点，fast每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环</p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表",
            "单向链表"
        ]
    },
    {
        "name": "给定两个链表，求它们交叉节点",
        "desc": "1.  已知两个链表, 从某个节点开始就交叉了\n2.  已知这两个链表的头节点, 求出交叉的节点",
        "answer": "1. 依次遍历两个链表分别得到链表的长度M和N\n2. 然后让长的那个一个从头开始走|M-N|的步数;\n3. 两个指针同时走, 直到碰头",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "判断一个IP是否是国内",
        "desc": "如何快速判断一个ip地址是否属于国内？已知db中有几十万个国内ip地址段",
        "answer": "1. 将ip地址通过位移运算转成int\n2. 对ip地址进行排序(可以考察任意一种排序算法)\n3. 二分查找",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "计算机基础",
            "查找",
            "编程",
            "基础算法"
        ]
    },
    {
        "name": "用户在线峰值",
        "desc": "已知一天内用户登录登出的日志（数据量较大），求这一天用户在线的最大峰值和持续时间段\n- 日志包含字段（userid, login_time, logout_time）\n- 登录登出时间精确到秒\n",
        "answer": "可以将这一天看成0-24*3600的离散的时间点，构造一个dict\n每个用户在login_time对应value+1,logout_time对应value-1\n得到用户在线数量的变化趋势，然后再遍历此dict求和\n难点：\n- 想不到先求变化趋势\n- 峰值时间段可能存在多个\n```\ndef get_max(logs):\n    log_count = {}\n    for log in logs:\n        login_time = log['login_time']\n        logout_time = log['logout_time']\n        log_count[login_time] = log_count.setdefault(login_time, 0) + 1\n        log_count[logout_time] = log_count.setdefault(logout_time, 0) - 1\n    max, current_users, start, end, is_max, timeline = (0, 0, 0, 0, False, [])\n    keys = log_count.keys()\n    keys.sort(lambda a, b: a - b)\n    for time_node in keys:\n        current_users = current_users + log_count[time_node]\n        if current_users &gt; max:\n            max = current_users\n            start = time_node\n            is_max = True\n        elif current_users < max:\n            if is_max:\n                end = time_node\n                is_max = False\n        else:\n            if is_max:\n                end = time_node\n            else:\n                timeline.append((start, end))\n                start = time_node\n                is_max = True\n    timeline.append((start, end))\n    return max, timeline\n```\n\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "股票买卖问题",
        "desc": "给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？日期不重叠的情况下，可以买卖多次呢？\n输入: {100, 80, 120, 130, 70, 60, 100, 125} \n只能买一次：65（60 买进，125 卖出）\n可以买卖多次: 115（80买进，130卖出；60 买进，126卖出）\n\n提示：不用输出买卖的序列，只需要得到最大利润\n\n",
        "answer": "1. 对于只能买一次的情况：\n\n```\n    public static int maximumProfit(int[] stockPrices)\n    {\n        int profit = 0;\n        int minimumPrice = Integer.MAX_VALUE;\n        /* \n         * 对于给定的一天，最大利润等于 - \n         * max(昨天为止的最大利润, 当天的价格 - 之前的最小价格)\n         */\n        for(int i = 0; i < stockPrices.length; i++)\n        {\n            profit = Math.max(profit, stockPrices[i] - minimumPrice);\n            minimumPrice = Math.min(stockPrices[i], minimumPrice);\n        }    \n        return profit;\n    }\n```\n\n2. 对于可以买卖多次的情况，累积递增序列的差就可以了：\n```\n    public static int maximumProfit2(int[] stockPrices) {\n        int totalProfit = 0;\n        for(int i=1; i 0){\n                totalProfit += currentProfit;\n            }\n        }\n        return totalProfit;\n    }\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "编程"
        ]
    },
    {
        "name": "输出给定数字下一个比它大的数字",
        "desc": "比如数字：1234， 输出 1243\n\n比如 1243，则输出 1324",
        "answer": "用 1243 为例：\n1. 从右向左扫描，找到第一个不是升序的数字，比如 2\n2. 在 2 的右边，找到比它大的最小的数，是 3\n3. 交换 2和 3，得到 1342\n4. 把现在 3 右边的所有数字从大到小排序，得到 1324 （如果是排序则是 O(nlogn), 其实逆序就行了）",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "Path Sum",
        "desc": "给定一个二叉树和一个数字n，判断二叉树中是否有一个路径上的数字之和等于给定的数字n\n\n\nFor example:\nGiven the below binary tree and sum = 22,\n\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\nreturn true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.\n",
        "answer": "public class Solution {\n\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root == null) return false;\n        int left = sum - root.val;\n        if(root.left == null &amp;&amp; root.right == null &amp;&amp; left == 0) {\n            return true;\n        }\n        return hasPathSum(root.left, left) || hasPathSum(root.right, left);\n    }\n}\n\n可以进一步问，输出所有和等于给定数字n的path",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "简单编程题"
        ]
    },
    {
        "name": "单链表每隔k个元素做一次反转",
        "desc": "给定一个链表，每隔k个元素做一次反转\n\nExample:\nInputs:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 3 \nOutput:  3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;8-&gt;7-&gt;NULL. \n\nInputs:   1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 5\nOutput:  5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;8-&gt;7-&gt;6-&gt;NULL. \n",
        "answer": "Node* rollback(Node *&amp;head, int k) {\n\tNode *pre = NULL;\n\tNode *next = NULL;\n\tNode *curr = head;\n\tint count = 0;\n\twhile (curr != NULL&amp;&amp;countnext;\n\t\tcurr-&gt;next = pre;\n\t\tpre = curr;\n\t\tcurr = next;\n\t\tcount++;\n\t}\n\tif (curr != NULL) {\n\t\thead-&gt;next = rollback(next, k);\n\t}\n \n\treturn pre;\n}\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "简单编程题",
            "单链表"
        ]
    },
    {
        "name": "用两个栈实现一个队列",
        "desc": "用两个堆栈模拟队列的功能，实现push，pop，count三个方法",
        "answer": "简单的做法：栈s1和s2，始终维护s1作为存储空间，以s2作为临时缓冲区，push直接进s1，pop时s1导入s2，栈顶出栈，导回s1\n优化做法：入队时，将元素压入s1，出队时，判断s2是否为空，如不为空，则直接弹出顶元素；如为空，则将s1的元素逐个“倒入”s2，把最后一个元素弹出并出队",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "赛马求最快N匹",
        "desc": "<p>条件：</p><p>1.64匹马</p><p>2.8个赛道</p><p>3.每次比赛只能知道比赛结果名次，不能知道具体时间</p><p>求：</p><p>用最少的比赛次数，找出最快的4匹</p>",
        "answer": "<p>1.每次比赛至少能淘汰4匹（树形淘汰算法），因此淘汰60匹，至少需要15次比赛，回答15，是最差答案</p><p>2.如果能回答出12次的（经过加速之后的简单排序），为次优解：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2）从第9次开始</p><p>\t\t*1.先取每组第一名，每次比赛，找出最快1匹，取出</p><p>\t\t*2.将最快这匹对应的组里次快的加入比赛，一共4次，找出最快4匹</p><p>3.如果能答出特定情况下10次，最差11次，为最优解（剪枝算法）：</p><p>\t1）先每8个一组，一共8组比8次</p><p>\t2)  第9次，先取每组第一名，进行比赛，找出前四名</p><p>    3)  第10次，将前4名对应的组中的第2名加入比赛，一共8匹，比赛一次，如果对应的前四名没发生变化，说明前4名就是最快4名</p><p>\t4）第11次</p><p>\t\t*1.假设有一个组里的第2名，进入前四名：</p><p>\t\t\t①有一组的第1名被挤出前4名，该组所有的候选马无法进入前4名</p><p>\t\t\t②另外两组第2名之后无法进入前4名</p><p>\t\t\t因此，4（第2名在第10次进入前4名的组对应的前4名）+2（还在前4名的另外两个第1名）=6匹马进行比赛，决出前4名，即为最终答案</p><p>\t\t*2假设有两个组的第2名，进入前四名：</p><p>\t\t\t①则另外两组都无法进入前4名，而还在前4名的两组的前4名4+4=8，跑一次，最终能得到最快4名</p>",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "LRU cache",
        "desc": "实现一个LRU过期算法的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则按照LRU的规则剔除一个KV;\n4. 查询时如果已经过期, 则返回空;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;\n\n解法大致同上;\n为了实现LRU, 可在每次get后, 将该K从cache中删除并重新插入一遍;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "求数组的最大区间和",
        "desc": "# 输出一个 int 型数组的最大连续子数组（所有元素加和最大）各个元素之和\n# 保证数组中至少有一个正数\n\n例：\n\n输入：{1，2，5，-7，8，-10}\n\n输出：9  (子数组为: {1，2，5，-7，8})",
        "answer": "复杂度 `O(n)` 的算法\n\n```\nint _tmain(int A[], _TCHAR* argv[])\n{\n    int array_length = sizeof(A) / sizeof(A[0]);\n    int sum = 0;\n    int thisSum = 0;\n    for (int i = 0; i < array_length; i++)\n    {\n        thisSum += A[i];\n        if (thisSum &gt; sum)\n        {\n            sum = thisSum;\n        }\n        else if (thisSum < 0)\n        {\n            thisSum = 0;\n        }\n    }\n    printf(&#34;%d&#34;,sum);\n    return 0;\n}\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "最长无重复子串",
        "desc": "<p>无重复子串指：子串中每个字符都不相同 例如：s = 'aaabcdddd' 最长的无重复子串为'abcd'长度为4</p>",
        "answer": "<p>用两个指针left、right指向子串的起止位置 通过set记录是否有重复元素，只要没有重复都可以移动right，更新最长子串长度 如果有重复，移动left，并从set里移除对应的字符</p><pre><code>def max_sub_len(s): \n    existed = set() \n    res = 0 \n    left, right = 0, 0 \n    while right < len(s): \n        if s[right] not in existed: \n            existed.add(s[right]) \n            res = max(res, len(existed)) \n            right += 1\n        else: \n            t.remove(s[left]) \n            left += 1\n    return res </code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "服务循环依赖检测",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很长，如果出现循环依赖将出现非常恶劣的影响。</p><p>对于一个具体应用，已知各个服务的调用关系（即依赖关系），请判断是否存在循环调用。</p><p>输入：</p><p>一组服务依赖关系list，('A', 'B') 表示 A 会调用 B 服务</p><p>service_relations = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('D', 'A')]</p><p>输出：</p><p>由于存在 A - B - D - A 故存在循环依赖，返回True；反之如果不存在，返回False</p><p>Follow up：</p><p>1. 如果有多个环，请都检测出来</p><p>2. 返回每个环中的服务名</p>",
        "answer": "<p>可以采用拓扑排序 或者 DFS思路解决</p>",
        "types": [
            "数据结构与算法",
            "图"
        ],
        "tags": [
            "检测"
        ]
    },
    {
        "name": "比较版本号",
        "desc": "<p>比较两个版本号 version1 和 version2。</p><p>如果 version1 &gt; version2 返回 1，如果 version1 < version2 返回 -1， 除此之外返回 0。</p><p>你可以假设版本字符串非空，并且只包含数字和 . 字符。</p><p> . 字符不代表小数点，而是用于分隔数字序列。</p><p>例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。</p><p>你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。</p><p> </p><p>示例 1:</p><p>输入: version1 = &#34;0.1&#34;, version2 = &#34;1.1&#34;</p><p>输出: -1</p><p>示例 2:</p><p>输入: version1 = &#34;1.0.1&#34;, version2 = &#34;1&#34;</p><p>输出: 1</p><p>示例 3:</p><p>输入: version1 = &#34;7.5.2.4&#34;, version2 = &#34;7.5.3&#34;</p><p>输出: -1</p><p>示例 4：</p><p>输入：version1 = &#34;1.01&#34;, version2 = &#34;1.001&#34;</p><p>输出：0</p><p>解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。</p><p>示例 5：</p><p>输入：version1 = &#34;1.0&#34;, version2 = &#34;1.0.0&#34;</p><p>输出：0</p><p>解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。</p>",
        "answer": "<h4><strong>方法1：分割+解析，两次遍历，线性空间</strong></h4><h4><strong>方法2：双指针，一次遍历，常数空间</strong></h4>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "双指针",
            "字符串"
        ]
    },
    {
        "name": "单链表(奇数位升序，偶数位降序)的排序",
        "desc": "单链表，奇数位升序，偶数位降序，现在要求整体排成全局升序\n输入：1-&gt;200-&gt;10-&gt;120-&gt;30-&gt;8-&gt;88-&gt;4\n输出：1-&gt;4-&gt;8-&gt;10-&gt;30-&gt;88-&gt;120-&gt;200",
        "answer": "思路：链表可以随便拆、组合\n先把奇数和偶数拆开，形成两个链表，一个升序和一个降序\n1-&gt;10-&gt;30-&gt;88\n200-&gt;120-&gt;8-&gt;4\n然后将降序的反转，再合并成一个列表\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "蛇形打印二叉树",
        "desc": "输入一棵二叉树，比如：\n```\n              0\n        1            2\n      3     4      5     6\n          7            8   9\n```\n将它蛇形输出，结果如下：\n0，1，2，6，5，4，3，7，8，9",
        "answer": "1. 依赖栈记录每层节点值：层次便利，按偶数层（根是 0 层）从右到左，奇数层从左到右输出，时间空间复杂度都是 O(n)，n 是节点数\n2. 不依赖栈，递归：d 是层数，for i from 0 to d， 如果 i 是偶数，后序遍历二叉树的 0到i层，输出第i层的节点；如果i是奇数，先序遍历 0到 i 层，也只输出第i层节点。空间复杂度是 O(d) 即递归深度，时间复杂度是 o(d^2) 因为 0层节点会被访问 d 次，1 层节点 d-1 次，以此递推。",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "冒泡排序和快速排序的复杂度区别是什么，如何实现？",
        "desc": "```javascript\n/**\n * Quick Sort\n **/\nfunction quickSort(arr) {\n    // 补全代码\n}\nconsole.log(quickSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n\n/** \n * BubbleSort\n **/\n \nfunction bubbleSort(arr) {\n    // 补全代码\n}\nconsole.log(bubbleSort([1, 3, 10, 6, 2, 8, 7])) // output: [1, 2, 3, 6, 7, 8, 10]\n```",
        "answer": "&gt;1. 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n&gt;1. 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```javascript\n/**\n * Quick Sort  O(NLogN)\n **/\nfunction quickSort(arr) {\n    const res = [];\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const leftArr = [];\n    const rightArr = [];\n    const q = arr[0];\n    for (let i = 1, l = arr.length; i < l; i++) {\n        if (arr[i] &gt; q) {\n            rightArr.push(arr[i]);\n        } else {\n            leftArr.push(arr[i]);\n        }\n    }\n    return res.concat(quickSort(leftArr), [q], quickSort(rightArr));\n}\n \n/** \n * BubbleSort O(N*N)\n **/\nfunction bubbleSort(arr) {\n    for (let i = 0, l = arr.length; i < l - 1; i++) {\n        for (let j = i + 1; j < l; j++) {\n            if (arr[i] &gt; arr[j]) {\n                let tem = arr[i];\n                arr[i] = arr[j];\n                arr[j] = tem;\n            }\n        }\n    }\n    return arr;\n}\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "岛屿数量",
        "desc": "<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1:</p><p>输入:</p><p>11110</p><p>11010</p><p>11000</p><p>00000</p><p>输出: 1</p><p>示例 2:</p><p>输入:</p><p>11000</p><p>11000</p><p>00100</p><p>00011</p><p>输出: 3</p><p>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p><p><br></p>",
        "answer": "<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。</p><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0</p><p>最终岛屿的数量就是我们进行深度优先搜索的次数</p><pre><code>class Solution {\nprivate:\n    void dfs(vector<vector<char&gt;&gt;&amp; grid, int r, int c) {\n        int nr = grid.size();\n        int nc = grid[0].size();\n\n        grid[r][c] = '0';\n        if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == '1') dfs(grid, r - 1, c);\n        if (r + 1 < nr &amp;&amp; grid[r+1][c] == '1') dfs(grid, r + 1, c);\n        if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == '1') dfs(grid, r, c - 1);\n        if (c + 1 < nc &amp;&amp; grid[r][c+1] == '1') dfs(grid, r, c + 1);\n    }\n\npublic:\n    int numIslands(vector<vector<char&gt;&gt;&amp; grid) {\n        int nr = grid.size();\n        if (!nr) return 0;\n        int nc = grid[0].size();\n\n        int num_islands = 0;\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                if (grid[r][c] == '1') {\n                    ++num_islands;\n                    dfs(grid, r, c);\n                }\n            }\n        }\n\n        return num_islands;\n    }\n};\n</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把中文数字转成int数字",
        "desc": "<p>在中文页面解析、中文数据处理中，常常遇到用中文表示的数字，例如：五千三百万零五百零一。</p><p>我们一般需要把它转化成int型整数，进行实际存储和使用。 请完成一亿（不含）以内的中文数字到int整数的转换</p>",
        "answer": "<p><br></p><pre><code>// 递归解法\ndef cn2digital(number):\n  name2val = {u'一': 1, u'二': 2, u'三': 3, u'四': 4, u'五': 5,\n    u'六': 6, u'七': 7, u'八': 8, u'九': 9}\n  unit2count = {u'十': 10, u'百': 100, u'千': 1000, u'万': 10000}\n  for unit in [u'万', u'千', u'百', u'十']:\n    if unit in number:\n      n1, n2 = number.split(unit)\n      return cn2digital(n1) * unit2count.get(unit) + cn2digital(n2)\n  if not number:\n    return 0\n  for c in number:\n    if c == u'零':\n      continue\n    return name2val.get(c)\n\n// 非递归解法\ndef cn2digital(number):\n  name2val = {u'一': '1', u'二': '2', u'三': '3', u'四': '4', u'五': '5',\n        u'六': '6', u'七': '7', u'八': '8', u'九': '9'}\n  unit2count = {u'十': 1, u'百': 2, u'千': 3, u'万': 4}\n  res = []\n  base_count = 0 \n  for num in number[::-1]:\n    if num in name2val:\n      res.append(name2val.get(num))\n      continue\n    zero_count = 0\n    if num in unit2count:\n      zero_count = max(0, unit2count.get(num) + base_count - len(res))\n      if num == u'万':\n        base_count += 4\n    for _ in range(zero_count):\n      res.append('0') \n  return 0 if not res else int(''.join(res[::-1]))\n\nassert cn2digital(u'一万零一') == 10001\nassert cn2digital(u'三千五百万') == 35000000\nassert cn2digital(u'三千五百一十万') == 35100000\nassert cn2digital(u'三千五百零一万') == 35010000\nassert cn2digital(u'三千五百零一万零五百') == 35010500\nassert cn2digital(u'三千五百零一万五千五百五十五') == 35015555\nassert cn2digital(u'一百万') == 1000000\nassert cn2digital(u'二百三十四万三千四百九十三') == 2343493</code></pre><p><br></p><p><br></p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "Hash表设计",
        "desc": "常规的hash表设计及变通。问题由浅入深递进\n\n1. 基本的原理，负载因子，扩容的原理\n2. 假设内存受限4G，hash表已经占用3G内存，怎么使用剩下的那一个G的内存空间\n3. 怎么在文件中设计类似于hash表的结构，能够在文件中快速查找一个key/value对",
        "answer": "1. 扩容时注意关注 rehash 过程\n2. 类似于多个Hash组成一个List\n3. 类似于leveldb的思路",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "哈希表"
        ]
    },
    {
        "name": "1-n数字字典序第k大",
        "desc": "给你一个数字n(n < 1e9), \n再给你一个数字k(k < n), 要求你找到1, 2, 3, ... n按照字典序排序后, 第k大的数字;\n\n如, n = 15, k = 7;\n\n那1 ~ 15按照字典序排序为: 1, 10, 11, 12, 13, 14, 15, 2, 3, 4, 5, 6, 7, 8, 9;\n\n则答案为15;",
        "answer": "利用字典树的思想;\n我们假设有这么一棵树, 每个节点都要10个儿子, 10条到儿子的边分别对应数据0~9;\n那么我们在这棵树上, 对边按照0~9的顺序进行DFS, 当走到第k个节点时, 该节点对应的数字既为我们的第k大字典序数字;",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "在数组中找出和值为给定值的两个数",
        "desc": "输入一维数组array和n，找出和值为0的任意两个元素。例如：\n``` python \narray = [2, 3, 1, 10, 4, 30]\nn = 31\n```\n则结果应该输出[1, 30] 顺序不重要\n\n如果有多个满足条件的，返回任意一对即可",
        "answer": "解法1： 本题容易想到用哈希表，迭代一次边建表边查找n - array[i]是否在hash_table中即可。\n\n该方法空间开销比较大\n\n解法2：先对数组做排序，然后首尾两个指针求和，如果小于n则左指针右移，如果大于n则右指针左移。\n\n该方法时间复杂度O(nlogn)\n\n推荐考察解法2，附带做了排序算法的考察",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "老虎吃羊问题",
        "desc": "在岛上有100只老虎和1只羊，老虎可以吃草，但他们更愿意吃羊。\n\n假设：\n\nA：每次只有一只老虎可以吃样，而且一旦他吃了羊，他自己就变成羊。\n\nB：所有的老虎都是聪明而且完全理性的，他们的第一要务是生存。 \n\n问最后这只羊会不会被吃？如果是n只老虎和一只羊呢？",
        "answer": "思路：先simplify。\n- 1只老虎，肯定吃。 \n- 2只老虎肯定不吃，否则就被另一只吃了。 \n- 3只老虎，如果一只老虎吃掉了羊，问题就转换为2只老虎和1只羊的情况，显然另外两种老虎不敢轻举妄动。所以羊会被吃。 \n- 4只老虎，如果某一只老虎吃了羊，问题转化为3只老虎和1只羊的问题，它肯定会被接下来的某一只吃掉，然后其他两只只能等着。所以4只老虎，大家都不敢吃羊。\n\n这样归纳，我们就可以发现如果老虎数目是奇数，那么羊肯定被吃，如果是偶数，那么羊肯定不会被吃。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "爬虫url去重-多线程并发",
        "desc": "用爬虫抓取网页时, 一个较为重要的问题, 就是对爬去的网页去重;\n请你详细的设计一种数据结构, 用来检验某个URL之前是否已经被爬取过;\n并给出每次检验的复杂度, 以及整体的空间复杂度;\n\n一般爬虫在实现时, 都会利用多线程并发的爬取;\n现在需要你升级一下之前的实现, 以保证并发安全;",
        "answer": "通常来说, 不需要改变数据结构本身, 只需要在其外围包裹一些简单的操作, 就能大大提高其并发度;\n比如可以根据URL的后几位, 进行hash分桶;\n注意这里选取URL的后几位, 而不是前几位, 是为了让hash更加均匀, 因为同个域名下的前缀大多是相同的;\n然后每个桶内维护一个上述实现的去重的数据结构;",
        "types": [
            "数据结构与算法",
            "队列"
        ],
        "tags": [
            "多线程",
            "哈希",
            "Hash策略",
            "爬虫"
        ]
    },
    {
        "name": "蓄水问题, 1维",
        "desc": "给定一个一维数组用于描述一个海拔，相邻的海拔高度不同，则下雨后低洼海拔的洼地会有积水，假设雨水足够，能够填满所有低洼地段，计算下雨后所有低洼地段总蓄水量。\n\n例如给定数组为：\n\n5, 2, 1, 4, 3\n\n则：所有低洼地段蓄水为量为 5",
        "answer": "定义左极高点: 该点左边最高的那个点;\n\n定义右极高点: 该点右边最高的那个点;\n\n于是每个点的蓄水高度为: min(左极高点高度, 右极高点高度) - 该点高度，累加每个点的高度即可;所有点的左右极点可以分别通过一次向右和向左的扫描得到;\n\n算法复杂度为 O(n)",
        "types": [
            "数据结构与算法",
            "贪心",
            "队列",
            "堆栈",
            "数组"
        ],
        "tags": [
            "基础"
        ]
    },
    {
        "name": "轮流抛硬币问题",
        "desc": "# A和B玩抛硬币游戏，AB轮流抛一枚硬币，谁先抛到正面谁就获胜并结束游戏，硬币两面均匀。A先抛，请问A获胜的概率是多少？",
        "answer": "将A和B的获胜情况罗列，可以看到规律。A第一次抛获胜概率是1/2, A不获胜情况下B第一次获胜概率1/2*1/2=1/4。\n所以A获胜概率是：1/2+1/8+1/32+...=2/3。B获胜的概率是：1/4+1/16+...=1/3",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "查找第一个缺失的正整数",
        "desc": "查找第一个缺失的正整数。\n时间复杂度O(n) ，空间复杂度 O(1)\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\n",
        "answer": "1 排序之后查找\n\n2 把出现的数值放到与下标一致的位置，再判断什么位置最先出现不连续的数值，就是答案了。\n\n3 和2差不多，把出现过的数值的下标位置做好标识，如果没有出现过的数组的下标就没有标识，那么这个就是答案",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "简单编程题",
            "查找",
            "排序"
        ]
    },
    {
        "name": "微信跳一跳",
        "desc": "<p>从起点开始接下来有 100 个方块，相邻方块间的距离都为 1，每个方块上有增加体力的食用蘑菇或减少体力的毒蘑菇，蘑菇带来的体力改变是已知的。一个人初始体力为 m，每次可以往前跳任意个方块，体力耗尽就会死掉。</p><ol><li>每跳一次消耗的体力与跳的距离成正比，比例为 1。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方。问这个人能否跳到终点，如果能，求可能剩余的最大体力。</li><li>每跳一次消耗的体力是跳的距离的平方，每跳一个方块加 1 分。问这个人能否跳到终点，如果能，求可能得到的最高分数。</li></ol>",
        "answer": "<ul><li>第 1 问，贪心算法，时间复杂度 O(n)</li></ul><pre><code>def flip1(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第一问\n    :param m: 初始体力\n    :param array: 蘑菇带来的体力改变\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    for n in array:\n        m -= 1  # 消耗的体力与跳的距离成正比\n        if m <= 0:  # 体力不足死掉\n            return -1\n        if n &gt; 0:  # 只跳加体力的格子\n            m += n\n    if array[-1] < 0:  # 终点的蘑菇必须吃\n        m += array[-1]\n    return m if m &gt; 0 else -1</code></pre><ul><li>第 2 问，动态规划，时间复杂度 O(n^2)</li></ul><pre><code>def flip2(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第二问\n    :param m:\n    :param array:\n    :return: 可能剩余的最大体力\n    &#34;&#34;&#34;\n    # powers 表示在每个格子可能剩余的最大体力\n    powers = [m] + [0] * len(array)\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            if powers[j] &gt; (i - j) ** 2:\n                powers[i] = max(powers[i], powers[j] - (i - j) ** 2 + array[i - 1])\n    return powers[-1] if powers[-1] &gt; 0 else -1</code></pre><ul><li>第 3 问，动态规划，时间复杂度 O(n^3)</li></ul><pre><code>def flip3(m, array):\n    &#34;&#34;&#34;\n    微信跳一跳第三问\n    :param m:\n    :param array:\n    :return: 可能跳的最多格子数\n    &#34;&#34;&#34;\n    # scores 表示在每个格子得到不同分数时可能剩余的最大体力\n    scores = [{0: m}] + [{} for _ in range(len(array))]\n    for i in range(1, len(array) + 1):\n        for j in range(i):\n            for score, power in scores[j].items():\n                left = power - (i - j) ** 2\n                if left &gt; 0 and left + array[i - 1] &gt; 0:\n                    scores[i][score + 1] = max(scores[i].get(score + 1, 0), left + array[i - 1])\n    return max(scores[-1].keys()) if scores[-1].keys() else 0</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": [
            "算法"
        ]
    },
    {
        "name": "二路归并",
        "desc": "<p>实现一个merge函数，功能是将两个有序数组，将它们合并成一个有序数组，如：</p><pre><code>let arr1 = [1, 2]\nlet arr2 = [-1, 2, 8, 9]\n\nmerge(arr1,arr2) // 返回 [-1, 1, 2, 2, 8, 9]</code></pre><p><br></p>",
        "answer": "<p><br></p><pre><code>function merge(arr1, arr2) {\n  // 可以判断一下arr1、arr2是否是数组\n  if(!(Array.isArray(arr1) &amp;&amp; Array.isArray(arr2))) throw '...'\n\n  let i = 0, j=0, t=0\n  let temp = [];\n  while (i < arr1.length &amp;&amp; j < arr2.length) {\n    temp[t++] = arr1[i] <= arr2[j] ? arr1[i++] : arr2[j++];\n  }\n\n  while (i < arr1.length) {  // 数组1有剩余\n    temp[t++] = arr1[i++];\n  }\n  while (j < arr2.length) {  // 数组2有剩余\n    temp[t++] = arr2[j++];\n  }\n  return temp\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据结构",
            "归并",
            "前端编码",
            "排序"
        ]
    },
    {
        "name": "拆分字符串",
        "desc": "输入一个列表的单词，及一个长字符串，判断字符串可否由列表中的单词组成。比如：\n输入：\n单词列表 dict：I, love, byte, bytedance\n字符串 s：Ilovebytedance\n输出：\nTrue",
        "answer": "1. 用一个数组 validWords[] 记录字符串当前位置之前的字符串是否可以用 dict 组成，validWords[i]=True 可以，否则不可以。默认不可以\n2. for 循环 i 从 0 到 s.length：\n    a. 如果 s[0-i] 在 dict 中，设置 validWords[i]=True\n\t\tb. 如果validWords[i]=True，for 循环 j 从 i+1 到 s.length-1，判断 s[i+1 到 j] 是否在 dict 中，如果是，设置 validWords[j]=True\n3. 如果 validWords[s.length-1] = True, return True\n",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": [
            "校招类",
            "字符串",
            "代码类"
        ]
    },
    {
        "name": "给定单链表，求离终点距离为 k 的节点",
        "desc": "给定单链表，求离终点距离为 k 的节点，要求只扫一次且空间复杂度为O(1)",
        "answer": "两个指针, 第一个先向后走k步;\n\n然后两个一起走;\n\n当第一个指针到达链表尾部时另一个指针指向的就是距离终点距离为 k 的节点。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "数组0值筛选",
        "desc": "给定一个非负数组，要求你对它进行操作, \n使得所有的0 放在数组左边， \n大于 0 的值位于数组右边,  \n\n要求空间为O(1), 时间为O(n);",
        "answer": "从右往左扫描，同时维护另一个指针指向出现在最右侧的 0，每次扫描到非 0 数字则和它交换",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针",
            "基础算法"
        ]
    },
    {
        "name": "区间合并",
        "desc": "给定一堆左右闭合的区间，要求对重叠的区间进行合并，返回合并后的区间段。\n\n例如：[9, 10], [1,4], [3,6], [8, 12]\n\n那么合并后的区间段为：[1, 6], [8, 12]",
        "answer": "由于输入的区间段，不一定按照起点排好序，所以先按照起点坐下排序利于后续合并。\n\n``` python\n    def merge(intervals):\n        res = []\n        intervals = sorted(intervals, key=lambda x:x.start)\n        pre = None\n        for interval in intervals:\n            if not pre:\n                pre = interval\n                continue\n            if interval.start <= pre.end:\n                if interval.end &gt;= pre.end:\n                    pre.end = interval.end\n            else:\n                res.append(pre)\n                pre = interval\n        if pre:\n            res.append(pre)\n        return res\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "爬楼梯问题",
        "desc": "<ul><li>爬楼梯问题：爬楼梯时，每一步会有两个选择：爬一个台阶和爬两个台阶，问：楼梯总台阶数为n，则一共有多少种爬法，写一个函数f，使得：总的爬法= f(n)。举例：n=3时，则共有：（1,1,1)、(1,2) 、(2,1)三种爬法，则f(3)=3。</li></ul><p><br></p>",
        "answer": "<p>斐波拉契：f(n)=f(n-1)+f(n-2) </p><p>代码需要判断边界</p>",
        "types": [
            "数据结构与算法",
            "动态规划",
            "数学基础",
            "递归"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找零钱问题",
        "desc": "有1，2，5，10等不同零钱，问给N元，有多少种不同的组合方式？",
        "answer": "假设有m种零钱，具体面值存在arr中，要找的钱为n。\n\n使用m种零钱去找零n元，可以拆分为：\n\n完全不用第m种零钱 和 至少用一次第m种零钱\n\n``` python\ndef zhaolin(arr, n, m):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 0\n    if m <= 0:\n        return 0\n    return zhaolin(arr, n, m - 1) \\ # 不用第m-1号零钱\n\t\t\t+ zhaolin(arr, n - arr[m - 1], m) # 至少使用1次m-1号零钱\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "把二叉树压成单链表",
        "desc": "对于输入的二叉树，舍弃left指针，用right指针按照先根顺序串成单链表。例如：\n``` \n      1\n    2   5\n  3  4\n``` \n转为单链表为1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5\n要求in-place",
        "answer": "本题利用dfs递归比较好解，关键点是要把左子树的最后一个节点和右子树头接上。\n\n关键代码：\n``` python\ndef flatten(root):\n\tif not root:\n\t\treturn\n\tif root.left:\n\t\tflatten(root.left)\n\tif root.right:\n\t\tflatten(root.right)\n\ttmp = root.right\n\troot.right = root.left\n\troot.left = None\n\twhile root.right:\n\t\troot = root-&gt;right\n\troot.right = tmp\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "最短子数组之和",
        "desc": "给定1个正整数数组array和1个正整数n，从array中寻找和值**大于等于n**的最短子数组。\n\n如果存在，则返回最短子数组长度；如果不存在返回0。\n\n例如：array = [1, 3, 4, 3, 9, 1], n = 12,\n\n那么子数组[3, 9]满足条件且长度最短为2。\n\n",
        "answer": "本题用两个指针的思路解决，时间复杂度O(n)\n\n指针left和right记录子数组的左右边界位置，\n\n让right向右移，直到子数组和&gt;=n或到达数组末尾，更新最短距离，\n\n将left像右移一位，然后在和值中减去移去的值，\n\n重复上面的步骤，直到right到达末尾，且left也无法再右移\n\n``` python\ndef min_sub_len(arrary, n):\n\tres = sys.maxsize\n\tleft, cur_sum = 0, 0\n\tfor i in range(0, len(array)):\n\t\tcur_sum += array[i]\n\t\twhile left <= i &amp;&amp; cur_sum &gt;= n:\n\t\t\tres = min(res, i - left + 1)\n\t\t\tcur_sum -= array[left]\n\t\t\tleft += 1\n\treturn 0 if res == sys.maxsize else res\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "双指针"
        ]
    },
    {
        "name": "二叉树最大宽度",
        "desc": "<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度（每一层的节点可能为空）。</p>",
        "answer": "<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p><p>思路：主要想法是给每个节点一个 position 值，如果我们走向左子树，那么 position -&gt; position * 2，如果我们走向右子树，那么 position -&gt; positon * 2 + 1。当我们在看同一层深度的位置值 L 和 R 的时候，宽度就是 R - L + 1。</p><p><strong>方法 1：深度优先搜索</strong></p><h4><strong>方法 2：宽度优先搜索</strong></h4>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树"
        ]
    },
    {
        "name": "二叉树中序遍历打印节点信息",
        "desc": "实现一个二叉树中序遍历函数，打印所有节点信息。  \ntypedef string DataType;  \ntypedef struct BinTreeNode {  \n    DataType data;  \n    struct BinTreeNode* leftChild;  \n    struct BinTreeNode* rightChild;  \n} BinTreeNode;  \ntypedef BinTreeNode* BinaryTree;  \n  \nvoid MidOrderPrint(BinaryTree tree) {  \n    //打印二叉树节点信息  \n}  \n",
        "answer": "二叉树的遍历按照根节点位置的不同，分为前序遍历、中序遍历、后序遍历。\n前序遍历：根节点-&gt;左子树-&gt;右子树  \n中序遍历：左子树-&gt;根节点-&gt;右子树  \n后序遍历：左子树-&gt;右子树-&gt;根节点  \n例如二叉树结构如下  \n........... a  \n........../.....\\  \n........b........c  \n....../....\\  \n....d........e  \n.....\\ ...../  \n......f....g  \n  \n前序遍历：abdfegc  \n中序遍历：dfbgeac  \n后序遍历：fdgebca  \n  \n  \n解法一：递归方式  \nvoid MidOrderPrint(BinaryTree tree) {  \n    if(NULL == tree) {  \n        return;  \n\t\t}  \n\t\tMidOrderPrint(tree-&gt;leftChild);  \n\t\tprintf(&#34;%s &#34;, tree-&gt;data.c_str());  \n\t\tMidOrderPrint(tree-&gt;rightChild);  \n}  \n|  \n|    \n解法二：非递归方式  \n//假设 Stack 为已经实现的堆栈类型，支持push和pop方法  \nclass Stack {  \n    void push(BinTreeNode *);  \n    BinTreeNode *pop();  \n    BinTreeNode *top();  \n};  \n  \nvoid MidOrderPrint(BinaryTree tree){  \n    if(NULL == tree) {  \n        printf(&#34;this tree is empty!\\n&#34;);  \n        return;  \n    }  \n    Stack s;  \n    BinTreeNode *curNode = tree;  \n    while(curNode != NULL || s.top() != NULL) {  \n        while(curNode != NULL) {  \n            s.push(curNode);  \n            curNode = curNode-&gt;leftChild;  \n        }  \n        curNode = s.pop();  \n        printf(&#34;%s &#34;,curNode-&gt;data);  \n        curNode = curNode -&gt;rightChild;  \n    }  \n}  \n_",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "iOS算法考查"
        ]
    },
    {
        "name": "从日志文件中抽取指定分钟的行",
        "desc": "某个很大（假设有几十T）的日志文件，每行的前两列为日期和时间（时间相等或递增），之后为日志内容，日志内容长度不一。例如：\n\n2015-01-01 00:00:01 this is the first line\n2015-01-01 00:00:03 this is another line\n...\n...\n2017-12-31 12:34:45 this is the last line\n\n需要将这个日志文件的某一分钟（例如2017-10-01 10:02这一分钟）的日志保存到另一个文件中。",
        "answer": "使用二分法寻找位置，seek到文件的该位置读取下一行的内容来判断需要寻找的行。\n本题考察二分查找和对文件操作的了解。需要考虑seek到一行中间的情况。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "二分"
        ]
    },
    {
        "name": "概率问题：赌徒获胜胜率计算",
        "desc": "有两个技巧相当的赌徒 A 和 B（即两人赌博胜率各为0.5），现在设定这样的获胜规则：\n1. A只要赢了2局或以上就获胜\n2. B要赢3局或以上才能获胜。\n问双方胜率各为多少？",
        "answer": "如果直接列举所有情况也是可以得出答案的，但有简单方法可以剪枝。\n\n我们用a表示A取胜，用b表示B取胜。\n\n只要意识到，**无论结果如何，最多4局就可分出胜负**，这样就好计算了。\n\n可以列举所有可能的情形如下： \n\naaaa aaab abba bbab \\\nbaaa baba abab babb \\\nabaa bbaa aabb abbb \\\naaba baab bbba bbbb\n\n也可以计算B获胜的情况 1(bbbb)+ 4(abbb babb bbab bbba)\n\n所以A获胜概率是\\dfrac{11}{16}，B获胜概率是\\dfrac{5}{16}\n",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "概率"
        ]
    },
    {
        "name": "旋转链表",
        "desc": "给定单链表，要求返回向右移k位后的新链表，例如：\n\n1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; NULL\n\nk = 3，则返回：4 -&gt; 5 -&gt; 6 -&gt; 1 -&gt; 2 -&gt;3 -&gt; null",
        "answer": "用一快一慢两个指针fast，slow，快指针提前走k步\n\n然后快慢一起走，直到fast.next == NULL\n\n这是slow-&gt;next即为新head，将fast.next指向head，并从slow处断开\n\n本题要注意参数处理：\n\n空链表\n\nk大于链表长度",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "链表求和",
        "desc": "给定一个链表`L1`、`L2`,每个元素是为10以内的正整数，链表表示一个数字，表头为高位。\n求两个链表之和，以链表形式返回\n如：\n```\nL1\n5 -&gt; 6 -&gt; 2 -&gt; 3 -&gt; 7\nL2\n1 -&gt; 7 -&gt; 0 -&gt; 9 -&gt; 2\n和为：\n56237+17092=73329\n```\n拓展1：\n表头改为低位\n拓展2：\n两表内数字不重复，优化\n拓展3：\n",
        "answer": "```java\n/**\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;      \n *     }\n * }\n */\npublic class Solution {\n    /**\n     * @param l1: the first list\n     * @param l2: the second list\n     * @return: the sum list of l1 and l2 \n     */\n    public ListNode addLists(ListNode l1, ListNode l2) {\n        if(l1 == null &amp;&amp; l2 == null) return null;\n        ListNode head = new ListNode(0);\n        ListNode tail = head;\n        int carry = 0;\n        while(l1 != null &amp;&amp; l2 != null){\n            int value = carry + l1.val + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n            l2 = l2.next;\n        }\n        while(l1 != null){\n            int value = carry + l1.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l1 = l1.next;\n        }\n        while(l2 != null){\n            int value = carry + l2.val;\n            carry = value / 10;\n            value = value % 10;\n            ListNode node = new ListNode(value);\n            tail.next = node;\n            tail = tail.next;\n            l2 = l2.next;\n        }\n        if(carry &gt; 0){\n            ListNode node = new ListNode(carry);\n            tail.next = node;\n            tail = tail.next;\n        }\n        return head.next;\n    }\n}\n```\n拓展1 翻转\n拓展2 set/bitmap\n",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "多叉树最大高度",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>求多叉树的最大高度 getDepth(node)</li></ol>",
        "answer": "<p>节点信息</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>getDepth实现</p><pre><code>function getDepth(node){\n if (!node) return 0\n if (node.children &amp;&amp; node.children.length){\n  let depth=0;\n  for(let e of node.children){\n    depth=Math.max(getDepth(e),depth)\n  }\n  return depth+1\n }else{\n   return 1\n } \n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "二叉树",
            "前端编码"
        ]
    },
    {
        "name": "单链表对折",
        "desc": "对输入的链表做对折操作\n\n例如：有n个节点的单链表：1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n-2 -&gt; n-1 -&gt; n -&gt; NULL\n\n处理后的链表为1 -&gt; n &gt; 2 -&gt; n-1 -&gt; 3 -&gt; n-2 ...\n\n要求在原链表基础上操作。",
        "answer": "解题思路\n1. 先找到中点，将原链表1分为2，即为l_1, l_2；\n2. 然后翻转l_2;\n3. 最后对l_1和l_2归并。\n\n本题主要考查候选人的编程功底以及好的编程习惯。\n\n比较好的答案应该是4个函数：\n* def fold(head): # 对折入口函数\n* def find_middle(head): # 找中点函数，用一快一慢两指针\n* def reverse(head): # 链表翻转\n* def merger(l1, l2): # 链表合并",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "单链表"
        ]
    },
    {
        "name": "螺旋打印二维数组",
        "desc": "输入m * n的二维矩阵，要求从(0,0)开始螺旋向内完成打印输出。\n具体打印方法：\n1. ➡️先从左向右打印第一行；\n2. ⤵️再从上向下打印最后一列；\n3. ⬅️然后从右向左打印最后一行；\n4. ⤴️最后从下向上打印第一列。\n\n如此往复，完成所有元素打印。\n\n例如：\n``` python\ninput = [ [ 1,  2,  3,  4,  5],\n          [14, 15, 16, 17,  6],\n          [13, 20, 19, 18,  7],\n          [12, 11, 10,  9,  8],\n        ]\noutput = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n```\n附件要求：不允许再开辟O(mn)的存储，直接打印输出。",
        "answer": "``` python\ndef print_martix(matrix):\n    '''\n    : type martix: list[list]\n    '''\n    if not matrix:\n        return\n    start_row, start_col, end_row, end_col = 0, 0, len(matrix) - 1, len(matrix[0]) - 1\n    while start_row <= end_row and start_col <= end_col:\n        for k in xrange(start_col, end_col + 1):\n            print matrix[start_row][k]\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            print matrix[k][end_col]\n        end_col -= 1\n        if start_row &gt; end_row or start_col &gt; end_col:\n        break\n        for k in xrange(end_col, start_col - 1, -1):\n            print matrix[end_row][k]\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            print matrix[k][start_col]\n        start_col += 1\n```\n测试用例\n``` python\ninput0 = [[]]\ninput1 = [[1]]\ninput2 = [[1, 2]]\ninput3 = [[1], [2]]\n```",
        "types": [
            "数据结构与算法",
            "递归",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "字符串相似度-编辑距离",
        "desc": "百科定义：编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。\n\n例如将kitten一字转成sitting：\n\nsitten （k→s）\n\nsittin （e→i）\n\nsitting （→g）\n",
        "answer": "本题用DP思路来解决，递推关系：\n\n若str1[i] == str2[j]，temp=0，否则temp=1\n\nd[i][j] = min([i-1][j] + 1, d[i][j-1] + 1, d[i - 1, j - 1] + temp)",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "找旋转数组的中位数",
        "desc": "有一个有序数组如：1，2，3，4，5，6，7\n随机选一个点比如5反转变成：5，6，7，1，2，3，4\n对于上面翻转后的数组，求它的中位数。",
        "answer": "1. 最简单的，排序，复杂度最高；\n2. 遍历整个数组，找到最小的数字比如 1，然后 (index+n/2)%n\n3. 二分，找到最小的数字就能找到中位数。淘汰哪一半？\n",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "校招类",
            "排序",
            "代码类",
            "基础算法",
            "查找"
        ]
    },
    {
        "name": "求二叉树的最长路径",
        "desc": "给定一棵二叉树，求其中的最长路径，所谓路径是指：连通两个节点的最小边数。",
        "answer": "使用后序遍历O(n)。遍历过程中计算以当前节点为根的最长路径，返回当前节点的高度。",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "精简文件路径",
        "desc": "对输入的unix风格的文件路径做精简。\n例如：/a/b/.././ 精简为 /a",
        "answer": "为了处理..，容易想到stack解决\n\n``` python \ndef simplify_path(ppath):\n\tsegs = path.split('/')\n\tstack = []\n\tfor seg in segs:\n\t\tif not seg or seg == '.':\n\t\t\tcontinue\n\t\telif seg == '..':\n\t\t\tif len(stack):\n\t\t\t\tstack.pop()\n\t\telse:\n\t\t\tstack.append(seg)\n\treturn '/' + '/'.join(stack)\n```\n特殊case：/../; ////foo/",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "stack"
        ]
    },
    {
        "name": "绝对众数",
        "desc": "<p>https://leetcode-cn.com/problems/majority-element/</p><p>定义：给定N个数，称出现次数最多的数为众数，若某数出现的次数大于N/2称为绝对众数。如</p><p>A={1, 2, 1, 3, 2}中，1和2都是众数，但都不是绝对众数</p><p>如A={1,2,1,3,1}中，1是绝对众数。</p>",
        "answer": "<p><strong>解题思路</strong>：任意删除2个不相同的数，不改变绝对众数</p><pre><code>class Solution {\n    public int majorityElement(int[] nums) {\n        int m = nums[0]; // 绝对众数\n        int count = 0; // 计数\n        for(int i = 0; i< nums.length; i++) {\n            if(count == 0) {\n                m = nums[i];\n                count++;\n            }else if(m == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return m;\n    }\n}</code></pre><p><br/></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "环节点的走法数",
        "desc": "一个环上有10个点，编号为0-9，\n\n从0点出发，每步可以顺时针到下一个点，也可以逆时针到上一个点，\n\n求：经过n步又回到0点有多少种不同的走法？\n\n举例：\n\n如果n = 1，则从0出发只能到1或者9，不可能回到0，共0种走法\n\n如果n = 2，则从0出发有4条路径：0-&gt;1-&gt;2, 0-&gt;1-&gt;0, 0-&gt;9-&gt;8, 0-&gt;9-&gt;0，其中有两条回到了0点，故一共有2中走法",
        "answer": "DP问题，令F(k, i)表示从0点出发经过k步到达i点的走法数，题目所求为F(n, 0)\n\nF(k, i) = F(k - 1,  (i + 1) % 10) + F(k - 1, ((i - 1) + 10) % 10)\n\n初始状态：f[1, 0] = 0, f[1, 1] = 1, f[1, 2] = 0, ... f[1, 9] = 1",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": []
    },
    {
        "name": "单词搜索",
        "desc": "<p>给定1个二维字符数组cmap和单词1个word，搜索word是否在map中。</p><p>搜索的定义是从cmap的任意位置开始，可以上下左右移动，依次和word每个字符匹配，如果word能匹配完，则存在，否则不存在。 </p><p>注：cmap中的每个位置只能被访问1次</p><pre><code>a c d z\nx t r o\nf i w o</code></pre><p><br></p><p>例如上面的cmap，则'zoo'能搜索到，'wto'不能搜索到</p>",
        "answer": "<p>比较容易想到用DFS解决，如果候选没思路，可以提示属于哪类问题，如果想到图就好办了。</p><pre><code>def search(cmap, word):\n    if not cmap or not word:\n        return False\n    visited = [[False] * len(cmap[0]) for _ in range(len(cmap))]\n    for i in range(len(cmap)):\n        for j in range(len(cmap[0])):\n            if dfs(cmap, word, 0, i, j, visited):\n                return True\n\ndef dfs(cmap, word, pos, i, j, visited):\n    if pos == len(word):\n        return True\n    if i < 0 or i &gt;= len(cmap) or j < 0 or j &gt; len(cmap[0]) or visited[i][j] or cmap[i][j] != word[pos]:\n        return False\n    find = False\n    visited[i][j] = True\n    for (ii, jj) in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        if dfs(cmap, word, pos + 1, i + ii, j + jj, visited):\n            find = True\n            break\n    visited[i][j] = False  # 易错点\n    return find</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "寻找数组任一峰值",
        "desc": "峰值定义：比前后元素都大；数组可能存在多个峰值，返回任一个就行\n\n例如：1 2 3 2 1 4 3 可以返回3或者4\n\n可以默认前提：\n\n1 任意元素不等于相邻元素\n\n2 首、尾元素只要比右、左一个元素大即可认为是峰值",
        "answer": "O(n)肯定能解决问题，但本题结合二分能优化时间复杂度\n\n如果a[mid] < a[mid + 1]说明峰值后半段，否则在前半段\n\n核心代码\n``` python\ndef find_peak(a):\n\tleft, right = 0, len(a) - 1\n\twhile left < right:\n\t\tmid = left + (right - left) / 2\n\t\tif a[mid] < a[mid + 1]:\n\t\t\tleft = mid + 1\n\t\telse;\n\t\t\tright = mid\n\t\treturn right",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "对称树判断",
        "desc": "判断一棵二叉树，是否是（左右）对称树：\n对称例子：\n```\nFor example, this binary tree is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```\n不对称例子：\n```\n   1\n   / \\\n  2   2\n   \\   \\\n   3    3\n``` ",
        "answer": "```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return solve (root.left, root.right);\n    }\n    \n    public boolean solve(TreeNode t1, TreeNode t2) {\n        if (t1 == null &amp;&amp; t2 == null) return true;\n        if (t1 == null &amp;&amp; t2 != null || t1 != null &amp;&amp; t2 == null || t1.val != t2.val) return false;\n        return solve(t1.left, t2.right) &amp;&amp; solve(t1.right, t2.left);\n    }\n}\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "给定链表，将其中的某一部分翻转",
        "desc": "给定链表，将其中的某一部分翻转, 要求空间复杂度为O(1);",
        "answer": "指针a与d指向要翻转部分的第一个节点，指针b指向a的上一个节点；\n\n指针c指向a，并将a指向下一个节点，再将c插入到b的后面，重复执行该操作直到a走出要翻转的区间；\n\n最后将a接在d后面，完成翻转。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "带TTL的N-kv cache",
        "desc": "&#34;实现一个带过期的KV cache, 所有KV过期间隔相同, 满足如下性质:\n1. 最多存储n对KV;\n2. 如果大于n个, 则随意剔除一个已经过期的KV;\n3. 如果没有过期的KV, 则将最老的那一对KV给剔除;\n4. 查询时如果已经过期, 则返回空;\n5. 所有操作复杂度都为O(1)&#34;",
        "answer": "用一个map来维护K-&gt;V索引;\n用一个双向链表list来维护K, 保证越靠前的K时间越早;\n用一个map来维护K-&gt;list.node, 该map用于删除时使用\n剔除时, 从list取出最老的K, 从map中剔除即可;\n\n最老的那个, 肯定最先过期;\n如果都没有过期, 也只能剔除最老的那个;\n因此在解决剔除与过期时, 完全同上;\n\n为了解决过期返回空, 有比较简单的办法是在每次查询前先过期一次;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "cache"
        ]
    },
    {
        "name": "二叉树的镜像",
        "desc": "实现一个函数，完成输入一个二叉树，输出该二叉树的镜像。\n二叉树结点的定义如下：\n```\nstruct BinaryTreeNode  \n{  \n    int data;  \n    BinaryTreeNode *Left;  \n    BinaryTreeNode *Right;  \n};\n```",
        "answer": "思路：先序遍历树的每个结点，若遍历到的结点有子结点，则交换它的两个子结点。\n有两种实现方法：\n1.递归实现:\n```\nvoid MirroRecursively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n    if(NULL == pNode-&gt;Left &amp;&amp; NULL == pNode-&gt;Right)  \n        return;  \n      \n    BinaryTreeNode *pTemp = pNode-&gt;Left;  \n    pNode-&gt;Left = pNode-&gt;Right;  \n    pNode-&gt;Right = pTemp;  \n      \n    if(pNode-&gt;Left)  \n        MirroRecursively(pNode-&gt;Left);  \n    if(pNode-&gt;Right)  \n        MirroRecursively(pNode-&gt;Right);  \n}  \n```\n2.非递归实现，即使用循环实现:\n```\nvoid MirrorNonRecurively(BinaryTreeNode *pNode)  \n{  \n    if(NULL == pNode)  \n        return;  \n  \n    stack stackTreeNode;  \n    stackTreeNode.push(pNode);  \n  \n    while(stackTreeNode.size())  \n    {  \n        BinaryTreeNode *pNode = stackTreeNode.top();  \n        stackTreeNode.pop();  \n  \n        if(NULL != pNode-&gt;Left || NULL != pNode-&gt;Right)  \n        {  \n            BinaryTreeNode *pTemp = pNode-&gt;Left;  \n            pNode-&gt;Left = pNode-&gt;Right;  \n            pNode-&gt;Right = pTemp;  \n        }  \n          \n        if(NULL != pNode-&gt;Left)  \n            stackTreeNode.push(pNode-&gt;Left);  \n  \n        if(NULL != pNode-&gt;Right)  \n            stackTreeNode.push(pNode-&gt;Right);  \n    }  \n} \n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出二叉树左视角能看到的节点",
        "desc": "给定一颗二叉树：\n\n```\n                1\n            2       3\n         4   5    6   7\n                        8\n```\n\n从左边看，输出能看到的 1，2，4，8 这四个节点，顺序无所谓。",
        "answer": "递归或者非递归都可以",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": [
            "校招类",
            "基础算法"
        ]
    },
    {
        "name": "日志提取",
        "desc": "你有一份非常大的日志文件;\n日志的格式为: timestamp: content;\n如 2017-01-01 20:00:00: hello hello hello;\n需要你提取日志中指定时间内的内容;\n如提取2017-01-01 20:00:00 ~ 2017-01-01 22:30:00的日志数据",
        "answer": "由于时间是递增的, 可以先二分到指定时间, 然后再进行读取;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "最多有两个不同字符的最长子串",
        "desc": "给定字符串s，返回最多包含两个不同字符的最长子串长度。\n\n例如：s = 'abbcceefffffg'\n\n最长子串为'eefffff'长度为5",
        "answer": "本题采用两个指针left、right指针指向子串的起始和结束位置。\n\nright不断前行，对left和right内的字符存入dict并计数，当dict的keys()超过2个时，向右移动left。\n\n如此往复，不断更新最长子串长度。\n\n``` python\ndef max_sub_len(s):\n\tmax_len, left = 0, 0\n\tcount = collections.Counter()\n\tfor right in xrange(len(s)):\n\t\tcount[s[right]] += 1\n\t\twhile len(count) &gt; 2:\n\t\t\tcount[s[left]] -= 1\n\t\t\tif count[s[left]] == 0:\n\t\t\t\tcount.pop(s[left])\n\t\t\tleft += 1\n\t\tmax_len = max(max_len, right - left + 1)\n\treturn max_len",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "滑动窗口",
            "字符串"
        ]
    },
    {
        "name": "生成n阶螺旋数组",
        "desc": "本题是http://marvel.byted.org/#/question/detail/?id=816&amp;nocontri=true的反向问题。\n\n``` python\ninput = 1\noutput = [[1]]\n\ninput = 2\noutput = [[1, 2],\n          [4, 3]]\n\t\t\t\t\t\ninput = 3 \noutput = [[ 1, 2, 3],\n          [ 8, 9, 4],\n          [ 7, 6, 5]]\n```",
        "answer": "``` python\ndef gen_matrix(n):\n    if n <= 0:\n        return None\n    matrix = [[0] * n for _ in xrange(n)]\n    val = 1\n    start_row, start_col, end_row, end_col = 0, 0, n - 1, n - 1\n    while val <= n * n:\n        for k in xrange(start_col, end_col + 1):\n            matrix[start_row][k] = val\n            val += 1\n        start_row += 1\n        for k in xrange(start_row, end_row + 1):\n            matrix[k][end_col] = val\n            val += 1\n        end_col -= 1\n        for k in xrange(end_col, start_col - 1, -1):\n            matrix[end_row][k] = val\n            val += 1\n        end_row -= 1\n        for k in xrange(end_row, start_row - 1, -1):\n            matrix[k][start_col] = val\n            val += 1\n        start_col += 1\n    return matrix\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "给定长度为n的整形数组，给定小一点的正数k，找到数组中出现次数大于 n/k 的数字",
        "desc": "举几个例子：\n1. 假设 n=100，k=2，那么需要找到数组中出现次数大于 50 的数。\n1. 假设 n=100，k=10，那么需要找到数组中出现次数大于 10 的数。",
        "answer": "1. 方案1：使用hashmap，遍历一次数组，将数组的数字当做key放入hashmap中，并将出现的次数作为value。之后再遍历hashmap将次数大于 n/k 的数打印出来即可\n2. 方案2：假设要求空间复杂度为O(K)，时间复杂度尽量低该怎么做？\n   - 可以给一点提示：换一个思路，每次都从数组中删除K个互不相同的数，那么删除 n/k 次后，还在数组中的数的出现次数，应该至少都大于 n/k \n\t - 最终答案：申请一个K空间的hashmap，按照方案1的思路遍历数组并插入hashmap，每当hashmap有K个值时，就将hashmap里的value减1，如果为0，就从hashmap中删除该key。当数组遍历完，hashmap中剩余的key/value对，就基本是我们要找的数（还需要再次遍历hashmap检查一下次数）",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表"
        ]
    },
    {
        "name": "平均延迟最大的调用链",
        "desc": "<p>在微服务的架构下，公司内部会有非常多的独立服务。</p><p>服务之间可以相互调用，往往大型应用调用链条很多也很长，我们需要找出耗时最大的链条进行优化。（假设服务同时调用其依赖的下游服务）</p><p><br></p><p>例如：</p><p>A服务依赖B服务，平均调用延迟100ms，记为(A, B, 100)</p><p>其他依赖和延迟如下：</p><p>(A, C, 200)</p><p>(A, F, 100)</p><p>(B, D, 100)</p><p>(D, E, 50)</p><p>(C, G, 300)</p><p>那么服务A有三条调用链：A-B-D-E，A-C-G，A-F，平均延迟250，500，100</p><p>延迟最大的调用链是A-C-G，延迟为500ms</p><p><br></p><p>输入：</p><p>[(A, B, 100), (A, C, 200), (A, F, 100), (B, D, 100), (D, E, 50), (C, G, 300)]</p><p>输出：</p><p>500</p><p><br></p><p>Follow up：</p><p>1. 能否输出延迟最大的调用链，如果存在多条，都输出</p>",
        "answer": "<p>可以采用搜索的思路解决，例如DFS</p>",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "最大能连续观看剧集数",
        "desc": "小明常常用BT下载连载电视剧、综艺观看。\n\n因为种子、网络等诸多因素，可能不是所有的剧集都能现在下来，且现在的顺序也不一定按照从第一集到第n集排列。\n\n请问：已知小明已下载的某部电视剧的剧集列表，求小明最多能连续观看多少集？\n\n例如：episodes = [10, 1, 3, 4, 7, 6, 20, 5, 13, 23, 14]\n\n那么小明做多能连续看[3, 4, 5, 6, 7]共5集\n\n希望时间复杂度O(N)",
        "answer": "我们看一般的case寻找连续剧集，其实就看当前剧集i的前一集i-1下载了没，或者后一集i+1下载了没\n\n也就是往前查查、往后查查，为了方便查，我们可以用hash，例如python里的set。\n\n知道这个原理后，我们可以比较容易的写出代码。\n\n``` python\ndef long_episode_count(episodes):\n    remains = set(episodes)\n   \tlong_count = 0\n    for i in episodes:\n        if i not in remains:\n            continue\n        remains.remove(i)\n        while pre in remains:\n            remains.remove(pre)\n            pre -= 1\n        while next in remains:\n            remains.remove(next)\n            next += 1\n        long_count = max(long_count, next - pre - 1)\n   return long_count\n```",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "hash"
        ]
    },
    {
        "name": "根据访问日志统计出头条每日最火的n篇文章",
        "desc": "每日的访问日志记录有文章id，简化起见，访问的文章id存在输入数组中，给定n，要求返回查看次数最多的文章id\n\n例如：visit_log = [ 10001, 1002, 10001, 20032, 302, 302]\n\n如果n = 2，则根据上面的访问日志，不难看出[10001、302]是最火的2篇文章\n",
        "answer": "首先对访问日志的文章id做计数，然后根据计数做排序得到top n。\n\n在排序方法选择方面，top n适合用堆来实现。\n\n``` python\ndef top_article_id(visit_log, n):\n\tarticle_cnt = collections.Counter()\n\tfor article_id in visit_log:\n\t\tarticle_cnt[article_id] += 1\n\theap = article_cnt.keys()\n\t\n\tdef _heap_adjust(heap, parent, heap_size, article_cnt):\n\t\twhile parent < heap_size:\n\t\t\tleft, right = parent * 2 + 1, parent * 2 + 2\n\t\t\tswap_pos = parent\n\t\t\tif left < heap_size and article_cnt[heap[left]] < article_cnt[heap[parent]]:\n\t\t\t\tswap_pos = left\n\t\t\tif right < heap_size and article_cnt[heap[right]] < article_cnt[heap[swap_pos]]:\n\t\t\t\tswap_pos = right\n\t\t\tif swap_pos != parent:\n\t\t\t\theap[parent], heap[swap_pos] = heap[swap_pos], heap[parent]\n\t\t\t\tparent = swap_pos\n\t\t\telse:\n\t\t\t\tbreak\n\n\tfor i in range(int(math.ceil(n / 2) - 1), -1, -1):\n\t\theap_adjust(heap, i, n, article_cnt)\n\tfor i in range(n, len(heap)):\n\t\tif article_cnt[heap[0]] < article_cnt[heap[i]]:\n\t\t\theap[0] = heap[i]\n\t\t\theap_adjust(heap, 0, n, article_cnt)\n\treturn heap[:n]",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "排序",
            "堆",
            "统计"
        ]
    },
    {
        "name": "实现字典树",
        "desc": "字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\n\n它有3个基本性质：根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。\n\n请实现字典树Class，并完成单词插入和查找函数。",
        "answer": "参考实现代码：\n``` python\nclass TrieNode(object):\n    def __init__(self):\n        self.is_leaf = False\n        self.children = [None] * 26\n        \nclass Trie(object):\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        if not word:\n            return\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                cur_node.children[index] = TrieNode()\n            cur_node = cur_node.children[index]\n        cur_node.is_leaf = True\n        \n    def search(self, word):\n        if not word:\n            return False\n        cur_node = self.root\n        for char in word:\n            index = ord(char) - ord('a')\n            if not cur_node.children[index]:\n                return False\n            cur_node = cur_node.children[index]\n        return cur_node.is_leaf\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "Trie"
        ]
    },
    {
        "name": "36进制正整数加法",
        "desc": "36进制由0-9，a-z，共36个字符表示，最小为'0'\n\n'0'~'9'对应十进制的0~9，'a'~'z'对应十进制的10~35\n\n例如：'1b' 换算成10进制等于 1 * 36^1 + 11 * 36^0 = 36 + 11 = 47\n\n要求按照加法规则计算出任意两个36进制正整数的和\n\n如：按照加法规则，计算'1b' + '2x' = '48'\n\n要求：**不允许把36进制数字整体转为10进制数字，计算出10进制累加结果再转回为36进制**\n\n本题可任意改变进制，如加入大写字母变为62进制。",
        "answer": "``` python\ndef add(num1, num2):\n    '''\n    &gt;&gt;&gt; add('', '')\n    ''\n    &gt;&gt;&gt; add('', '1')\n    '1'\n    &gt;&gt;&gt; add('ab', '')\n    'ab'\n    &gt;&gt;&gt; add('1b', '2x')\n    '49'\n    &gt;&gt;&gt; add('0', '2x')\n    '2x'\n    &gt;&gt;&gt; add('zz', '1')\n    '100'\n    '''\n    def _get_value(num):\n        if ord('0') <= ord(num) <= ord('9'):\n            return ord(num) - ord('0')\n        return ord(num) - ord('a') + 10\n\n    def _to_chr(num):\n        if 0 <= num <= 9:\n            return str(num)\n        return chr(ord('a') + num - 10)\n\n    def _add(n1, n2, carry):\n        result = _get_value(n1) +  _get_value(n2) + carry\n        carry = 1 if result &gt;= 36 else 0\n        result %= 36\n        return _to_chr(result), carry\n\n    len1, len2 = len(num1), len(num2)\n    if len1 &gt; len2: # 取巧：把两个数字长度对齐\n        num2 = '0' * (len1 - len2) + num2\n    elif len2 &gt; len1:\n        num1 = '0' * (len2 - len1) + num1\n    res = []\n    carry = 0\n    for i in xrange(max(len1, len2) - 1, -1, -1):\n        tmp, carry = _add(num1[i], num2[i], carry)\n        res.append(tmp)\n    if carry:  # 易错点：很容易遗漏\n        res.append('1')\n    return ''.join(res[::-1])  # 易错点：需要翻转\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "字符串",
            "编程",
            "基础",
            "基础算法"
        ]
    },
    {
        "name": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数",
        "desc": "数列（顺序为: 一堆负数 + 一堆 0 + 一堆正数），求最后一个出现的负数和第一个出现的正数的位置，从 1 开始计数。例如：\n-2，-1，0，0，0，0，4，5\n最后一个负数出现的位置为：2，第一个正数出现的位置为7。",
        "answer": "1. 二分查找 0 的位置;\n2. 注意边界位置 0 的处理，在二分条件上需要做一些处理，如果只是找到 0 的位置然后遍历找到第一个和最后一个 0 的话， 复杂度为恶化;\n3. 整体复杂度为 O(lg(n));",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "查找",
            "基础算法"
        ]
    },
    {
        "name": "青蛙跳石子",
        "desc": "在长度为m的地面格子上，每个格子里面有一些石子；有一只青蛙, 从格子开始处起跳，每次可以跳3到5个格子，求青蛙跳出格子最少需要踩几个石子；",
        "answer": "简单DP\ndp[i]表示调到第i的位置最少需要踩几个石子;\n于是dp[i]可由dp[i-3], dp[i-4], dp[i-5]得来;",
        "types": [
            "数据结构与算法",
            "动态规划"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "给定一个字符串如下，请统计字符串中出现最多的字母和次数",
        "desc": "```javascript\nfunction findMaxDuplicateChar(str) {\n       let maxChar = '', maxValue = 1;\n    // 补全代码.....\n    return {\n        maxChar,\n        maxValue\n    };\n}\nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "answer": "```javascript\nfunction findMaxDuplicateChar(str) {\n    if (str.length === 1) {\n        return str;\n    }\n    const charObj = {};\n    let maxChar = '', maxValue = 1;\n    for(let i = 0; i < str.length; i++) {\n        if (str[i].trim() !== '') {\n            if (!charObj[str.charAt(i)]) {\n                charObj[str.charAt(i)] = 1;\n            } else {\n                charObj[str.charAt(i)] += 1;\n            }\n        }\n    }\n    for (const k in charObj) {\n        if (charObj[k] &gt;= maxValue) {\n            maxChar = k;\n            maxValue = charObj[k];\n        }\n    }\n    return {\n        maxChar,\n        maxValue\n    };\n}\n \nconst str = 'this is a fe test at toutiao on September';\nfindMaxDuplicateChar(str) // output: { maxChar:&#34;t&#34;, maxValue:7 }\n```",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表",
            "基础算法",
            "统计"
        ]
    },
    {
        "name": "数组排序",
        "desc": "<p>输入数组nums，要求输出升序排序后的结果。已知数组元素为非负整数，且当数组长度为n时，所有元素的值都小于n；</p><p>例：</p><p>[3, 2, 1, 3, 5, 0]  -&gt; [0, 1, 2, 3, 3, 5]</p><p>[0] -&gt; [0]</p>",
        "answer": "<p>O(n2)的排序算法：冒泡排序，插入排序，选择排序 等；</p><p>O(nlog(n))的排序算法：归并排序，快排 等；</p><p>O(N)的排序算法：空间换时间，利用计数实现，需要O(n)空间复杂度；</p><p><br></p><p><br></p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": []
    },
    {
        "name": "二叉树转换成双向链表",
        "desc": "转换结果满足下面条件：\n1. 不要新建一个链表空间，要原地做；直接使用 left 和 right 指针\n2. 转换后的双向链表节点顺序要与中序遍历的结果一致\n3. 二叉树最左边的节点作为双向链表的头节点\n\n例如:\n二叉树:\n\n                    1\n            2                3\n        4        5        6        7\n\n双向链表: 4 <-&gt; 2 <-&gt; 5 <-&gt; 1 <-&gt; 6 <-&gt; 3 <-&gt; 7",
        "answer": "二叉树遍历；递归；链表操作\n\n原理上看，对根节点、根的左子树、根的右子树分别作处理：\n1. 比如根节点1， 对于左子树，找到它的最右节点 5， 把 5 和 1 连接起来；\n2. 对于 1 的右子树，找到它的最左节点 6，把 6 和 1 连接起来。\n\n实现上，假设已经把左子树变做双向链表了，让指针一直向右走，就能找到最右节点和根连接；\n右子树同理。\n\n返回结果的时候，找到双向链表的最左节点就可以了。\n\n```\n    private Node convertToDoublyLinkedList(Node root) {\n        if (root.getLeft() != null) {\n            Node left = convertToDoublyLinkedList(root.getLeft());\n            while (left.getRight() != null) {\n                left = left.getRight();\n            }\n            left.setRight(root);\n            root.setLeft(left);\n        }\n         \n        if (root.getRight() != null) {\n            Node right = convertToDoublyLinkedList(root.getRight());\n            while (right.getLeft() != null) {\n                right = right.getLeft();\n            }\n            right.setLeft(root);\n            root.setRight(right);\n        }\n        return root;\n    }\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "链表"
        ],
        "tags": [
            "双向链表"
        ]
    },
    {
        "name": "翻转单词",
        "desc": "给定一个字符串，逐个翻转字符串中的每个单词。",
        "answer": "根据情况，选择栈和队列即可\n栈必须，队列可选",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "字符串"
        ]
    },
    {
        "name": "两个数的和相加",
        "desc": "<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p><p>输出：7 -&gt; 0 -&gt; 8</p><p>原因：342 + 465 = 807</p>",
        "answer": "<p><br></p>",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "二叉树所有根到叶子路径组成的数字之和",
        "desc": "二叉树每个节点的value范围是1-9\n\n例如：\n```\n\t\t   1\n\t 2\t\t    3 \n 4\t  5\n```\n从根到叶子共3条：1-&gt;2-&gt;4, 1-&gt;2-&gt;5, 1-&gt;3\n\n构成的数字为124，125，13，求和124 + 125 + 13 = 262即为所求",
        "answer": "``` python\ndef tree_path_sum(root, val):\n\tif not root:\n\t\treturn 0\n\tval = val * 10 + root.val\n\tif not root.left and not root.right:\n\t\treturn val\n\treturn tree_path_sum(root.left, val) + tree_path_sum(root.right, val)\n```",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "三门问题/蒙蒂大厅难题",
        "desc": "你面前有三扇门，每个门后都有一个奖品，其中一个是一辆车，另外两个是山羊。\n你首先挑选一扇门，姑且称之为A，其他两个门分别是B和C。\n在打开你选择的门前，我先从B和C中选择一个没有车的门打开。\n给你一个选择，你是坚持最开始的选择还是换到剩下未打开的门上？\n\n如果我打开门的策略从随机选择，变成总是优先选择门B，只有在迫不得已的时候选择C。\n问结果有变化么？",
        "answer": "使用贝叶斯公式求解，p(a|b)*p(b) = p(a)*p(b|a)\n三种假设，即假设车在门A，门B，门C后面。\nD表示打开了门B但是车不在门后。\n假设A：先验概率=1/3，似然度=1/2，后验概率=(1/3)*(1/2)/(1/2)=1/3\n假设B：先验概率=1/3，似然度=0, 后验概率=0\n假设C：先验概率=1/3，似然度=1，后验概率=2/3\n\n变化之后概率相同。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": [
            "贝叶斯",
            "概率"
        ]
    },
    {
        "name": "海盗分金问题",
        "desc": "5个海盗要分100块金币，分配的协议是：按顺序一个一个来，轮到当前的海盗，他提出一个分配方案，如果包括他在内至少有50%的人同意，那么方案通过，否则这个海盗就会被喂鲨鱼，下一个海盗继续提出分配方案。 \n假设海盗都是纯理性而且冷血的，他们的第一原则是生存，第二原则就是拿到尽可能多的金子，第三原则是如果给的金币一样，他们倾向于选择有更少的海盗的分配方案。",
        "answer": "思路： \n5个人太多了，首先把问题简化。从1个人到5个人逐个分析。\n* 1个人，显然自己全拿\n* 2个人。1，2。2号海盗显然可以全部拿走，因为他自己的一票保证了50%。\n* 3个人。1，2，3。首先，如果3号的方案没通过，那么1号将什么都得不到，而2号必定要除3号而后快。因此3号必须征得1号的支持，但又不能完全不给1号任何金币（第三原则）。因此分配方案是1 2 3 = 1 0 99。这样3号的方案能够得到1和3的支持。\n* 4个人。1，2，3，4。首先，如果4号的方案没通过，那么2号将什么都得不到。因此4号只需要分配1 2 3 4 = 0 1 0 99\n* 5个人。1，2，3，4，5。5号清楚的知道一旦他的方案不通过，1和3将什么都得不到，因而他只需要分配1 2 3 4 5 = 1 0 1 0 98，这样即足以保证。",
        "types": [
            "数据结构与算法",
            "数学基础"
        ],
        "tags": []
    },
    {
        "name": "牛过河",
        "desc": "<p><strong>有一堆牛要过河，河的长度是ｌ，河中间有ｎ个石头，牛只能踩着石头过河，问去掉ｍ个石头后（去掉这ｍ个石头的方式是随机的）的每种情况牛能走的石头间距最小值中，最大的那一个是多少</strong></p>",
        "answer": "<p>二分最大值最小化问题</p>",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找"
        ]
    },
    {
        "name": "求二叉树是否存在和值为N的路径",
        "desc": "从二叉树的根到叶子节点称为一条路径\n\n路径上每个节点的value之和为路径和值\n\n本题要求所有的路径中是否存在一条和值为N的。\n\nfollow-up：可以要求返回所有符合条件的路径",
        "answer": "要求自己给出二叉树数类定义\n\n本题很容易用递归解决，基本思路如下：\n\n```\ndef path_exists(root, n):\n\tif not root:\n\t\treturn False\n\tif not root.left and not root.right and root.value == n:\n\t\treturn True\n\treturn path_exists(root.left, n - root.value) or path_exists(root.right, n - root.value)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "special trim",
        "desc": "对输入的字符串，去除其中的字符'b'以及连续出现的'a'和'c'\n\n例如：\n\n'aacbd' -&gt; 'ad'\n\n'aabcd' -&gt; 'ad'\n\n'aaabbccc' -&gt; ''\n\n不允许使用类似string.replace函数。要求时间、空间复杂度尽量优化",
        "answer": "本题不好处理的是aaabccc，即：c和a相遇就要都去掉。\n\n比较好的思路是用栈的思路解决。\n\n``` python\ndef special_trim(s):\n    if not s:\n        return s\n    res = []\n    for c in s:\n       if c == 'b':\n            continue\n       if c == 'c' and res and res[-1] == 'a':\n            res.pop()\n            continue\n       res.append(c)\n    return ''.join(res)\n```",
        "types": [
            "数据结构与算法",
            "堆栈"
        ],
        "tags": [
            "栈",
            "字符串"
        ]
    },
    {
        "name": "约瑟夫问题",
        "desc": "假设有n个人，标号为1-n。\n从第一个人开始计数，到第k个人则出列，随后从第k+1个人重新计数，到第k再出列。\n直至剩下最后一个人。问最后剩下的人的编号？",
        "answer": "考察链表使用。最简单直接的方法是使用循环链表。\n具体思路是：\n1. 构建循环链表，初始化数据；\n2. 每到第k-1个结点，便p-&gt;next = p-&gt;next-&gt;next。\n3. 循环结束条件为p = p-&gt;next，即只有一个结点，该结点所对应的值即为最后剩下的人。",
        "types": [
            "数据结构与算法",
            "链表"
        ],
        "tags": []
    },
    {
        "name": "二叉搜索树中的第K小的元素",
        "desc": "给定二叉搜索树，求所有元素中第k小的。k<=节点总数",
        "answer": "结合BST的性质，用递归很好解决，按照中序遍历即可\n核心代码：\n``` python \ndef find_k_small(root, k):\n\tdef _find(root):\n\t\tif not root:\n\t\t\treturn -1\n\t\tval = _find(root)\n\t\tif not k:\n\t\t\treturn val\n\t\tk -= 1\n\t\tif not k:\n\t\t\treturn root.val\n\t\treturn _find(root)\n\t_find(root)\n```",
        "types": [
            "数据结构与算法",
            "树",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "序列化和反序列化二叉树",
        "desc": "将一棵二叉树序列化为字符串，并能字符串反序列为一棵树。",
        "answer": "本题解法应该有不少，大体思路是按照某种遍历的顺序记录下每个节点，叶子节点的空指针可以用特殊字符表示\n\n例如用先根遍历解决：\n``` python \n    def serialize(root):\n        def pre_order(node):\n            if node:\n                vals.append(str(node.val))\n                pre_order(node.left)\n                pre_order(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        pre_order(root)\n        return ' '.join(vals)\n\n    def deserialize(data):\n        def pre_order():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = pre_order()\n            node.right = pre_order()\n            return node\n            \n        vals = iter(data.split())\n        return pre_order()",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": []
    },
    {
        "name": "带过期和最大对象数限制的LRU-CACHE",
        "desc": "设计一个对象cache, 他支持下列两个基本操作:\nset(id, object), 根据id设置对象;\nget(id): 根据id得到一个对象;\n同时它有下面几个性质:\n1: x秒自动过期, 如果cache内的对象, x秒内没有被get或者set过, 则会自动过期;\n2: 对象数限制, 该cache可以设置一个n, 表示cache最多能存储的对象数;\n3: LRU置换, 当进行set操作时, 如果此时cache内对象数已经到达了n个, 则cache自动将最久未被使用过的那个对象剔除, 腾出空间放置新对象;\n请你设计这样一个cache;",
        "answer": "通过组合一些基本的数据结构, \n来实现一些更高级的性质;\n\n内部维护一个链表, list, 其元素为一个三元组(ID, timestamp, obj), 分别为对象ID, 上次被访问时间, 和对象内容;\n在维护该list时, 需要保持一个性质, 越靠后的元素越新, 既timestamp越大;\n内部再维护一个map, 该map表示一个ID到list节点的索引, 格式为map(ID, node);\n对于get(id)操作:\n1: 先在map中查找ID对应的list node;\n2: 将node从list中取出, 即list.Remove(node);\n3: 检查node.timestamp, 如果过期, 则返回null, 表示无数据, 并将ID从map中删除;\n4: 如果未过期, 设置node.timestamp = now(), 并将node添加到list尾部, 即list.Append(node);\n5: 返回node.obj;\n对于set(id, obj)操作:\n1: 同get(id)的1~3步操作, 删除对应的ID;\n2: 如果此时空间满了, 既对象数为n, 则将list中表头的那个元素删除;\n3: 更新list和map: node = new(ID, now(), obj), list.Append(node), map[ID] = node;",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "数据存储",
            "基础算法",
            "lru",
            "cache"
        ]
    },
    {
        "name": "n sum",
        "desc": "<p>输入一维数组array和n，找出和值为sum的n个元素即可，不用找出所有组合。</p><pre><code>array = [2, 3, 1, 10, 4, 30] n = 2, sum = 31\nresult = find(array, n, sum)\n// result = [1, 30]</code></pre><p><br></p>",
        "answer": "<p>基础解法供参考</p><pre><code>function find(arr, n, sum, shouldSort = true) {\n let sorted = arr;\n if (shouldSort) {\n  sorted = arr.sort();\n }\n const length = sorted.length;\n if (n === 2) {\n  let front = 0;\n  let back = length - 1;\n  while(front < back) {\n   const value = sorted[front] + sorted[back];\n   if (value === sum) {\n    return [sorted[front], sorted[back]];\n   } else if (value &gt; sum) {\n    back -= 1;\n   } else {\n    front += 1;\n   }\n  }\n  return null;\n }\n for(let i = 0; i < length; i += 1) {\n  const val = sorted[i];\n  const result = find(sorted.slice([i + 1]), n - 1, sum - val, false);\n  if (!result) {\n   return null;\n  } else {\n   return [val, ...result];\n  }\n }\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": [
            "哈希表",
            "算法"
        ]
    },
    {
        "name": "多叉树广度优先遍历查找",
        "desc": "<p>要求：</p><ol><li>自定义多叉树节点node结构（只需要定义节点结构即可，无需构建树）</li><li>按照广度优先查找符合要求的节点（没有符合要求的节点返回null），比如查找电话号码为 phone的用户信息，调用如下：</li></ol><p><br></p><pre><code>let node = wideTraversal(node,(e)=&gt;e.phone===phone)</code></pre><p><br></p>",
        "answer": "<p>节点定义：</p><pre><code>  // 定义树节点\nNode {\n  ... // 属性\n  children:[], // 子节点\n}</code></pre><p><br></p><p>实现：</p><pre><code>wideTraversal(node: Node, predict): Node | null {\n  if (!node) return null\n  let queue: Array<Node&gt; = [];\n  queue.push(node)\n  while (queue.length) {\n    let cur = queue.shift()\n    if (!cur) continue\n    if (predict(cur)) return cur\n    if (cur.children&amp;&amp; cur.children.length) {\n      queue.push(...cur.children)\n    }\n  }\n  return null\n}</code></pre><p><br></p>",
        "types": [
            "数据结构与算法",
            "树"
        ],
        "tags": [
            "广度优先遍历",
            "前端编码",
            "多叉树"
        ]
    },
    {
        "name": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点",
        "desc": "给定无向图和它一个顶点，求无向图中到该顶点距离为K的所有点，各个相邻顶点间距离为1",
        "answer": "方案：对图进行K步的BFS, 注意处理被重复走过的点;\n",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "输出所有根节点到叶子节点的路径",
        "desc": "比如:\n\n            1\n          2   3\n         4  5 6  7\n                  8\n\n输出：\n\n    1，2，4\n    1，2，5\n    1，3，6\n    1，3，7，8\n",
        "answer": "二叉树遍历",
        "types": [
            "数据结构与算法",
            "树",
            "递归",
            "堆栈"
        ],
        "tags": [
            "基础算法"
        ]
    },
    {
        "name": "找出旋转有序数组中的最小值",
        "desc": "假设原数组为1，2，3，4，5那4，5，1，2，3就是旋转有序的数组\n\n注：数组无重复元素",
        "answer": "暴力可以O(n)，但没用到旋转有序的特征。\n\n本题可以用二分的思想降低时间复杂度\n\n定义左右两个指针left、right指向头尾元素\n\n如果a[left] < a[right]则没有移位，直接输出a[left]即可，反之二分搜索。\n\n如果a[left] &gt; a[mid] 则要搜索右半段，因为a[left]也大于a[right]；反之搜索左半段。\n\n核心代码\n``` python\ndef find_min(arr):\n\tleft, right = 0, len(arr) - 1\n\tif arr[left] < arr[right]:\n\t\treturn arr[left]\n\twhile left != right - 1:\n\t\tmid = left + (right - left) / 2\n\t\tif arr[left] < arr[mid]:\n\t\t\tleft = mid\n\t\telse:\n\t\t\tright = mid\n\t\treturn min(arr[left], arr[right])\n\t\t",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "查找",
            "有序数组"
        ]
    },
    {
        "name": "搜索二维矩阵",
        "desc": "给定二维m * n矩阵matrix，满足一定特性：\n1. 每行从左到右递增\n2. 每列从上到下递增\n给定目标元素num，判断num是否在矩阵中存在\n\n例如：\n``` python \nmatrix = [\n\t[1, 3, 5, 10],\n\t[2, 4, 6, 11],\n\t[7, 9, 12, 20],\n]\n```\nnum = 4存在；num = 13不存在\n",
        "answer": "结合数组定义，观察例子，有两个特殊位置很特殊：左下角和右上角。\n\n左下角的7往上所有的数变小，往右所有的数变大。\n\n那么我们就可以将目标数字num和左下角比较，比目标小就往右搜，比目标大就往上搜。\n\n如此往复可以判断num是否在matrix中。\n\n``` python\ndef search(matrix, num):\n\tif not matrix:\n\t\treturn False\n\trows, cols = len(matrix), len(matrix[0])\n\tif num < matrix[0][0] or num &gt; matrix[rows - 1][cols - 1]:\n\t\treturn False\n\ti, j = rows - 1, 0 # 左下角\n\twhile i &gt;= 0 and j < cols:\n\t\tif matrix[i][j] < num:\n\t\t\tj += 1\n\t\telif matrix[i][j] &gt; num:\n\t\t\ti -= 1\n\t\telse:\n\t\t\treturn True\n\treturn False\n```",
        "types": [
            "数据结构与算法",
            "数组"
        ],
        "tags": []
    },
    {
        "name": "扑克牌的堆栈、队列操作",
        "desc": "我手中有一堆扑克牌， 但是观众不知道它的顺序。\n\n*  第一步， 我从牌顶拿出一张牌， 放到桌子上。\n*  第二步， 我从牌顶再拿一张牌， 放在手上牌的底部。\n*  第三步， 重复第一步的操作， 直到我手中所有的牌都放到了桌子上。 \n\n最后， 观众可以看到桌子上牌的顺序是：13\\12\\11\\10\\9\\8\\7\\6\\5\\4\\3\\2\\1\n请问， 我刚开始拿在手里的牌的顺序是什么？",
        "answer": "解法一：\n这道题候选人容易出现折半的思路， 其实考虑的复杂了。 \n本质是将一个队列和栈做了两个操作\n1. 出队、入栈\n2. 出队、入队（队尾）\n\n因为是看得到结果， 看不到初始顺序， 那么这个操作就是一个逆操作。 \n1. 出栈、入队\n2. 出队（队尾）、入队（队首）\n答案：\n输入：\n1,2,3,4,5,6,7,8,9,10,11,12,13,\n输出：\n1,12,2,8,3,11,4,9,5,13,6,10,7,\n\n代码如下\n``` C++ 再改改\nint doTheWork(std::deque * pQ, std::stack * pS)\n{\n        if(NULL == pQ or NULL == pS)\n                return -1;\n        while(pS-&gt;size() &gt; 0)\n        {\n                int val = pS-&gt;top();\n                pS-&gt;pop();\n                if (pQ-&gt;size() &gt; 0)\n                {\n                        int tmp = pQ-&gt;back();\n                        pQ-&gt;pop_back();\n                        pQ-&gt;push_front(tmp);\n                        pQ-&gt;push_front(val);\n                }\n                else\n                {\n                        pQ-&gt;push_front(val);\n                }\n        }\n        return 0;\n}\n```\n\n解法二：\n对手上牌按照a，b，c...进行编码，直接按顺序操作，输出结果和桌上实际结果对应，即为原手上牌的顺序。",
        "types": [
            "数据结构与算法",
            "队列",
            "堆栈"
        ],
        "tags": [
            "栈"
        ]
    },
    {
        "name": "用js实现一个binarySearch二分查找",
        "desc": "定一个一个binarySearch的函数，传参能支持四个参数，分别是：\n&gt;1. arr: 一个数组，\n&gt;1. key: 一个需要查找的目标值，\n&gt;1. low: 左边界\n&gt;1. high: 右边界\n&gt;1. 如果能知道则访问素组的位置，否则返回-1\n```javascript\nfunction binarySearch(){\n  // 补全代码\n}\nvar arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\nvar result = binary_search2(arr, 5, 0, 6);\nconsole.log(result);   // 4\n```",
        "answer": "二分法查找，也称折半查找，是一种在有序数组中查找特定元素的搜索算法。查找过程可以分为以下步骤：\n&gt;1. 首先，从有序数组的中间的元素开始搜索，如果该元素正好是目标元素（即要查找的元素），则搜索过程结束，否则进行下一步。\n&gt;1. 如果目标元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半区域查找，然后重复第一步的操作。\n&gt;1. 如果某一步数组为空，则表示找不到目标元素。\n```javascript\n // 递归实现的js代码\n  function binary_search2(arr, key, low, high) {\n    if(low &gt; high) {\n      return -1;\n    }\n    var mid = parseInt((high + low) / 2);\n    if(arr[mid] == key) {\n      return mid;\n    } else if(arr[mid] &gt; key) {\n      high =mid -1;\n      return binary_search2(arr, key, low, high);\n    } else if(arr[mid] < key) {\n      low = mid +1;\n      return binary_search2(arr, key, low, high);\n    }\n  }\n\n  var arr = [86,1,3,2,4,5,6,7,8,9,10,11,23,44];\n  var arrSorted = arr.sort(function (a,b) {\n    return a-b;\n  })\n  var result = binary_search2(arrSorted, 5, 0, 10);\n  console.log(result);   // 4\n```",
        "types": [
            "数据结构与算法",
            "递归"
        ],
        "tags": [
            "查找",
            "js"
        ]
    },
    {
        "name": "通配符匹配",
        "desc": "给定字符串s和模式串p，实现函数match(s, p)，判断模式串p是否能完全匹配s\n\n模式串中有两个特殊字符'?'和'*'\n\n'?'匹配任意1个字符；'* '匹配任意r个字符，包括空\n\n例如:\n``` python\nmatch('a', 'a') = True\nmatch('aa', 'a') = False\nmatch('a', '?') = True\nmatch('aa', '*') = True\nmatch('abc', '?*') = True\n```",
        "answer": "本题可以用DP算法来解答。\n\n用dp[i, j]表示串s, p这两个串分别到i和j位置它们是否匹配。那么我们得到递推关系：\n\n如果p[j] != '* ', dp[i, j] = dp[i-1, j-1] and (s[i] == p[j] || p[j] == '?') \n\n如果p[j] == '* ', 那么dp[i][j] = dp[i - 1][j] || dp[i][j - 1]\n\n``` python\ndef match(s, p):\n\tm, n = len(s), len(p)\n\tdp = [[False] * (n + 1) for _ in range(m + 1)]\n\tdp[0][0] = True\n\tfor j in range(1, n + 1):\n\t\tdp[0][j] = dp[0][j - 1] and p[j - 1] == '*'\n\tfor i in range(1, m + 1):\n\t\tfor j in range(1, n + 1):\n\t\t\tif p[j - 1] in [s[i - 1], '?']:\n\t\t\t\tdp[i][j] = dp[i-1][j-1]\n\t\t\telif p[j - 1] == '*':\n\t\t\t\tdp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\treturn dp[m][n]\n```\n另外，本题也可以用贪心算法",
        "types": [
            "数据结构与算法",
            "动态规划",
            "贪心"
        ],
        "tags": []
    },
    {
        "name": "原子计数问题",
        "desc": "给出一个分子式，比如：\n     HMg2(H2O(N3Ag)2)3N2\n计算这个分子式中每个原子出现了多少次，输出一个 map，比如上面的分子式中：\nmap[string]int {&#34;H&#34;: 7, &#34;Mg&#34;: 2,&#34;Ag&#34;: 6, ...}\n\n分子式的规则：\n1. 都以大写字母开头，后面跟 0 个或者 1 个小写字母，比如 Mg, H\n2. 单个原子后面跟 0 个或者 1 个数字表示它出现的次数，比如 Mg2 表示 Mg 出现 2 次，数字范围 [2-1000]\n3. 分子式中可能有括号，括号后面可能跟 0 个或者 1 个数字表示整个括号内的原子出现的次数，比如 (N3Ag)2 表示 N出现 6 次，Ag 出现 2 次\n4. 括号可以嵌套\n\n输入是合法的\n",
        "answer": "1. 最简单的方法是递归，碰到 ( 就开始递归\n2. 担心爆栈就把递归改成非递归\n3. 可以用正则表达式来做，这里不展开了，如果候选人懂的话让他解释",
        "types": [
            "数据结构与算法",
            "递归",
            "堆栈"
        ],
        "tags": [
            "校招类",
            "编程",
            "代码类",
            "基础算法",
            "字符串"
        ]
    },
    {
        "name": "安卓解锁密码数",
        "desc": "安卓系统采用9个点连线构成图案密码。\n\n要求连接以下9个点中**至少4个点**构成一条路径，从而得到1个密码。\n\n1 2 3\n\n4 5 6\n\n7 8 9\n\n任意点间均可连线，都有如下附加限制：\n1. 在一个密码路径里每个点只能用1次；\n2. 如果2号点没有被连，则1不能直接连3号点，即：1-&gt;3路径是非法的。类似情况还有1、7；2、8；1、9等等；\n3. 如果2点已经连过了，则1可以连到3，3也可以连到1，即：2-&gt;1-&gt;3路径是合法的。\n4. 1和6是可以直接连线的，因为二者之间没有点。\n\n本问题求所有的密码数，也就是路径数，包含4个点、5个点。。。9个点的所有路径数。",
        "answer": "本题目如果数据结构算法比较熟悉，会很快想到DFS。\n\n难点是路径不能直达问题如何解决？\n\n用visit记录某个点是否已经在路径中\n\n``` python\nvisit = [[0, 0 ,0],\n         [0, 0, 0],\n         [0, 0, 0]]\n```\n\n判断两个点能否连同，等价于判断两个点是否存在中间点问题，如果不存在可以直接连，如果存在要判断中间点是否已经访问过了。\n\n中间点坐标为：|i1 - i2| / 2, |j1 - j2| / 2\n\n另外，本题考虑到对称性会大大降低运算量\n\n1、3、7、9点对称\n\n2、4、6、8点对称",
        "types": [
            "数据结构与算法",
            "图",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "矩阵中的最长递增路径",
        "desc": "给定m * n矩阵matrix，可以从任意位置开始，向上、向下、向左、向右移动，但要求下一个位置上的元素要大于当前元素。\n\n找出最长的递增路径长度。",
        "answer": "本题很容易想到dfs，但问题是每个点开始递归搜索，重复计算很多，结合DP提升效率。\n\n用dp[i][j]表示从(i,j)开始的最长递增路径长度，当递归调用时，如果dp[i][j]不为0，直接返回dp[i][j]。\n\n``` python\ndef long_increase_path_len(matrix):\n\tif not matrix:\n\t\treturn 0\n\tres = 1\n\tm, n = len(martix), len(matrix[0])\n\tdp = [[0] * n for _ in range(m)]\n\tfor i in range(m):\n\t\tfor j in range(n):\n\t\t\tres = max(res, dfs(matrix, dp, i, j, m, n))\n\treturn res\n\ndef dfs(matrix, dp, i, j, m, n):\n\tif dp[i][j]:\n\t\treturn dp[i][j]\n\ttmp_max = 1\n\tdirs = [[0, -1], [-1, 0], [0, 1], [1, 0]]:\n\tfor ni, nj in dirs:\n\t\tii, jj = i + ni, j + nj\n\t\tif ii < 0 or ii &gt;= m or jj < 0 or jj &gt;= n or matrix[ii][jj] <= matrix[i][j]:\n\t\t\tcontinue\n\t\ttmp_max = max(tmp_max, 1 + dfs(matrix, dp, ii, jj, m, n)\n\tdp[i][j] = tmp_max\n  return dp[i][j]\n```",
        "types": [
            "数据结构与算法",
            "动态规划",
            "递归"
        ],
        "tags": []
    },
    {
        "name": "升序数组求平方数不同的个数",
        "desc": "给定一个升序数组1，元素有重复，对每个元素算一下平方后得到新的数组2，问数组2中不相同的元素共有多少个？给出算法和空间复杂度，要求尽量优化。\n举例：\n数组1 [-13,-10,-9,-6,-5,-1,3,4,6,7,10,11,15,21,42]\n平方后得到\n数组2 [169,100,81,36,25,1,9,16,36,49,100,121,225,441,1764]\n其中不相同的元素个数为13个。",
        "answer": "常规解法，按题目思路，先平方算好，再将结果插入hashset，最后输出hashset大小。\n优化1，平方没必要算，其实就是绝对值。\n优化2，注意到数组2其实是以0分隔的一个降序和一个升序数组。反序遍历降序数组，正序遍历升序数组，即可合并成一个升序数组，合并时做一下排重，最后输出合并后数组的元素个数。",
        "types": [
            "数据结构与算法"
        ],
        "tags": [
            "哈希表"
        ]
    }
]
